<!DOCTYPE HTML>
<html>

<!-- HEADER -->
<head>

<meta charset="UTF-8">

<title>"""
rat's nest

{ava "b"}{a = 0}
"""</title>

<script type="text/bitsyGameData" id="exportedGameData">
"""
rat's nest

{ava "b"}{a = 0}
"""

# BITSY VERSION 8.12

! VER_MAJ 8
! VER_MIN 12
! ROOM_FORMAT 1
! DLG_COMPAT 0
! TXT_MODE 0

PAL 0
75,81,55
51,56,41
143,146,138
NAME blueprint

PAL 1
96,34,46
45,3,3
255,2,24
NAME red

ROOM 0
b,b,b,c,f,b,b,b,b,f,f,b,b,b,b,b
b,c,c,c,c,c,f,c,d,f,c,c,c,f,c,b
f,f,c,e,e,0,e,c,d,0,0,d,f,f,c,b
f,c,d,0,0,0,e,0,e,0,0,d,0,d,c,b
b,c,d,0,e,0,0,d,d,0,0,0,0,d,c,b
b,c,c,d,d,0,0,d,0,0,0,0,0,c,c,b
b,c,d,e,0,e,0,0,0,0,0,e,d,d,c,b
b,c,c,0,0,0,0,0,0,0,0,0,0,d,c,b
b,f,c,0,e,e,0,b,0,0,d,0,0,d,d,c
b,d,0,0,0,0,0,0,0,d,d,d,0,0,c,c
b,d,0,d,e,0,0,e,d,d,0,0,0,e,f,b
b,c,0,d,d,d,0,0,d,0,0,0,e,e,f,b
b,c,0,0,d,c,c,d,d,0,d,d,d,0,f,f
b,c,f,c,d,c,c,c,d,d,d,f,c,c,c,b
b,c,f,f,c,c,c,c,c,c,f,f,c,c,c,b
b,b,b,b,b,b,b,b,b,b,b,b,b,b,c,b
NAME gradient room
ITM 0 9,8
ITM 0 8,8
ITM 0 7,6
ITM 0 8,7
ITM 0 8,6
ITM 0 7,8
ITM 0 7,7
ITM 0 9,7
ITM 0 9,6
EXT 9,6 3 8,8 DLG 3
EXT 9,8 3 8,8 DLG 3
EXT 8,8 3 8,8 DLG 3
EXT 7,8 3 8,8 DLG 3
EXT 7,7 3 8,8 DLG 3
EXT 8,6 3 8,8
EXT 7,6 3 8,8 DLG 3
EXT 9,7 3 8,8 DLG 3
PAL 0
TUNE 6

ROOM 3
0,0,0,0,0,x,y,z,10,11,12,13,0,0,0,0
a,0,0,14,0,15,16,17,18,19,1a,1b,1c,1d,1e,0
1f,1g,1h,1i,0,1j,1k,1l,1m,0,1n,1o,1p,1q,1r,1s
1t,1u,1v,1w,1x,1y,1z,20,0,0,21,22,0,23,24,25
26,27,28,29,29,2a,2b,2c,2d,2e,2f,2g,0,2h,0,2i
0,2j,29,0,0,2k,2l,2m,2n,2o,2p,2q,2r,2s,0,2t
2u,2v,0,0,0,2w,2x,2y,2z,30,31,2q,32,33,34,35
36,37,38,39,3a,3b,3c,3d,3e,3f,3g,3h,3i,3j,3k,3l
3m,3n,3o,3p,3q,3r,3s,3s,3s,3s,3t,3u,3v,3w,3x,3y
3z,40,41,42,3s,43,44,45,46,47,48,49,4a,4b,4c,4d
4e,4f,4g,4h,4i,4j,4k,4l,4m,4n,4o,4p,4q,4r,4s,4t
4u,4v,4w,4x,4y,4z,50,51,52,53,11,54,55,56,57,58
59,5a,5b,5c,5d,5e,5f,5g,5h,5i,5j,5k,5l,5m,5n,5o
5p,5q,5r,5s,5t,5u,5v,5w,5x,5y,5z,60,61,62,63,64
65,66,67,68,69,6a,6b,6c,6d,6e,6f,6g,67,0,6h,6i
6j,6k,0,6l,6m,6n,6o,6p,6q,6r,6s,6t,6u,0,6v,6w
NAME bedroomdresser
ITM 1 8,4
ITM 3 5,8
EXT 2,1 4 7,7
PAL 0

ROOM 4
0,0,dy,0,0,0,0,0,dz,e0,e1,e2,0,0,0,0
0,e3,e4,e5,e6,e7,e8,0,0,e9,0,ea,0,0,0,0
0,eb,ec,ed,ee,7r,0,0,0,ef,eg,eh,ei,0,0,0
ej,ek,el,em,0,en,0,0,0,eo,ep,ea,eq,er,0,0
es,et,eu,0,0,ev,ew,ex,ey,ez,f0,7r,f1,f2,13,0
f3,f4,f5,f6,f7,f8,f9,fa,fb,fc,fd,0,fe,ff,fg,0
fh,fi,fj,fk,fl,fm,fn,fo,fp,fq,fr,2h,fs,ft,fu,0
fv,fw,fx,z,fy,fz,g0,g1,g2,g3,g4,g5,g6,g7,g8,0
g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,gk,gl,gm,gn,0
go,gp,gq,gr,gs,0,gt,gu,gv,gw,gx,gy,gz,h0,h1,0
h2,h3,h4,h5,h6,h7,h8,h9,ha,hb,hc,hd,he,hf,hg,0
hh,hi,hj,hk,0,0,0,0,0,0,hl,hm,hn,ho,hp,0
hq,hr,hs,ht,0,0,0,0,0,0,hu,hv,0,hw,hx,0
hy,hz,i0,i1,i2,i3,i4,i5,i6,i7,i8,i9,0,0,ia,ib
0,ic,0,0,0,0,id,ie,if,ig,ih,ii,ij,0,ik,il
0,0,0,0,0,0,0,im,in,io,ip,iq,0,0,0,ir
NAME bedroom
ITM 6 5,1
ITM 7 14,8
PAL 0

ROOM 5
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
is,it,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,iu,0,0,0,iv,hp,0,0,0,0,0,0,0,0,0
0,iw,ix,iy,iz,j0,j1,j2,j3,0,0,0,0,0,0,0
0,j4,j5,j6,j7,j8,j9,ja,jb,0,0,0,0,0,0,0
hp,jc,jd,je,jf,jg,jh,ji,jj,cw,jk,jl,jm,0,0,0
jn,jo,jp,jq,jr,js,jt,ju,jv,jw,jx,jy,jz,k0,0,0
k1,k2,k3,k4,k5,k6,k7,k8,k9,0,0,ka,0,kb,kc,0
kd,ke,kf,kg,kh,0,ki,kj,kk,kl,6z,km,0,0,kn,0
0,ko,kp,kq,13,26,kr,ks,kt,ku,kv,kw,0,0,kx,0
ky,kz,l0,l1,l2,l3,l4,l5,l6,l7,l8,0,0,0,l9,0
0,la,lb,lc,ld,le,lf,lg,lh,li,lj,0,0,0,lk,0
0,s,ll,lm,ln,lo,lp,lq,lr,ls,lt,lu,13,0,lv,0
0,lw,lx,ly,co,lz,m0,m1,m2,m3,m4,m5,m6,m7,m8,m9
6s,ma,mb,mc,md,me,mf,mg,mh,mi,mj,mk,ml,mm,mn,mo
0,0,7r,0,0,0,0,0,0,0,mp,cs,mq,mr,ms,mt
NAME hallway
ITM 4 6,7
PAL 0

ROOM 6
0,0,0,0,0,0,mu,bm,0,0,0,9z,0,0,0,0
0,0,0,0,mv,mw,mx,0,0,0,my,mz,0,0,0,0
n0,n1,n2,n3,n4,n5,n6,0,0,n7,n8,n9,na,0,nb,0
nc,nd,ne,7r,0,0,0,0,0,0,0,nf,6m,c5,ng,nh
ni,nj,nk,nl,nm,nn,no,np,nq,nr,ns,nt,nu,nv,nw,nx
ny,nz,0,0,o0,0,0,o1,0,0,0,o2,0,o3,o4,o5
o6,o7,o8,o9,oa,ob,oc,od,oe,of,og,oh,oi,oj,ok,ol
om,on,0,0,oo,0,op,oq,0,0,0,or,0,os,0,ot
ou,ov,ow,ox,oy,3s,3s,oz,3s,3s,p0,p1,3s,p2,p3,p4
p5,p6,p7,p7,p8,p9,0,pa,0,0,kv,pb,0,pc,pd,pe
pf,pg,ph,pi,pj,pk,pl,pm,pn,po,pp,pq,pr,ps,pt,pu
pv,pw,px,py,pz,q0,q1,q2,q3,q4,q5,q6,q7,q8,q9,qa
qb,qc,qd,qe,qf,qg,qh,qi,qj,qk,ql,qm,qn,qo,qp,qq
qr,qs,qt,qu,qv,qw,qx,qy,qz,r0,r1,r2,r3,r4,r5,r6
r7,r8,r9,ra,0,6m,rb,rc,rd,re,rf,rg,rh,ri,rj,0
29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME cage up
PAL 0
TUNE 4

ROOM 7
0,0,rk,71,rl,p7,rm,rn,rn,ro,rp,13,0,rq,0,0
0,0,rr,rs,rt,ru,rv,rw,rx,ry,rz,s0,0,s1,0,0
0,0,s2,s3,s4,s5,s6,s7,ea,0,s8,ea,0,or,0,0
0,s9,sa,sb,sc,sd,se,eh,sf,0,sg,sh,si,sj,sk,0
sl,sm,sn,so,sp,sq,sr,ss,eh,st,su,sv,sw,sx,sy,sz
t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,kv,ta,tb,tc,td,te
tf,tg,0,th,ti,tj,tk,tl,si,tm,6m,tn,to,tp,tq,tr
ts,0,0,tt,tu,tv,tw,tx,ty,tz,0,u0,u1,u2,7w,u3
u4,u5,u6,u7,u8,u9,ua,ub,uc,ud,ue,uf,ug,uh,ui,uj
uk,ul,um,un,7r,uo,up,uq,ur,us,ut,uu,uv,uw,ux,uy
uz,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,va,vb,vc,vd,0
ve,vf,vg,vh,vi,vj,vk,vl,vm,vn,vo,vp,vq,vr,vs,vt
vu,vv,vw,vx,0,vy,vz,w0,w1,w2,w3,w4,w5,w6,w7,w8
w9,wa,ic,wb,wc,wd,we,wf,wg,wh,0,wi,wj,wk,wl,wm
wn,0,6z,wo,wp,wq,0,0,6m,wr,ws,wt,kd,wu,wv,ww
wx,0,0,6,0,0,0,0,0,wy,wz,x0,x1,x2,x3,x4
NAME bathroom
ITM 5 3,10
ITM c 10,13
PAL 0

ROOM 8
x5,x6,0,0,0,0,0,0,0,0,0,0,0,s,0,v1
x7,x8,x9,0,0,0,0,0,0,0,0,0,s,xa,e3,xb
0,0,0,0,xc,xd,xe,xf,xg,xh,xi,xj,51,xk,xl,xm
0,0,0,0,xn,xo,cs,xp,0,0,xq,pc,xr,0,xs,xt
0,xu,xv,xw,xx,xy,xz,y0,0,0,y1,y2,bm,ix,y3,s
0,y4,y5,y6,y7,y8,y9,0,7w,0,ya,yb,bz,yc,0,yd
0,ye,yf,yg,or,yh,0,0,yi,yj,yk,yl,ym,yn,yo,0
0,yp,yq,yr,ys,52,yt,yu,yv,yw,yx,or,yy,yz,z0,z1
0,z2,z3,z4,z5,52,p7,p7,z6,z7,z8,z9,za,zb,zc,0
0,zd,ze,zf,zg,zh,zi,zj,zk,zl,zm,zn,0,0,zo,zp
cw,0,0,85,zq,zr,zs,zt,zu,0,p7,ce,0,zv,zw,zx
os,zy,0,zz,100,101,102,103,104,105,106,3s,107,0,108,109
10a,10b,10c,10d,10e,10f,10g,10h,10i,10j,10k,10l,10m,10n,0,0
10o,10p,10q,0,10r,10s,10t,10u,10v,10w,10x,10y,10z,110,0,0
111,0,112,113,114,115,116,117,118,119,11a,11b,11c,11d,11e,0
0,11f,11g,11h,11i,3s,i9,11j,3s,11k,11l,11m,11n,11o,0,0
NAME bathroomclose
PAL 0

ROOM 9
11p,x6,0,0,0,0,0,0,0,0,0,0,0,s,0,v1
11q,11r,11s,k0,0,0,0,0,0,0,0,0,s,xa,e3,xb
11t,11u,11v,11w,11x,11y,11z,120,121,122,123,xj,51,xk,xl,xm
124,125,126,127,128,129,0,0,0,0,0,12a,xr,0,xs,xt
12b,12c,12d,12e,12f,12g,12h,12i,12j,rn,12k,12l,bm,ix,y3,s
12m,12n,12o,12p,12q,12r,12s,12t,12u,12v,12w,12x,bz,yc,0,yd
12y,12z,130,131,132,0,0,0,0,0,0,133,ym,yn,yo,0
134,135,136,137,138,139,13a,12i,p7,p7,13b,13c,yy,yz,z0,z1
13d,13e,13f,13g,13h,13i,13j,13k,13l,13m,13n,13o,za,zb,zc,0
13p,13q,13r,13s,13t,13u,13v,13w,13x,13y,13z,140,67,0,zo,zp
141,142,143,0,zq,zr,zs,zt,zu,0,p7,ce,0,zv,zw,zx
os,zy,0,zz,100,101,102,103,104,105,106,3s,107,0,108,109
10a,10b,10c,10d,10e,10f,10g,10h,10i,10j,10k,10l,10m,10n,0,0
10o,10p,10q,0,10r,10s,10t,10u,10v,10w,10x,10y,10z,110,0,0
111,0,112,113,114,115,116,117,118,119,11a,11b,11c,11d,11e,0
0,11f,11g,11h,11i,3s,i9,11j,3s,11k,11l,11m,11n,11o,0,0
NAME bathroomopen
ITM 9 9,7
PAL 0

ROOM 10
0,0,0,144,13,0,0,0,6z,p7,p7,145,p7,p7,p7,146
0,0,6y,147,148,149,14a,14b,0,14c,14d,14e,14f,14g,14h,14i
0,0,0,14j,14k,14l,14m,14n,26,14o,14p,14q,14r,14s,14t,14u
0,0,0,14v,14w,14x,14y,14z,150,151,152,153,154,155,156,157
0,0,0,158,159,15a,15b,15c,15d,15e,15f,15g,15h,15i,15j,15k
15l,15m,15n,15o,15p,15q,0,wx,15r,15s,15t,15u,15v,15w,15x,15y
15z,0,160,161,162,163,164,0,0,165,166,167,168,169,16a,16b
0,16c,16d,6z,16e,13,16f,0,0,16g,16h,16i,16j,16k,16l,16m
16n,16o,6z,16p,16q,16r,16s,16t,16u,16v,16w,16x,16y,16z,170,171
172,ro,173,174,0,175,176,177,0,0,0,8f,178,ow,179,3s
17a,17b,17c,17d,17e,17f,17g,17h,0,17i,17j,17k,0,0,0,0
17l,17m,17n,17o,17p,17q,17r,17s,0,17t,17t,17u,17v,17w,17x,17y
17z,180,181,182,183,184,0,0,185,186,187,188,189,bm,18a,0
18b,18c,18d,18e,18f,18g,18h,0,0,18i,18j,18k,18l,18m,18n,0
18o,18p,18q,18r,18s,18t,18u,mv,18v,18w,18x,18y,0,0,0,0
26,18z,190,191,192,193,194,195,196,197,198,199,19a,19b,19c,0
NAME livingleft
ITM 8 5,2
ITM e 10,11
ITM f 1,12
PAL 0

ROOM 11
0,0,mv,19d,19e,19f,0,0,0,0,0,0,0,0,mv,9z
0,0,19g,19h,0,0,0,0,0,0,0,0,0,0,0,0
19i,19j,19k,19l,19m,0,19n,19o,19p,19q,13n,19r,0,19s,0,0
19t,iq,0,0,19u,19v,19w,19x,19y,19z,1a0,1a1,0,1a2,17s,0
0,1a3,1a4,1a5,1a6,1a7,1a8,1a9,7r,0,1aa,1ab,1ac,1ad,1ae,jj
0,0,0,sg,1af,13,1ag,1ah,1ai,1aj,1ak,1al,1am,1an,0,1ao
1ap,1aq,1ar,1as,1at,1au,rn,1av,1aw,1ax,1ay,1az,1b0,1b1,0,2q
1b2,1b3,0,1b4,1b5,1b6,7r,1b7,1b8,1b9,1ba,1bb,1bc,1bd,1be,1bf
0,0,0,kv,1bg,1bh,1bi,1bj,13n,1bk,1bl,1bm,1bn,1bo,1bp,1bq
0,0,0,6m,1br,1bs,0,0,0,1bt,1bu,0,0,0,1bv,1bw
1bx,0,0,0,kv,1by,1bz,1c0,1c1,1c2,1c3,0,1c4,1c5,1c6,0
1c7,1c8,1c9,1ca,1cb,1cc,1cd,1ce,1cf,1cg,1ch,1ci,1cj,1ck,1cl,1cm
1cn,1co,1cp,0,1cq,1cr,1cs,1ct,1cu,1cv,1cw,1cx,1cy,1cz,1d0,1d1
0,1d2,1d3,1d4,1d5,1d6,1d7,0,1d8,1d9,1da,17y,n,1db,cs,0
0,0,0,im,1dc,85,0,1dd,1de,1df,1dg,1dh,1di,0,0,0
0,0,0,0,0,0,0,0,2h,1dj,1dk,1dl,0,1dm,1dn,1do
NAME kitchen
ITM b 2,5
ITM d 10,2
PAL 0

ROOM 12
0,1dp,1dq,1dr,0,0,0,0,0,0,0,0,1ds,1dt,1du,1dv
1dw,1dx,1dy,1dz,1e0,1e1,13b,0,1e2,p7,p7,1e3,1e4,1e5,1e6,1e7
1e8,1e9,i,1ea,1eb,1ec,1ed,1ee,1ef,1eg,1eh,1ei,1ej,0,1ek,1el
0,0,1em,13,1en,1eo,1ep,1eq,oe,1er,1es,1et,1eu,0,1ev,1ew
0,0,1ex,ea,i,1ey,1ez,0,0,0,1f0,1f1,0,0,1f2,0
0,0,1f3,0,0,1ey,1f4,0,0,0,1f5,1f6,0,0,1f7,0
0,113,1f8,1f9,0,1fa,1fb,0,0,0,1fc,1fd,0,0,0,0
0,1fe,1ff,1fg,0,1fh,1fi,0,0,cw,1fj,1fk,67,0,0,1fl
0,1fm,1fn,0,0,1fo,eh,0,0,1fp,1fq,1fr,1fs,0,0,1ft
1fu,0,1fn,e3,1fv,1fw,1fx,0,0,0,52,1fy,1fz,0,1g0,1g1
1g2,s,1g3,1g4,1g5,1g6,si,0,0,0,1g7,1g8,1g9,1ga,1gb,1gc
1gd,1ge,0,1gf,1gg,1gh,1gi,1gj,1gk,1gl,1gm,1gn,1go,1gp,1gq,1gr
1gs,1gt,1gu,1gv,1gw,1gx,1gy,1gz,1h0,1h1,1h2,1h3,1h4,1h5,1h6,1h7
1h8,1h9,1ha,1hb,1hc,1hd,1he,1hf,1hg,1hh,1hi,1hj,1hk,1hl,1hm,1hn
1ho,1hp,1hq,1hr,1hs,1ht,1hu,1hv,1hw,1hx,1hy,1hz,1i0,1i1,1i2,1i3
1i4,1i5,1i6,1i7,1i8,0,1i9,1ia,1ib,1ic,bm,1id,1ie,1if,1ig,1ih
NAME doorway crowbar
PAL 0
TUNE 7

ROOM 13
0,1dp,1dq,1dr,0,0,0,0,0,0,0,0,1ds,1dt,1du,1dv
1dw,1dx,1dy,1dz,1e0,1e1,13b,0,1e2,p7,p7,1e3,1e4,1e5,1e6,1e7
1e8,1e9,i,1ea,1eb,1ec,1ed,1ee,1ef,1eg,1eh,1ei,1ej,0,1ek,1el
0,0,0,0,1en,1eo,1ep,1eq,oe,1er,1es,1et,1eu,0,1ev,1ew
0,0,0,0,i,1ey,1ez,0,0,0,1f0,1f1,0,0,1f2,0
0,0,0,0,0,1ey,1f4,0,0,0,1f5,1f6,0,0,1f7,0
0,113,1ii,1ij,0,1fa,1fb,0,0,0,1fc,1fd,0,0,0,0
0,1ik,1il,1im,0,1fh,1fi,0,0,cw,1fj,1fk,67,0,0,1fl
0,1in,0,0,0,1fo,eh,0,0,1fp,1fq,1fr,1fs,0,0,1ft
1fu,0,0,e3,1fv,1fw,1fx,0,0,0,52,1fy,1fz,0,1g0,1g1
1g2,s,0,1g4,1g5,1g6,si,0,0,0,1g7,1g8,1g9,1ga,1gb,1gc
1gd,1ge,0,1gf,1gg,1gh,1gi,1gj,1gk,1gl,1gm,1gn,1go,1gp,1gq,1gr
1gs,1gt,1gu,1gv,1gw,1gx,1gy,1gz,1h0,1h1,1h2,1h3,1h4,1h5,1h6,1h7
1h8,1h9,1ha,1hb,1hc,1hd,1he,1hf,1hg,1hh,1hi,1hj,1hk,1hl,1hm,1hn
1ho,1hp,1hq,1hr,1hs,1ht,1hu,1hv,1hw,1hx,1hy,1hz,1i0,1i1,1i2,1i3
1i4,1i5,1i6,1i7,1i8,0,1i9,1ia,1ib,1ic,bm,1id,1ie,1if,1ig,1ih
NAME doorway no
PAL 0
TUNE 8

ROOM 14
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
is,it,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,iu,0,0,0,iv,hp,0,0,0,0,0,0,0,0,0
0,iw,ix,iy,iz,j0,j1,j2,j3,0,0,0,0,0,0,0
0,j4,j5,j6,j7,j8,j9,ja,jb,0,0,0,0,0,0,0
hp,jc,jd,je,jf,jg,jh,ji,jj,cw,jk,jl,jm,0,0,0
jn,jo,jp,jq,jr,js,jt,ju,jv,jw,jx,jy,jz,k0,0,0
k1,k2,k3,k4,k5,k6,k7,k8,k9,0,0,ka,0,kb,kc,0
kd,ke,kf,kg,kh,0,ki,kj,kk,kl,6z,km,0,0,kn,0
0,ko,kp,kq,13,26,kr,ks,kt,ku,kv,kw,0,0,kx,0
ky,kz,l0,l1,l2,l3,l4,l5,l6,l7,l8,0,0,0,l9,0
0,la,lb,lc,ld,le,lf,lg,lh,li,lj,0,0,0,lk,0
0,s,ll,lm,ln,lo,lp,lq,lr,ls,lt,lu,13,0,lv,0
0,lw,lx,ly,co,lz,m0,m1,m2,m3,m4,m5,m6,m7,m8,m9
6s,ma,mb,mc,md,me,mf,mg,mh,mi,mj,mk,ml,mm,mn,mo
0,0,7r,0,0,0,0,0,0,0,mp,cs,mq,mr,ms,mt
NAME hallway copy
ITM g 6,7
PAL 0

ROOM 15
0,0,0,0,0,0,mu,bm,0,0,0,9z,0,0,0,0
0,0,0,0,mv,mw,mx,0,0,0,my,mz,0,0,0,0
n0,n1,n2,n3,n4,n5,n6,0,0,n7,n8,n9,na,0,nb,0
nc,nd,ne,7r,0,0,0,0,0,0,0,nf,6m,c5,ng,nh
ni,nj,nk,nl,nm,nn,no,np,nq,nr,ns,nt,nu,nv,nw,nx
ny,nz,0,0,o0,0,0,o1,0,0,0,o2,0,o3,o4,o5
o6,o7,o8,o9,oa,ob,oc,od,oe,of,og,oh,oi,oj,ok,ol
om,on,0,0,oo,0,op,oq,0,0,0,or,0,os,0,ot
ou,ov,ow,ox,oy,3s,3s,oz,3s,3s,p0,p1,3s,p2,p3,p4
p5,p6,p7,p7,p8,p9,0,pa,0,0,kv,pb,0,pc,pd,pe
pf,pg,ph,pi,pj,pk,pl,pm,pn,po,pp,pq,pr,ps,pt,pu
pv,pw,px,py,pz,q0,q1,q2,q3,q4,q5,q6,q7,q8,q9,qa
qb,qc,qd,qe,qf,qg,qh,qi,qj,qk,ql,qm,qn,qo,qp,qq
qr,qs,qt,qu,qv,qw,qx,qy,qz,r0,r1,r2,r3,r4,r5,r6
r7,r8,r9,ra,0,6m,rb,rc,rd,re,rf,rg,rh,ri,rj,0
29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME cage up copy 1
PAL 1

ROOM 17
1o2,1o3,cw,1o4,26,1o5,1o6,1o7,1o8,1o9,1oa,cw,1ob,1oc,1od,1oe
1of,0,1og,1oh,1oi,1oj,1ok,1ol,1om,1on,1oo,1op,1oq,1or,1os,1ot
1ou,1ov,1ow,1ox,1oy,1oz,1p0,1p1,1p2,1p3,1p4,1p5,1p6,1p7,1p8,1p9
1pa,1pb,1pc,1pd,1pe,1pf,1pg,1ph,1pi,1pj,1pk,1pl,1pm,1pn,1po,1pp
1pq,1pr,1ps,1pt,1pu,1pv,1pw,1px,1py,1pz,1q0,1q1,1q2,1q3,1q4,1q5
1q6,1q7,1q8,1q9,1qa,1qb,1qc,1qd,1qe,1qf,1qg,1qh,1qi,1qj,1qk,1ql
1qm,1qn,1qo,1qp,1qq,1qr,1qs,1qt,1qu,1qv,1qw,1qx,1qy,1qz,1r0,1r1
1r2,1r3,1r4,1r5,1r6,1r7,1r8,1r9,1ra,1rb,1rc,1rd,1re,1rf,1rg,1rh
1ri,1rj,1rk,1rl,1rm,1rn,1ro,1rp,1rq,1rr,1rs,1rt,1ru,1rv,1rw,1rx
1ry,1rz,1s0,1s1,1s2,1s3,1s4,1s5,1s6,1s7,1s8,1s9,1sa,b,1sb,1sc
1sd,1se,1sf,1sg,1sh,1si,1sj,1sk,1sl,1sm,1sn,1so,1sp,1sq,1sr,1ss
1st,1su,1sv,1sw,1sx,b,1sy,1sz,1t0,b,1t1,b,b,1t2,1t3,1t4
1t5,1t6,1t7,1t8,1t9,b,b,b,b,b,b,b,b,1ta,1tb,1tc
1td,1te,1tf,1tg,1th,b,b,b,b,b,b,b,b,1ti,1tj,1tk
b,b,b,1tl,1tm,b,b,b,b,b,b,b,b,1tn,1ng,1to
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
NAME end2
ITM h 5,7
PAL 1
TUNE 9

ROOM 18
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b
NAME dark
PAL 1

TIL 2
01110000
11110000
11100000
11000000
10000000
00000000
00000000
00000000
NAME bedroomdresser 2

TIL 3
00001100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 3

TIL 4
00011100
00011100
00111000
00110000
01100000
01100000
11100000
11000000
NAME bedroomdresser 4

TIL 5
00000001
00000011
00000111
00000111
00001111
00011111
00011110
00111100
NAME bedroomdresser 5

TIL 6
11000000
10000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 6

TIL 7
00000010
00000010
00000100
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 7

TIL 8
00000000
00000000
00000000
00000001
00000011
00000111
00001111
00000111
NAME bedroomdresser 8

TIL 9
01111100
11111000
11110000
11110000
11100000
11000000
10000000
00000000
NAME bedroomdresser 9

TIL 10
00000000
00000000
00000000
00000000
11000000
00111111
00000000
00000000
NAME bedroomdresser 31

TIL 11
00000000
00000000
00000000
00000000
00000000
11111111
00000000
00000000
NAME bedroomdresser 32

TIL 12
00000000
00000000
00000000
00000000
00000000
10000000
01111000
00000111
NAME bedroomdresser 33

TIL 13
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000
NAME bedroomdresser 34

TIL 14
00000000
00000000
00000000
00000000
00000000
00000000
00001000
01000000
NAME bedroomdresser 35

TIL 15
00100000
00100011
00100001
00101111
00101000
01001000
01001000
01011000
NAME bedroomdresser 36

TIL 16
00000001
11111111
11111101
00001111
00000000
00000000
00000000
00000000
NAME bedroomdresser 37

TIL 17
11111111
11111110
11111111
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 38

TIL 18
11100000
00011110
11111111
00000111
00000000
00000000
00000000
00000000
NAME bedroomdresser 39

TIL 19
00000000
00001111
11110000
11111111
00000110
00000001
00000000
00000000
NAME bedroomdresser 40

TIL 20
10000001
00100010
00000010
00000010
00000100
00000100
10000100
00000100
NAME bedroomdresser 67

TIL 21
00000111
00000111
00000111
00000111
00000111
00000111
00000111
00010111
NAME bedroomdresser 68

TIL 22
00010000
00010000
00010000
00010000
00010000
00100000
00100000
00100000
NAME bedroomdresser 69

TIL 23
00000000
00000100
10000000
00000000
10000000
00000000
00000000
00000000
NAME bedroomdresser 70

TIL 24
00100000
00000000
00001000
00000000
00000000
00000000
00000000
00000001
NAME bedroomdresser 71

TIL 25
00100000
01000000
10100000
00000000
00100000
01000000
00100000
01000000
NAME bedroomdresser 72

TIL 26
00000000
00000000
00000000
00000000
00000000
00000001
00000000
00000000
NAME bedroomdresser 73

TIL 27
00000000
00000000
00000010
00000101
00000000
00000100
10100000
00000000
NAME bedroomdresser 74

TIL 28
00000000
00000000
00000000
01000000
00000000
01000000
00100000
00000000
NAME bedroomdresser 75

TIL 29
00100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 76

TIL 30
00101010
01010000
10101000
01010000
10001010
00010101
10000010
11111111
NAME bedroomdresser 103

TIL 31
10001111
01010111
10001111
01010110
10101111
01000111
01111010
11111000
NAME bedroomdresser 104

TIL 32
00000000
00000000
00000000
00010000
00100000
01000000
00100000
01000000
NAME bedroomdresser 105

TIL 33
10100000
00000000
00100000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 106

TIL 34
00000000
00000000
00000000
00000000
00010000
00000001
00000100
00000001
NAME bedroomdresser 107

TIL 35
01101010
00000110
00100010
01000101
00100011
01001100
11001010
01111001
NAME bedroomdresser 108

TIL 36
00001000
01010100
00000000
01010100
00100010
01010101
10101010
01010101
NAME bedroomdresser 109

TIL 37
00000000
00000000
00000000
01000000
00000000
00000000
10100000
01000000
NAME bedroomdresser 110

TIL 38
00000000
00000000
00000000
00000000
00000000
00000000
00100000
00000000
NAME bedroomdresser 111

TIL 39
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001001
NAME bedroomdresser 112

TIL 40
10101110
11110101
00101001
01101011
10100100
10001010
00100000
00010110
NAME bedroomdresser 139

TIL 41
10000100
11111100
11100010
11100000
01100011
01100000
10100100
10110101
NAME bedroomdresser 140

TIL 42
00111011
10110101
00110000
01111000
00111000
00111000
11111000
10111000
NAME bedroomdresser 141

TIL 43
11111110
00000001
00000000
00000000
00000000
00000000
00000000
11111111
NAME bedroomdresser 142

TIL 44
00000000
11011111
00111111
00000000
00000000
00000000
00000000
11110000
NAME bedroomdresser 143

TIL 45
00000000
11111000
11111111
11111111
00000000
00000000
00000000
00000000
NAME bedroomdresser 144

TIL 46
00000000
00000000
11111111
11111100
00000000
00000000
00000000
00000000
NAME bedroomdresser 145

TIL 47
00000000
00011111
11111111
00000000
00000000
00000000
00000000
00011111
NAME bedroomdresser 146

TIL 48
00111111
11000000
11111000
00000000
00000000
00000000
00000000
11110000
NAME bedroomdresser 147

TIL 49
10101010
11110001
00101010
00111111
00001000
00000100
00000000
00000000
NAME bedroomdresser 148

TIL 50
00000000
00000000
00000000
00000000
00000000
11100000
00010000
00010000
NAME bedroomdresser 175

TIL 51
00010000
00010000
00010000
00010000
00010000
00010000
00010000
00010000
NAME bedroomdresser 176

TIL 52
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01000000
NAME bedroomdresser 177

TIL 53
00000000
00000000
00000000
00000000
00111100
01000011
10000000
10000000
NAME bedroomdresser 178

TIL 54
00000000
00000000
00000000
00000000
00000000
11000000
00100000
00100000
NAME bedroomdresser 179

TIL 55
00011100
00001001
00001000
00001101
00001100
00001101
00001100
00001101
NAME bedroomdresser 180

TIL 56
10111000
11001111
11101111
11000101
10101100
01110100
10101101
11111101
NAME bedroomdresser 181

TIL 57
10011101
01101111
10000001
00111101
01110111
01101111
11011100
11011101
NAME bedroomdresser 182

TIL 58
01001110
01011111
00001011
10111100
01011011
11101011
11000111
00110100
NAME bedroomdresser 183

TIL 59
11001110
11111011
11110110
01110111
01101101
11101110
11101011
11101110
NAME bedroomdresser 184

TIL 60
00111111
11111000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 211

TIL 61
11111111
00000000
00000000
00000000
00000000
00000001
00000110
00000000
NAME bedroomdresser 212

TIL 62
11111111
00001111
00000001
00000011
01111111
11000111
00001110
00000000
NAME bedroomdresser 213

TIL 63
10011010
11010111
10011111
11111110
11001101
10111111
00011111
00000001
NAME bedroomdresser 214

TIL 64
00011111
11111111
11111111
11111111
11111111
11111111
11111111
01111111
NAME bedroomdresser 215

TIL 65
00100110
01011101
00010110
00001000
00010111
00010000
00001111
00001111
NAME bedroomdresser 216

TIL 66
10001110
11111100
11110000
01000000
10000000
00000000
11111111
11111111
NAME bedroomdresser 217

TIL 67
00000000
00000000
00000000
00000000
00000000
00000000
10000000
00000000
NAME bedroomdresser 218

TIL 68
00001111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 219

TIL 69
11110000
00001111
00011111
11111111
00000011
00000100
00001000
00000111
NAME bedroomdresser 220

TIL 70
00011100
00011100
00111000
00110000
01110000
01100000
11100000
11000000
NAME bedroom 4

TIL 71
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000010
NAME bedroom 5

TIL 72
00000010
00000110
00000110
00000000
00000000
00000000
00000000
00000000
NAME bedroom 6

TIL 73
01111100
11111000
11110000
11110000
11100000
11000000
10000000
10000000
NAME bedroom 7

TIL 74
00100111
00000110
01111100
11111100
11110000
11100000
10000000
00000000
NAME bedroom 8

TIL 75
00111100
01111000
00001110
00000000
00000000
00000000
00000000
00000000
NAME bedroom 9

TIL 76
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001110
NAME bedroom 10

TIL 77
00000000
00000000
00000000
10000000
11000000
11100000
11100000
11100000
NAME bedroom 11

TIL 78
00000000
00000000
00000000
00000000
00000000
00000000
01000100
00000111
NAME bedroom 12

TIL 79
00011111
00011111
00000111
00000000
00000000
00000000
00000000
00000000
NAME bedroom 13

TIL 80
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00000001
NAME bedroom 40

TIL 81
11110000
01111000
01111100
00111100
00011100
00011100
00001110
00001110
NAME bedroom 41

TIL 82
00001110
00000100
00000100
00000000
00000000
00000100
00000100
00001000
NAME bedroom 42

TIL 83
00111100
00110000
00110000
00000001
00000011
00000111
00001110
00001110
NAME bedroom 43

TIL 84
01111000
01110000
11100000
11000000
10000000
00000000
00000000
00000000
NAME bedroom 44

TIL 85
11100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 45

TIL 86
00000001
00000011
00000111
00000111
00001111
00001110
00011110
00111100
NAME bedroom 46

TIL 87
00000000
00000100
00000100
00001000
00000000
00000000
00000000
00000000
NAME bedroom 47

TIL 88
00000000
00000000
00000000
00000001
00000011
00000111
00001111
00001111
NAME bedroom 48

TIL 89
01111100
11111000
11110000
11110000
11100000
11000000
11000000
10000000
NAME bedroom 49

TIL 90
00000000
00000000
00000110
00000000
00000000
00000000
00000000
00000000
NAME bedroom 76

TIL 91
00001111
00011110
00111100
11111000
00011100
00000000
00000000
00000000
NAME bedroom 77

TIL 92
00000000
00000000
00000000
00110000
11111100
11111110
00111111
00111111
NAME bedroom 78

TIL 93
11000000
00100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 79

TIL 94
00000000
00000000
00000000
00000000
00000000
00000000
00010000
00000001
NAME bedroom 80

TIL 95
11111110
01111110
00111100
00000000
00000000
00000000
00000000
00000000
NAME bedroom 81

TIL 96
00000000
00000000
00001001
00001000
00011100
00000000
00000000
00000000
NAME bedroom 82

TIL 97
11100000
10000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 83

TIL 98
11110000
11111000
01111000
00111000
00111100
00011100
00001100
00001110
NAME bedroom 84

TIL 99
00001100
00000000
00000000
00000000
00000000
00001100
00001000
00000000
NAME bedroom 85

TIL 100
00001000
01101000
11001000
11011000
00011000
00011000
00011000
00011000
NAME bathroomclose 104

TIL 101
11111000
00000000
00000000
00000001
00000010
00000101
00101010
01010101
NAME bathroomclose 105

TIL 102
00100000
10111111
11111000
11100000
10100000
11100000
11100000
11100000
NAME bathroomclose 106

TIL 103
01100000
11000000
01000000
11000100
11000000
11000100
10001000
10000100
NAME bathroomclose 107

TIL 104
00001111
00000011
00000001
00000000
00000000
00000000
00000000
00000000
NAME bathroomclose 108

TIL 105
01111111
00000000
10000000
10000000
10000000
10000000
10000000
11111110
NAME bathroomclose 109

TIL 106
11111111
11111100
00000000
00000000
00000000
00000000
00000000
00000000
NAME bathroomclose 110

TIL 107
11000000
11111110
00000110
00000100
00000110
00000110
00000111
00000011
NAME bathroomclose 111

TIL 108
10100010
00000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME bathroomclose 112

TIL 109
00100000
01000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bathroomclose 113

TIL 110
11110000
01110000
01111000
00111000
00111000
00111000
00011000
00001100
NAME bathroomclose 140

TIL 111
10100000
00000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME bathroomclose 141

TIL 112
00111100
00111000
00110000
01110000
01110000
01100000
11100000
11000000
NAME bathroomclose 142

TIL 113
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00111111
NAME bathroomclose 143

TIL 114
00110000
00000000
00000000
00000000
00000000
00000000
00000000
11111111
NAME bathroomclose 144

TIL 115
11111000
11111000
11001111
00000000
00000000
00000000
00000010
11111111
NAME bathroomclose 145

TIL 116
00000000
00000000
11000000
00111111
00000000
00000000
00000000
11111111
NAME bathroomclose 146

TIL 117
00000000
00000000
00000000
11111110
00000001
00000000
01111111
11110000
NAME bathroomclose 147

TIL 118
00000000
00000000
00000000
01111111
10000000
00000000
11111111
00000001
NAME bathroomclose 148

TIL 119
00000000
00000000
00000000
11111111
00000000
01111111
11111000
11111111
NAME bathroomclose 149

TIL 120
10101001
11111110
11111111
01010101
10101010
01000000
00000000
00000000
NAME bathroomopen 12

TIL 121
11111111
00111111
11111111
01010101
10101010
00000000
00000000
00000000
NAME bathroomopen 13

TIL 122
11110000
11111111
11111111
00000001
10101010
00000000
00000000
00000000
NAME bathroomopen 14

TIL 123
00000000
00000000
11111111
11111000
00000000
00000000
00000000
00000000
NAME bathroomopen 15

TIL 124
00001111
00001111
00001111
00001111
00001110
00001110
00011111
00011110
NAME bathroomopen 16

TIL 125
11111111
00000000
00111111
00000000
00000000
00000111
11111100
00000000
NAME bathroomopen 17

TIL 126
11111111
00000000
11111111
00000000
00011111
11111111
00000001
00011110
NAME bathroomopen 18

TIL 127
11111111
00001111
11110001
11111111
11110001
11110001
11110000
00000010
NAME bathroomopen 19

TIL 128
11111100
11111100
11111110
11111101
11111110
01111100
01111110
01111101
NAME bathroomopen 20

TIL 129
00100000
01000000
10000000
00000000
00100000
01010000
10100000
01000000
NAME bathroomopen 21

TIL 130
10101111
01111100
11110011
11111101
10001110
01110000
10111111
11011000
NAME bathroomopen 48

TIL 131
11101110
01101111
11111110
11011111
01011110
11111111
00011110
00011111
NAME bathroomopen 49

TIL 132
11010000
01100000
11100000
01100000
11100000
11100000
11100000
11100101
NAME bathroomopen 50

TIL 133
00011000
00011000
00011000
00011000
00011000
00011000
00011000
00010000
NAME bathroomopen 51

TIL 134
00011010
00011010
00011010
00011010
00011010
00011010
00011010
00011110
NAME bathroomopen 52

TIL 135
10000000
00000000
00000010
00000001
00000000
00000100
00000000
00000000
NAME bathroomopen 53

TIL 136
01101000
01010000
10100010
00000101
00000000
01000101
10111011
01001101
NAME bathroomopen 54

TIL 137
00101110
00011111
00001111
01011111
10001111
00011111
00101111
10010111
NAME bathroomopen 55

TIL 138
11101010
11110001
11101010
11110101
11100010
11100100
11101010
11111111
NAME bathroomopen 56

TIL 139
10100000
01000000
10101010
00010100
10101010
00010101
11111111
11111111
NAME bathroomopen 57

TIL 140
00100000
00010000
00110000
00010000
10000000
11110100
10101010
00000000
NAME bathroomopen 84

TIL 141
00001100
00001100
00001001
00000000
00000000
00000000
00000000
00000100
NAME bathroomopen 85

TIL 142
00011111
11101000
10000000
00000000
00000000
00000000
00000000
00000000
NAME bathroomopen 86

TIL 143
11111100
01100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bathroomopen 87

TIL 144
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001111
NAME livingleft 1

TIL 145
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11010000
NAME livingleft 2

TIL 146
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11110000
NAME livingleft 3

TIL 147
00001000
00010000
00100000
01000000
01000000
10000000
10000000
01000000
NAME livingleft 4

TIL 148
10000000
01111110
00011111
00011110
11110000
00101111
01100000
01000000
NAME livingleft 5

TIL 149
00000000
00000000
11111111
00000000
00000000
10000000
01111100
00000011
NAME livingleft 6

TIL 150
00000000
00000000
00000000
10000001
01000001
01100001
01000001
10000001
NAME livingleft 33

TIL 151
11000000
11000000
11000000
11000101
11001000
11000000
11000010
11000100
NAME livingleft 34

TIL 152
10100000
01000001
10000010
00000100
00001000
00000000
00000000
00000000
NAME livingleft 35

TIL 153
10001000
00010000
00100000
01000101
10001010
00010001
00100010
01010101
NAME livingleft 36

TIL 154
00100000
01000000
10000000
01000000
10100000
01000000
10000000
00000100
NAME livingleft 37

TIL 155
00100000
01000000
10000000
00000000
00000000
00000001
00000010
00000100
NAME livingleft 38

TIL 156
00101000
00010000
00100000
01000000
10000000
00000001
00000000
00000000
NAME livingleft 39

TIL 157
00100000
00000000
00000010
00000100
10000000
00000001
00000010
00000000
NAME livingleft 40

TIL 158
00000100
00000001
00000001
00000000
00000000
00000000
00000000
00110000
NAME livingleft 41

TIL 159
00000011
00000000
11111111
00000000
00000000
00000000
00000000
00000000
NAME livingleft 42

TIL 160
00000000
00000000
00000000
00000000
00000000
00000000
00001110
00000011
NAME livingleft 69

TIL 161
00001000
00011000
00110000
00100000
00100000
01000000
10000000
11100000
NAME livingleft 70

TIL 162
01110011
01111101
00111111
00111110
00000010
00000011
00001111
00000010
NAME livingleft 71

TIL 163
11111000
11111110
01000001
00000000
00111111
11111111
11110000
00000000
NAME livingleft 72

TIL 164
11000000
01000000
10100000
01110000
11111000
11111100
00001100
00001100
NAME livingleft 73

TIL 165
11100010
11100100
11100010
11100111
11111000
11100001
11101010
11110101
NAME livingleft 74

TIL 166
00101010
01010101
10101110
11111111
10101111
01010101
10100010
01000100
NAME livingleft 75

TIL 167
10101010
01010101
10101010
11110101
11001111
00010001
00100010
01000101
NAME livingleft 76

TIL 168
10000010
00000100
00011111
01010111
10100010
01000100
10001000
00010001
NAME livingleft 77

TIL 169
00100000
00000001
11111111
11111111
00001111
00010100
00101000
01010000
NAME livingleft 78

TIL 170
00101010
00010101
00101000
01010001
10000010
11110000
00111111
11111011
NAME livingleft 105

TIL 171
10000000
01000000
10000000
00000000
00000000
00000000
00000000
11111111
NAME livingleft 106

TIL 172
10000000
10000000
00000000
00000000
00000000
00000000
00000001
00000011
NAME livingleft 107

TIL 173
00000011
00000111
00001110
00011100
00011100
00011000
00110000
11100001
NAME livingleft 108

TIL 174
10000000
00000000
00000000
00000000
00000000
00000000
00000000
11111000
NAME livingleft 109

TIL 175
00000110
00000100
00001100
00001000
00011000
00110000
01100000
01100000
NAME livingleft 110

TIL 176
00000010
00000110
00000100
00001100
00001100
00011001
00010000
00110001
NAME livingleft 111

TIL 177
00000000
00000000
00000000
01000000
10001000
00010101
00101010
01000100
NAME livingleft 112

TIL 178
11111110
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME livingleft 113

TIL 179
00011111
11100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME livingleft 114

TIL 180
11110111
11111111
11111111
10000000
00000000
00000000
00000000
10000000
NAME livingleft 141

TIL 181
00000011
10111101
11111111
00000000
00000000
00000000
00000000
00000000
NAME livingleft 142

TIL 182
11101000
11001000
10000000
00000000
00000000
00000000
00000000
00000000
NAME livingleft 143

TIL 183
10000011
10000011
01000111
01001011
01001110
01011111
01011011
01111011
NAME livingleft 144

TIL 184
11101010
11010100
10100010
01100100
11001000
10010000
00001000
00000000
NAME livingleft 145

TIL 185
00000000
00010101
00000000
00000000
00000000
00000001
00000000
00000001
NAME livingleft 146

TIL 186
00101000
00000000
00000000
00000000
00001010
01000000
10000000
00000000
NAME livingleft 147

TIL 187
00000000
00000000
00000000
00000101
10101000
00000000
00000000
00000000
NAME livingleft 148

TIL 188
00000000
00000000
00000010
01010000
00000000
00000000
00000000
00000001
NAME livingleft 149

TIL 189
00000000
00000000
10101010
00000000
00000000
00000000
00000000
01010100
NAME livingleft 150

TIL 190
10100010
00010101
10000010
00000001
10101010
00010100
00001010
00000000
NAME livingleft 177

TIL 191
10001010
01000000
10101010
01010101
10101010
01010101
00000000
00000000
NAME livingleft 178

TIL 192
10101010
01010101
10101010
01000000
10101010
01010101
00000000
00000000
NAME livingleft 179

TIL 193
10101010
01010101
10101010
00000101
10101010
01010000
10101010
00000001
NAME livingleft 180

TIL 194
10101010
00010101
10101010
01010100
10101010
00000000
10100010
01010101
NAME livingleft 181

TIL 195
10101010
01000101
10101010
00010101
10000000
00000001
10101010
01000000
NAME livingleft 182

TIL 196
10100000
01010101
10101010
01010101
00000000
01010101
00000000
00000000
NAME livingleft 183

TIL 197
00000000
01010101
10101010
01000000
10101010
00000000
00000000
00000000
NAME livingleft 184

TIL 198
00000000
01010101
10101010
01010101
00000000
00000000
00000000
00000000
NAME livingleft 185

TIL 199
00000000
01010101
10101010
01000000
00101010
00000000
00000000
00000000
NAME livingleft 186

TIL b
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME fulldark
WAL false

TIL c
10111101
00101111
11110011
10011111
10110110
11101101
11010101
11111111
NAME halfdark
WAL false

TIL d
00111001
00000101
01010010
00011000
00110010
01001001
11010000
00011101
NAME quarterdark
WAL false

TIL e
00100001
00000000
01010010
00000000
10010010
01001000
00010000
00001001
NAME eigthdark
WAL false

TIL f
01111101
11111111
10101101
01110111
11111111
11111110
10111011
11110111
NAME mostdark
WAL false

TIL a
00000000
00000000
00000000
00000000
00000000
00000000
00000010
00000000
NAME bedroomdresser 10

TIL g
00000000
00000000
00000000
00000001
00000011
00001111
00001111
00011110
NAME bedroomdresser 11

TIL h
00100011
00000110
01111100
11111100
11100000
11000000
00000000
00000000
NAME bedroomdresser 12

TIL i
00000010
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 13

TIL j
00111100
01111000
00001100
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 14

TIL k
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000110
NAME bedroomdresser 15

TIL l
00000000
00000000
00000000
00011111
00011111
00011111
00000111
00000111
NAME bedroomdresser 16

TIL m
00000000
00000000
00000000
00000000
11000000
11100000
11100000
11100000
NAME bedroomdresser 17

TIL n
00000011
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 18

TIL o
00000000
00000000
00000000
00000000
00000000
00000000
01000100
00000011
NAME bedroomdresser 19

TIL p
00011111
00001111
00000111
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 20

TIL q
11100000
11100000
11000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 21

TIL r
00000011
00000011
00100011
00100001
01110000
00110000
00000000
00000000
NAME bedroomdresser 22

TIL s
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00010000
NAME bedroomdresser 23

TIL t
00001100
00001110
00000111
00000011
00000011
00000001
00000000
00000000
NAME bedroomdresser 24

TIL u
00000000
00000000
11000000
11000000
11100000
11100000
11110000
01110000
NAME bedroomdresser 25

TIL v
00110000
00111000
00111000
00110000
00010000
00000000
00000000
00000000
NAME bedroomdresser 26

TIL w
00110000
00010000
00100000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 27

TIL x
00000000
00000000
00000000
00000000
00000000
00000001
00001110
00010000
NAME bedroomdresser 28

TIL y
00000000
00000000
00000000
00000000
00001111
11110000
00000000
00000000
NAME bedroomdresser 29

TIL z
00000000
00000000
00000000
00000000
11111111
00000000
00000000
00000000
NAME bedroomdresser 30

TIL 1a
00000000
11110000
11001100
11111100
11111100
11010100
00100100
00000100
NAME bedroomdresser 41

TIL 1b
10000000
10000000
10000000
10000000
10000000
10000000
01000000
01000000
NAME bedroomdresser 42

TIL 1c
00000000
00000101
00000010
00000100
00001010
00000101
00001000
00000100
NAME bedroomdresser 43

TIL 1d
10001000
00010100
00000010
00010001
00000010
00000000
10100000
00000000
NAME bedroomdresser 44

TIL 1e
00000000
00000000
00000000
00000000
10100000
00000000
00000000
01010000
NAME bedroomdresser 45

TIL 1f
00000010
00000001
00000000
00000001
00000000
00000001
00000000
00000001
NAME bedroomdresser 46

TIL 1g
00000000
00000000
00000000
00000000
10000000
00000000
10000000
00000000
NAME bedroomdresser 47

TIL 1h
00000000
00000100
00000000
00000000
00000000
00000001
00000000
00000001
NAME bedroomdresser 48

TIL 1i
10000000
00000000
00001000
00010000
10000000
00010000
00001000
00000000
NAME bedroomdresser 49

TIL 1j
01011000
00101000
00101000
00101000
00101000
00101000
00101000
00101000
NAME bedroomdresser 50

TIL 1k
00000000
00000000
00000000
00000000
00000000
00000001
00000001
00000010
NAME bedroomdresser 51

TIL 1l
00000000
00011100
00111111
01110011
11000110
10000000
10000100
10000000
NAME bedroomdresser 52

TIL 1m
00000000
11111000
11101100
10010000
01100000
01000000
10000000
10000000
NAME bedroomdresser 53

TIL 1n
00000100
00000100
00000100
00000100
00000100
00000100
00000110
00000111
NAME bedroomdresser 54

TIL 1o
01000000
01000000
01000000
01000000
00100000
00100000
00100000
00100000
NAME bedroomdresser 55

TIL 1p
00001000
00000100
00000010
00000101
00000010
00000100
00000000
00000000
NAME bedroomdresser 56

TIL 1q
00000000
01010000
00000000
01010001
00100000
01000000
00000000
01000000
NAME bedroomdresser 57

TIL 1r
00100000
00000000
00100000
00000000
00101000
00000000
00000010
00000000
NAME bedroomdresser 58

TIL 1s
00000000
00010000
10000000
00010000
00000000
00010000
00000000
00000000
NAME bedroomdresser 59

TIL 1t
00000000
00000001
00000000
00000001
00000000
00000001
00000000
00000001
NAME bedroomdresser 60

TIL 1u
10000000
00000000
00000000
00000000
00000000
00000100
00000000
00000100
NAME bedroomdresser 61

TIL 1v
00000000
00000000
00001000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 62

TIL 1w
00000000
00010000
10000010
00010000
10000000
00010001
00000000
01010000
NAME bedroomdresser 63

TIL 1x
00100000
00000000
00100000
00000000
00100000
00000000
00100000
00000000
NAME bedroomdresser 64

TIL 1y
00101000
00101000
00101100
00101100
00101100
00101100
00111100
00111100
NAME bedroomdresser 65

TIL 1z
00000111
00000110
00000110
00000100
10000100
01001000
10101000
00001000
NAME bedroomdresser 66

TIL 2a
00101100
00101100
00101100
00101101
00101110
00101100
00101110
00101100
NAME bedroomdresser 77

TIL 2b
10001011
00001000
10101000
00011100
10101010
01010100
10100110
01010111
NAME bedroomdresser 78

TIL 2c
00000100
00000100
00100010
00000010
00000001
00000000
00000000
00010000
NAME bedroomdresser 79

TIL 2d
00000000
00000000
00000000
00000000
01000000
10000111
01111111
00000000
NAME bedroomdresser 80

TIL 2e
00000001
00000011
00000110
00111110
11110110
11001100
00001100
00001000
NAME bedroomdresser 81

TIL 2f
00001111
00010111
00101111
00010111
00101011
01010111
00101011
01010111
NAME bedroomdresser 82

TIL 2g
00100000
00010000
00010000
00010000
00010000
00010000
00010000
00100000
NAME bedroomdresser 83

TIL 2h
00000000
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 84

TIL 2i
10000000
01000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 85

TIL 2j
00000000
00000000
10001000
00010000
00000010
00010000
10000000
00010000
NAME bedroomdresser 86

TIL 2k
00101110
00101101
00101110
00101101
00101110
00101101
00101110
00101101
NAME bedroomdresser 87

TIL 2l
10101001
00010100
10101010
00000100
10000010
01010101
10001010
01010001
NAME bedroomdresser 88

TIL 2m
10000000
11000010
10100000
01010000
10110000
01001100
10100011
00000001
NAME bedroomdresser 89

TIL 2n
00000000
01000000
00000010
00000100
00000001
00100010
11111100
00000000
NAME bedroomdresser 90

TIL 2o
01010010
00010100
00100000
01000100
10000000
01000101
10001010
01000101
NAME bedroomdresser 91

TIL 2p
10101011
00010011
10101010
00010010
10101010
01010010
10001010
01010110
NAME bedroomdresser 92

TIL 2q
00100000
00100000
00100000
00100000
00100000
00100000
00100000
00100000
NAME bedroomdresser 93

TIL 2r
00000000
00000000
00000000
00000000
00100000
00000101
00000010
01010000
NAME bedroomdresser 94

TIL 2s
00100000
00000000
10000000
00000000
00100000
01010000
00000000
00000000
NAME bedroomdresser 95

TIL 2t
00000000
00000000
00000000
00000000
00000000
00010101
00000010
00010001
NAME bedroomdresser 96

TIL 2u
00000000
00000000
00000000
00000000
00000000
01000000
00000000
01010000
NAME bedroomdresser 97

TIL 2v
00000000
01010001
00000010
01000001
00000010
00000000
00000000
00000000
NAME bedroomdresser 98

TIL 2w
00101110
00101101
00101110
00101111
00101011
00100000
00100111
00010000
NAME bedroomdresser 99

TIL 2x
10101000
01010100
10101010
01010101
10101000
01110101
11111111
00000111
NAME bedroomdresser 100

TIL 2y
10000010
01010101
10001010
01010101
00101010
01111111
11111100
11111111
NAME bedroomdresser 101

TIL 2z
10001000
01010001
10101010
01000101
10100010
11111111
00100001
11111111
NAME bedroomdresser 102

TIL 3a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01111111
NAME bedroomdresser 113

TIL 3b
00001111
00000000
00000000
00000000
00000000
00000000
00000000
11111111
NAME bedroomdresser 114

TIL 3c
00000000
11111010
00000101
00000000
00000000
00000000
00000000
11111111
NAME bedroomdresser 115

TIL 3d
00000001
00000000
11111110
00000001
00000000
00000000
00011111
11111110
NAME bedroomdresser 116

TIL 3e
11111111
00000000
00001111
11110000
00000000
00000000
10000000
00000000
NAME bedroomdresser 117

TIL 3f
11111000
00000000
11111111
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 118

TIL 3g
00000100
00000001
11111110
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 119

TIL 3h
00100000
11000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 120

TIL 3i
00100000
00010000
00100000
00010000
00000000
00010000
00000000
00000000
NAME bedroomdresser 121

TIL 3j
00000000
00000000
00000000
00000000
00000001
00000000
00000000
00000000
NAME bedroomdresser 122

TIL 3k
00100101
00110001
00101000
01100101
10101010
00000111
11110010
01111111
NAME bedroomdresser 123

TIL 3l
11111111
01101111
00101011
01000101
10111010
11010101
00101110
11000110
NAME bedroomdresser 124

TIL 3m
10100000
01010011
11000100
01111100
10110010
11010000
00100010
00001000
NAME bedroomdresser 125

TIL 3n
10100010
00010001
10101000
01110001
11111000
11110101
11101000
01011011
NAME bedroomdresser 126

TIL 3o
00100000
01010000
00100000
01010000
00100000
01010000
10101010
11100000
NAME bedroomdresser 127

TIL 3p
00001111
00001001
00001010
00011101
00011010
00010101
00011010
00010101
NAME bedroomdresser 128

TIL 3q
11111111
00000000
10100000
01010100
10101010
01010100
00100010
01111111
NAME bedroomdresser 129

TIL 3r
10000001
00000000
00000000
00000000
00000000
00000000
00000000
11000000
NAME bedroomdresser 130

TIL 3s
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 131

TIL 3t
11111110
00000001
00000000
00000001
00000010
01000101
00100010
00000101
NAME bedroomdresser 132

TIL 3u
00000000
11111111
00000000
01010001
10101010
01010101
10101010
01000101
NAME bedroomdresser 133

TIL 3v
00000000
11000000
11000000
11000001
11000000
01000000
11100010
01101101
NAME bedroomdresser 134

TIL 3w
00000010
00000100
10001000
01010001
10101000
01011011
11111011
10000100
NAME bedroomdresser 135

TIL 3x
10000100
01001101
11000100
10011010
10010000
00010001
01001000
01001111
NAME bedroomdresser 136

TIL 3y
10011010
10110111
01011000
00010101
11110101
01010000
01111110
00010000
NAME bedroomdresser 137

TIL 3z
10001101
00011110
01110010
01110100
01011001
11011000
10001100
01000100
NAME bedroomdresser 138

TIL 4a
11101010
01100101
10101010
11111111
00111111
00011001
00011000
00010000
NAME bedroomdresser 149

TIL 4b
10000011
01110100
11101100
00100111
00011100
10110000
01111101
01011100
NAME bedroomdresser 150

TIL 4c
10001010
00110101
11011010
00010011
01010001
00000010
00111010
11011010
NAME bedroomdresser 151

TIL 4d
01100010
01001100
10100010
01110100
00001010
01011100
10001010
11110101
NAME bedroomdresser 152

TIL 4e
10010000
10001011
11000100
00110001
11000110
10000000
10000000
01010001
NAME bedroomdresser 153

TIL 4f
00100100
00110101
00001010
00010101
00011100
00000100
00101010
00011001
NAME bedroomdresser 154

TIL 4g
00000101
01110100
10101010
00011001
11011101
01111111
10101010
00010100
NAME bedroomdresser 155

TIL 4h
00111000
01011000
00011000
01011000
00011000
10011000
00011000
00011000
NAME bedroomdresser 156

TIL 4i
11111111
10000000
10100000
11000000
10101000
11010000
10100010
11010101
NAME bedroomdresser 157

TIL 4j
00000000
00000000
00000000
00000000
00000000
01010100
10101010
11111111
NAME bedroomdresser 158

TIL 4k
00001100
00000010
00000010
00000010
00000010
00000010
11111100
00000000
NAME bedroomdresser 159

TIL 4l
00000010
00000101
00001000
00010000
00010000
00010000
00010000
00010000
NAME bedroomdresser 160

TIL 4m
00000000
00000000
10000000
01000000
01000001
01000001
01000000
01000000
NAME bedroomdresser 161

TIL 4n
00100000
01000000
10000000
10000000
00000000
00010101
00100000
00011111
NAME bedroomdresser 162

TIL 4o
00001111
00000000
00000000
00000000
00000010
01010000
10111010
11000111
NAME bedroomdresser 163

TIL 4p
11110000
01001000
10001000
01011100
10101000
00001000
10101000
11110000
NAME bedroomdresser 164

TIL 4q
00011010
00011001
00010101
00011100
00011100
00011100
00011101
00010000
NAME bedroomdresser 165

TIL 4r
10110000
00001110
01110000
11011000
11111101
00101011
10111101
01011011
NAME bedroomdresser 166

TIL 4s
10010111
00001010
00111111
00110111
11110110
10101101
00011011
11101101
NAME bedroomdresser 167

TIL 4t
10101010
11010100
11000110
00111000
01101010
10000110
10111111
01001110
NAME bedroomdresser 168

TIL 4u
11100000
01000010
10010001
11011010
00000010
11111100
00111100
01100011
NAME bedroomdresser 169

TIL 4v
00000010
00000000
00000010
01000000
11101110
01000010
11100000
11011110
NAME bedroomdresser 170

TIL 4w
10100010
01010100
00111010
01010101
10101010
00010101
11100110
01010110
NAME bedroomdresser 171

TIL 4x
11011000
00011000
10011000
00011000
10011000
11011000
10011000
11011000
NAME bedroomdresser 172

TIL 4y
10111111
00000000
00100000
00000000
00000000
00000000
00001111
00000110
NAME bedroomdresser 173

TIL 4z
10000000
00000000
00000000
00000000
00000000
00000000
00111111
11000000
NAME bedroomdresser 174

TIL 5a
11001000
01010000
00011111
10101100
11100110
10010111
11111001
10101101
NAME bedroomdresser 185

TIL 5b
10111010
01110110
11010011
10001100
11011111
00101110
10001111
11100101
NAME bedroomdresser 186

TIL 5c
00011000
11011000
10111000
01011000
10111000
11001000
00101000
11111000
NAME bedroomdresser 187

TIL 5d
00000100
00000101
00001010
00001001
00011111
00000100
00000010
01111111
NAME bedroomdresser 188

TIL 5e
00000000
00000000
00000000
00011111
11101010
00000000
00000000
11111110
NAME bedroomdresser 189

TIL 5f
00001000
00001100
11111100
00000000
00000000
00000000
00000000
00000111
NAME bedroomdresser 190

TIL 5g
00110000
00010000
00010000
00001000
00000101
00000010
00000000
10000000
NAME bedroomdresser 191

TIL 5h
01000001
01000001
10000000
10000000
00000001
00000000
00000101
00001111
NAME bedroomdresser 192

TIL 5i
00000000
01010101
10001010
11111111
10100000
00000100
11111110
11111111
NAME bedroomdresser 193

TIL 5j
00000000
01010101
10101010
11111111
00000000
00000000
00000000
11111111
NAME bedroomdresser 194

TIL 5k
00100000
01100000
00100000
11000000
00000000
00000000
00110001
11111111
NAME bedroomdresser 195

TIL 5l
00001100
00001101
00011000
00011001
00011000
10111000
11101000
11111111
NAME bedroomdresser 196

TIL 5m
10100100
01111011
11010010
01111111
11110100
10111001
11111111
11111111
NAME bedroomdresser 197

TIL 5n
10110111
11100111
01111110
11111100
01101101
11001101
10001101
11111111
NAME bedroomdresser 198

TIL 5o
10100111
01111000
01010110
11011001
10011011
00111010
00010100
11110111
NAME bedroomdresser 199

TIL 5p
11111111
11011100
11101111
10111111
11111111
01111111
11011001
00011011
NAME bedroomdresser 200

TIL 5q
11110111
01101111
11001111
11111111
11111111
11101111
11111111
01111011
NAME bedroomdresser 201

TIL 5r
11011111
11110101
10111001
11111010
11101000
10000000
10100000
00000000
NAME bedroomdresser 202

TIL 5s
01111111
11111110
10000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 203

TIL 5t
11111111
00111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 204

TIL 5u
00111111
11111110
00000001
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 205

TIL 5v
11111111
00001111
11110000
00000000
00000000
00000000
00000000
01000000
NAME bedroomdresser 206

TIL 5w
11111111
11111111
00000000
00000000
00000000
00000000
00000000
00000111
NAME bedroomdresser 207

TIL 5x
11110001
11111111
00000000
00000000
00000000
00000000
01111000
10011111
NAME bedroomdresser 208

TIL 5y
11111111
10000111
01111000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 209

TIL 5z
11111111
11000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 210

TIL 6a
00000000
11111111
10001111
11111110
11110011
00000010
00111100
11111001
NAME bedroomdresser 221

TIL 6b
00000000
10000000
10010111
00000000
10000000
00000000
00100001
00000000
NAME bedroomdresser 222

TIL 6c
10000010
00000010
10101000
11110000
00010100
10011111
00110101
00010000
NAME bedroomdresser 223

TIL 6d
00000000
11000000
00000111
00000001
00000000
11111111
01000010
11000011
NAME bedroomdresser 224

TIL 6e
11110000
10001000
00000100
00000000
00000000
10000000
00010000
11101000
NAME bedroomdresser 225

TIL 6f
00111111
00000000
00000000
00000000
00000000
00000011
00000000
00000111
NAME bedroomdresser 226

TIL 6g
11110000
00000000
00000000
00000000
00000000
10000000
11111111
11111111
NAME bedroomdresser 227

TIL 6h
00000000
00111111
01111100
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 228

TIL 6i
11110111
11001111
00011011
00100101
01000111
00000111
00000111
00001111
NAME bedroomdresser 229

TIL 6j
00001110
00000111
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 230

TIL 6k
00000010
11111100
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 231

TIL 6l
00000000
00000000
01000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 232

TIL 6m
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 233

TIL 6n
00000001
10000011
01111100
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 234

TIL 6o
00000000
11000001
00000000
00000000
10000001
00000001
00000000
00000001
NAME bedroomdresser 235

TIL 6p
00001010
00000001
00000100
00000100
00110000
00000000
00001000
01000000
NAME bedroomdresser 236

TIL 6q
00111100
01000000
00000010
00000000
00100100
00000001
10000000
01000000
NAME bedroomdresser 237

TIL 6r
01001000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 238

TIL 6s
00000010
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 239

TIL 6t
00000000
11110000
00001111
00000111
00001111
00000000
00000000
00000000
NAME bedroomdresser 240

TIL 6u
00000000
00000000
11110110
00001000
11110000
00000000
00000000
00000000
NAME bedroomdresser 241

TIL 6v
00000000
00000000
00000001
00000011
00000000
00000000
00000000
00000000
NAME bedroomdresser 242

TIL 6w
01111111
01110001
11001110
00000000
00000000
00000000
00000000
00000000
NAME bedroomdresser 243

TIL 6x
00111000
00010000
00001000
00010001
00000011
00000111
00001111
00001110
NAME bedroom 1

TIL 6y
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000000
NAME bedroom 2

TIL 6z
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME bedroom 3

TIL 7a
00000011
00000011
00100111
00110001
01110000
00110000
00000000
00000000
NAME bedroom 14

TIL 7b
00001100
00001111
00000111
00000011
00000011
00000001
00000000
00000000
NAME bedroom 15

TIL 7c
00000000
10000000
11000000
11100000
11100000
11100000
11110000
01110000
NAME bedroom 16

TIL 7d
01110000
00111000
00111000
00110000
00010000
00000000
00000000
00000000
NAME bedroom 17

TIL 7e
00110000
00010000
00100000
01000000
00000000
00000000
00000000
00000000
NAME bedroom 18

TIL 7f
00000001
00000001
00000011
00000011
00000001
00000001
00000000
00000000
NAME bedroom 19

TIL 7g
11111000
11111111
11111111
11111100
11111000
11110001
11000011
10000111
NAME bedroom 20

TIL 7h
00000000
10000000
10000000
00000000
00000000
11111100
10000000
00000000
NAME bedroom 21

TIL 7i
00000011
00000011
00000011
00000011
00000011
00000001
00000001
00000001
NAME bedroom 22

TIL 7j
01001111
00001110
00011000
00111000
01110000
01100000
11100000
11000000
NAME bedroom 23

TIL 7k
00000001
00000001
00000011
01111111
00011111
00000011
00000000
00000000
NAME bedroom 24

TIL 7l
00000001
00000001
00000011
00000111
00000111
00001110
00011110
00011100
NAME bedroom 25

TIL 7m
00000000
00000000
00000000
00000000
01000000
11000000
11000000
00000000
NAME bedroom 26

TIL 7n
00000000
00000000
00000000
00000000
00000001
00000011
00000011
00000111
NAME bedroom 27

TIL 7o
00111100
00111000
01111000
11110000
11100000
11100000
11000000
10000000
NAME bedroom 28

TIL 7p
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00000111
NAME bedroom 29

TIL 7q
00001111
00011111
00001110
01001100
00011100
11111000
11110000
11000000
NAME bedroom 30

TIL 7r
10000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 31

TIL 7s
00000000
00000000
00000010
00000000
00000000
00000000
00000000
00000000
NAME bedroom 32

TIL 7t
00001111
00011110
00111100
01111000
00011100
00000000
00000000
00000000
NAME bedroom 33

TIL 7u
00000000
00000000
00000000
00110000
11111110
11111110
00111111
00111111
NAME bedroom 34

TIL 7v
11000000
00110000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 35

TIL 7w
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11000000
NAME bedroom 36

TIL 7x
11111111
01111110
00111110
00000000
00000000
00000000
00000000
00000000
NAME bedroom 37

TIL 7y
00000000
00001000
00001101
00001100
00001100
00000100
00000000
00000000
NAME bedroom 38

TIL 7z
11110000
11000000
11000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 39

TIL 8a
00000000
00000000
00000000
00000000
00000011
00000111
00001111
00011111
NAME bedroom 50

TIL 8b
00000111
00000110
01111100
11111100
11110000
11100000
10000000
00000000
NAME bedroom 51

TIL 8c
00000110
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 52

TIL 8d
00111110
01111000
00011110
00000000
00000000
00000000
00000000
00000000
NAME bedroom 53

TIL 8e
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001100
NAME bedroom 54

TIL 8f
00000111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 55

TIL 8g
00000000
00000000
00000000
00000000
00000000
00000000
00001000
00000110
NAME bedroom 56

TIL 8h
11100000
11000000
11000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 57

TIL 8i
00000111
01000110
01100110
01100000
11100000
01100000
00000000
00000000
NAME bedroom 58

TIL 8j
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00110000
NAME bedroom 59

TIL 8k
00011000
00001111
00000111
00000111
00000011
00000001
00000000
00000000
NAME bedroom 60

TIL 8l
00000000
00000000
10000000
11000000
11100000
11100000
11100000
11110000
NAME bedroom 61

TIL 8m
01110000
01110000
01110000
01100000
00100000
00000000
00000000
00000000
NAME bedroom 62

TIL 8n
01100000
01100000
01000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 63

TIL 8o
00000001
00000001
00000001
00000011
00000011
00000001
00000001
00000000
NAME bedroom 64

TIL 8p
11110001
11111010
11111111
11111111
11111000
11110000
11100011
10000111
NAME bedroom 65

TIL 8q
00000000
00000000
00000000
00000000
00000000
11110000
11000110
00000000
NAME bedroom 66

TIL 8r
00000111
00000111
00000111
00000111
00000111
00000011
00000011
00000011
NAME bedroom 67

TIL 8s
10000111
00001110
00011100
00111000
01110000
01100000
11100000
11000000
NAME bedroom 68

TIL 8t
00000011
00000011
00000011
01100111
01111111
00001111
00000010
00000000
NAME bedroom 69

TIL 8u
00000001
00000001
00000011
00000111
00000111
00001110
00001110
00011100
NAME bedroom 70

TIL 8v
11000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 71

TIL 8w
00000000
00000000
00000000
00000000
00000000
10000000
10000000
00000000
NAME bedroom 72

TIL 8x
00000000
00000000
00000000
00000000
00000001
00000001
00000011
00000111
NAME bedroom 73

TIL 8y
00000000
00000001
00000001
00000000
00000000
00000000
00000000
00000000
NAME bedroom 74

TIL 8z
00001111
00011111
00011110
00001100
00011100
11111000
11111000
11000000
NAME bedroom 75

TIL 9a
00000011
00000011
00000011
00000011
00000011
00000011
00000111
00000111
NAME bedroom 86

TIL 9b
10000011
10000111
10000111
10000111
10000110
10000000
10001000
11010000
NAME bedroom 87

TIL 9c
00000000
00000001
10000011
00000010
00000000
00000010
00000000
00000000
NAME bedroom 88

TIL 9d
00011110
11110000
10110000
00110000
00000000
00000000
00000000
00000000
NAME bedroom 89

TIL 9e
00000000
00000000
00000010
00000001
00000001
00000001
00000001
00000001
NAME bedroom 90

TIL 9f
01111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME bedroom 91

TIL 9g
00000111
00001111
00001111
00001111
00000111
00000110
00000010
00000000
NAME bedroom 92

TIL 9h
11011000
11111000
11000000
10001111
00011100
00111000
01110000
01100000
NAME bedroom 93

TIL 9i
00000000
00000000
00000000
00000000
01100000
00000000
00000000
00000000
NAME bedroom 94

TIL 9j
00000001
00000001
00000001
00000001
00000000
00000000
00000000
00000000
NAME bedroom 95

TIL 9k
00000000
00000001
00000011
00000011
00000111
00000110
00001100
00001100
NAME bedroom 96

TIL 9l
00000001
00011111
00000111
00000001
00000000
00000000
00000000
00000000
NAME bedroom 97

TIL 9m
11111111
11111000
11111000
00000000
00000000
00000001
00000011
00000111
NAME bedroom 98

TIL 9n
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000011
NAME bedroom 99

TIL 9o
00011000
00011000
00111000
01110000
11100000
11100000
11000000
11000000
NAME bedroom 100

TIL 9p
00000000
00010000
00010000
00010000
00000000
00000000
00000000
00000000
NAME bedroom 101

TIL 9q
00000111
00000111
00000011
00000111
01001111
11001111
10001111
00001111
NAME bedroom 102

TIL 9r
00000011
00000111
00001111
00011110
00111110
00111100
00011000
00110000
NAME bedroom 103

TIL 9s
00000000
00000000
00000000
00000000
00000010
00000000
00000000
00000000
NAME bedroom 104

TIL 9t
00000001
00000111
00001111
00011110
00111100
11110000
00111000
00000000
NAME bedroom 105

TIL 9u
11100000
11000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 106

TIL 9v
00000001
00000011
00000011
00000011
00000011
00000011
00000011
00000001
NAME bedroom 107

TIL 9w
00000000
00000000
00000000
00000000
00000011
00000011
00000001
00000001
NAME bedroom 108

TIL 9x
00000000
00000000
00000000
00000000
11000000
11110000
11110000
11110000
NAME bedroom 109

TIL 9y
00001000
00001100
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 110

TIL 9z
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01000000
NAME bedroom 111

TIL a0
00000011
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 112

TIL a1
11110000
11110000
11100000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 113

TIL a2
00000000
00000010
00000001
00000011
00000001
00000000
00000000
00000000
NAME bedroom 114

TIL a3
00111000
00100000
01100000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 115

TIL a4
00000000
00000000
00000000
00000000
01000000
00100000
00111100
00011110
NAME bedroom 116

TIL a5
00001111
00000111
00000111
00000011
00000001
00000001
00000001
00000001
NAME bedroom 117

TIL a6
00000000
00000000
00000000
00000000
10000000
10000000
00000000
00000000
NAME bedroom 118

TIL a7
00000000
00000000
00000001
00000010
00000010
00000000
00000000
00000000
NAME bedroom 119

TIL a8
00000000
00000000
00000001
00000011
00000111
00001111
00111111
00111111
NAME bedroom 120

TIL a9
11010000
11000000
11000000
11000000
10000000
10000000
10000001
11110001
NAME bedroom 121

TIL aa
01110000
01110000
10110000
00000000
00000000
11100000
11000000
11000000
NAME bedroom 122

TIL ab
00000000
00000000
00000000
00000000
00000000
00000000
10000000
10000000
NAME bedroom 123

TIL ac
00000000
00000001
00000001
00000111
00001111
00000111
00000111
00000011
NAME bedroom 124

TIL ad
00111111
00011111
00011111
00000110
00000000
00000000
00000000
00000000
NAME bedroom 125

TIL ae
11111001
11111000
01111000
00111000
00111000
00110000
00110000
00110000
NAME bedroom 126

TIL af
11000000
11000000
11000000
11000000
11000000
11000001
11000001
10000000
NAME bedroom 127

TIL ag
01000000
00000000
01000000
00100000
00011100
11110000
10110000
00000000
NAME bedroom 128

TIL ah
00000000
00000000
00000000
00000000
00000001
00000111
00001111
00000111
NAME bedroom 129

TIL ai
00000001
00000001
00000000
10000000
11100000
11110000
11110000
11111000
NAME bedroom 130

TIL aj
11111111
11111111
01111100
01100000
00000000
00000000
00000000
00000000
NAME bedroom 131

TIL ak
00110000
01111000
01111010
01111110
11111000
01110001
01100011
01000110
NAME bedroom 132

TIL al
00000000
00000000
00000000
00000000
00000000
11000000
00001000
00000000
NAME bedroom 133

TIL am
00000111
00000111
00001111
00001111
00000111
00000111
00000111
00000111
NAME bedroom 134

TIL an
11111000
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME bedroom 135

TIL ao
00000000
00000000
00000000
10000000
11000000
11000000
10000000
10000000
NAME bedroom 136

TIL ap
00001100
00011000
00111000
00110000
01100000
01100000
11000000
11000000
NAME bedroom 137

TIL aq
00000111
00000111
01111111
00001111
00000000
00000000
00000000
00000000
NAME bedroom 138

TIL ar
11111111
11111111
11000100
10000000
00000000
00001110
00111111
01111111
NAME bedroom 139

TIL as
00000001
00000011
00000011
00000111
00001110
00001110
00011100
00111000
NAME bedroom 140

TIL at
10000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 141

TIL au
00010000
00010000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 142

TIL av
00000000
00000000
00000000
00000010
00000010
00000000
00000000
00000000
NAME bedroom 143

TIL aw
00111111
00111111
01111111
01111110
01111000
01110000
00000000
00000000
NAME bedroom 144

TIL ax
00000000
00000000
00000000
00000000
00000011
00001111
00011110
00111000
NAME bedroom 145

TIL ay
01111000
11110000
11100000
01000000
11000000
10000000
00000000
00000000
NAME bedroom 146

TIL az
00000000
00000000
00000000
00010000
00010000
00010000
00110000
00111000
NAME bedroom 147

TIL b0
00110000
01110000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 148

TIL b1
00111000
00111000
00011000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 149

TIL b2
00000000
00000000
00000000
00000000
00000000
00111100
01111110
01011110
NAME bedroom 150

TIL b3
00000000
00000000
00000100
00000000
00000000
00000000
00000000
00000000
NAME bedroom 151

TIL b4
00111110
00111100
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 152

TIL b5
00000000
00000100
00000010
00000010
00000000
00000000
00000000
00000000
NAME bedroom 153

TIL b6
11100000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 154

TIL b7
00000000
00000000
01100000
00111000
00011100
00001110
00001110
00000110
NAME bedroom 155

TIL b8
00000011
00000011
00000010
00000000
00000000
00000010
00000100
00000000
NAME bedroom 156

TIL b9
00001111
00011111
00011111
00011111
00001111
00000111
00000011
00000000
NAME bedroom 157

TIL ba
11100000
11100000
11111100
11111110
10111110
10011110
10001110
00001110
NAME bedroom 158

TIL bb
01110100
01110000
01110000
00110000
00110000
00010000
00010000
00111000
NAME bedroom 159

TIL bc
00010000
00001000
00001000
00000100
00000100
00000100
00000000
00001011
NAME bedroom 160

TIL bd
00000000
00000000
00000000
00000000
00000000
00000000
00001100
00011111
NAME bedroom 161

TIL be
00011111
00011111
00001111
00001111
00000111
00000001
00000001
10000000
NAME bedroom 162

TIL bf
00001100
00001100
00011100
00011100
00011110
00011110
00111111
00111111
NAME bedroom 163

TIL bg
00111000
00111000
00110000
00000000
01000000
00000000
11000000
11000000
NAME bedroom 164

TIL bh
00011010
00111010
00000010
00000000
00000000
00000000
00000000
00000000
NAME bedroom 165

TIL bi
10111111
01111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME bedroom 166

TIL bj
10000000
10000000
11000000
11100000
11110000
11111000
11111110
11111110
NAME bedroom 167

TIL bk
00111110
00111100
00011000
00010001
00000011
00000110
00001110
00001100
NAME bedroom 168

TIL bl
00000000
01111000
11000001
10000000
10000000
00000000
00000000
00000000
NAME bedroom 169

TIL bm
00000000
00000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 170

TIL bn
00000000
00000000
00000000
00000000
00000000
00000000
00000111
00000001
NAME bedroom 171

TIL bo
01111111
01111111
00111111
00111111
00111111
01111111
11111110
11111100
NAME bedroom 172

TIL bp
11111111
11111111
11111110
11111110
11111100
11111000
00110000
00100000
NAME bedroom 173

TIL bq
00011000
00011000
00110000
00110000
01100000
01100000
11000000
11000000
NAME bedroom 174

TIL br
00000000
00000000
00000000
00000000
00000000
00000000
00000010
00000010
NAME bedroom 175

TIL bs
01000000
00000000
00000000
00000011
00000011
00000001
00000001
00010011
NAME bedroom 176

TIL bt
00000000
00010000
11111000
11111100
11111100
11111100
11111100
11111000
NAME bedroom 177

TIL bu
00000001
00000011
00000111
00001111
00001110
00011100
00111100
01111000
NAME bedroom 178

TIL bv
00010011
00110111
00100011
00000000
00000000
00000000
00000000
00000000
NAME bedroom 179

TIL bw
11110000
11100000
11000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 180

TIL bx
00000000
00000001
00000001
00000111
00001111
00011110
00111000
11110000
NAME bedroom 181

TIL by
01110000
00100000
11100000
11000000
00000000
00000000
00000000
00000000
NAME bedroom 182

TIL bz
00000000
00000000
00000000
00000000
00000000
00000001
00000001
00000001
NAME bedroom 183

TIL c0
00000000
10000000
10000000
10000000
11000000
11000000
11000000
11100000
NAME bedroom 184

TIL c1
00111000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 185

TIL c2
11100000
11100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 186

TIL c3
00000000
00000000
00000000
00000000
00001100
00011111
00011111
00000111
NAME bedroom 187

TIL c4
00000000
10000000
01000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 188

TIL c5
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001000
NAME bedroom 189

TIL c6
00011111
00001111
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 190

TIL c7
00000110
01001100
00100100
01100000
00000000
00000000
00000000
00000000
NAME bedroom 191

TIL c8
00000000
00000000
00000000
00000100
00000111
00000011
00000001
00000000
NAME bedroom 192

TIL c9
00000000
00000000
00000000
00000000
10000000
11000000
11000000
11100000
NAME bedroom 193

TIL ca
11100000
01100000
01110000
01100000
00100000
00000000
00000000
00100000
NAME bedroom 194

TIL cb
01000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 195

TIL cc
00000001
00000001
00000001
00000011
00000011
00000111
00000011
00000011
NAME bedroom 196

TIL cd
11100000
11100000
11110010
11110100
11111110
11111110
11110000
11100011
NAME bedroom 197

TIL ce
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11100000
NAME bedroom 198

TIL cf
00001111
00001111
00011111
00011111
00011111
00011111
00001111
00001111
NAME bedroom 199

TIL cg
00000001
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 200

TIL ch
10000111
00001110
10001100
00011100
00110000
01110000
11100000
11000000
NAME bedroom 201

TIL ci
00000100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 202

TIL cj
00001111
00001111
00001111
00001111
00001111
11111111
01111111
00011111
NAME bedroom 203

TIL ck
00000001
00000001
00010011
00000011
00000111
00001110
00001110
00011100
NAME bedroom 204

TIL cl
00000000
00000000
00000000
00000000
00000000
00000001
00000011
00000011
NAME bedroom 205

TIL cm
00011000
00111000
01111000
11110000
11100000
11100000
11000000
11000000
NAME bedroom 206

TIL cn
00000010
00000010
00000110
00000110
00000100
00000000
00000000
00000000
NAME bedroom 207

TIL co
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011
NAME bedroom 208

TIL cp
00000111
00001111
00011110
00011110
00001100
00011000
11110000
11110000
NAME bedroom 209

TIL cq
00000000
00000000
00000000
00000010
00000000
00000000
00000000
00000000
NAME bedroom 210

TIL cr
00001111
00001111
00111110
00111000
01111000
00000000
00000000
00000000
NAME bedroom 211

TIL cs
11000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 212

TIL ct
00000000
00000000
00000000
00000000
00000001
00000001
00000000
00000000
NAME bedroom 213

TIL cu
00000000
00000000
00000000
01100000
11111000
11111100
01111110
01111110
NAME bedroom 214

TIL cv
00000000
11000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 215

TIL cw
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000100
NAME bedroom 216

TIL cx
11111100
11111100
00111000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 217

TIL cy
00000011
00100010
00110110
00110000
00110000
00000000
00000000
00000000
NAME bedroom 218

TIL cz
00000000
00000000
00000000
00000000
00000000
00001000
00000110
00000011
NAME bedroom 219

TIL d0
11100000
11100000
11110000
01110000
01110000
00111000
00111000
00111000
NAME bedroom 220

TIL d1
00010000
00000000
00000000
00000000
00110000
00100000
00100000
00000000
NAME bedroom 221

TIL d2
11100111
11000111
00000111
00000111
00000111
00000111
00000111
00000111
NAME bedroom 222

TIL d3
10000110
10000110
10000111
00001110
00000111
00000100
00000000
00001000
NAME bedroom 223

TIL d4
00000000
00000000
00000001
00000011
00000111
00000100
00000000
00000000
NAME bedroom 224

TIL d5
01000000
01000000
00101100
11100000
01100000
01000000
00000000
00000000
NAME bedroom 225

TIL d6
00000000
00000000
00000000
00000011
00000111
00000111
00000011
00000011
NAME bedroom 226

TIL d7
00000000
11100000
11111100
11111100
11111110
11111110
11111111
11111111
NAME bedroom 227

TIL d8
00001111
00001111
00001111
00011111
00001111
00001111
00000100
00000100
NAME bedroom 228

TIL d9
10010000
10100000
11110000
11100000
10000000
00011111
00110000
01110000
NAME bedroom 229

TIL da
00000000
00000000
00000000
00000000
00000000
10000000
00000000
00000000
NAME bedroom 230

TIL db
00000011
00000111
00000111
00000111
00000011
00000011
00000011
00000011
NAME bedroom 231

TIL dc
00000100
00000001
00000001
00000011
00000111
00000110
00001100
00001100
NAME bedroom 232

TIL dd
00000011
00000011
00111111
00011111
00000111
00000000
00000000
00000000
NAME bedroom 233

TIL de
11111111
11111111
11110001
11100001
00000000
00000000
00000010
00000111
NAME bedroom 234

TIL df
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000001
NAME bedroom 235

TIL dg
00011000
00111000
00110000
01110000
01100000
11100000
11100000
11000000
NAME bedroom 236

TIL dh
00000000
00000000
00100000
00100000
00100000
00000000
00000000
00000000
NAME bedroom 237

TIL di
00011111
00011111
00001111
00001111
00011111
10011111
10011111
00111111
NAME bedroom 238

TIL dj
00000011
00000111
00001111
00001110
00011110
00111100
00111000
00110000
NAME bedroom 239

TIL dk
00011100
00000000
00000000
00000000
00000000
00000000
00000000
00000100
NAME bedroom 240

TIL dl
00000000
00000000
00000000
00000000
00000000
00000010
00000000
00000000
NAME bedroom 241

TIL dm
00000001
00000001
00000111
00011111
00111100
00111000
01110000
00000000
NAME bedroom 242

TIL dn
11110000
11100000
10000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 243

TIL do
00000110
00000110
00000110
00001110
00001111
00001111
00001111
00000111
NAME bedroom 244

TIL dp
00000000
00000000
00000000
00000000
00000111
00000111
00000011
00000001
NAME bedroom 245

TIL dq
00000000
00000000
00000000
00000000
10000000
11100000
11100000
11110000
NAME bedroom 246

TIL dr
00000000
00011000
00000100
00000000
00000000
00000000
00000000
00000000
NAME bedroom 247

TIL ds
00000111
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 248

TIL dt
00000000
00000100
00000110
00000110
00000110
00000000
00000000
00000000
NAME bedroom 249

TIL du
01110000
11000000
11000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 250

TIL dv
00000000
00000000
00000000
00000000
10000000
01100000
00111000
00111100
NAME bedroom 251

TIL dw
00011100
00001110
00001110
00000110
00000111
00000110
00000000
00000000
NAME bedroom 252

TIL dx
00000000
00000110
00000100
00000100
00000000
00000000
00000000
00000000
NAME bedroom 253

TIL dy
00000000
00000000
11000000
11000000
11000000
11000000
11000000
11000000
NAME bedroom 254

TIL dz
11111111
11111111
01010011
00000111
00000111
00000111
00000010
00000000
NAME bedroom 255

TIL e0
11010100
10111111
11111111
11111111
11111100
01111111
00111111
00111110
NAME bedroom 256

TIL e1
10111101
11111001
11110101
11001111
10001111
10001110
00000100
00000000
NAME bedroom 257

TIL e2
01100000
01100000
11100000
10100000
10100000
10100000
10100000
10000000
NAME bedroom 258

TIL e3
00000000
00000000
00000000
00000000
00000000
00000001
00000000
00000001
NAME bedroom 259

TIL e4
11000000
11000000
11000011
11000111
11000100
11000100
11000110
11000110
NAME bedroom 260

TIL e5
00000000
00000011
11111111
11000000
11000000
01000000
01100011
00101111
NAME bedroom 261

TIL e6
00000000
11111111
11111111
00000000
00000001
00001111
01111110
11110001
NAME bedroom 262

TIL e7
00000000
11111111
00000001
00000111
01111110
10111100
01110000
11100000
NAME bedroom 263

TIL e8
00000000
11100000
10000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 264

TIL e9
00111100
00010011
00000000
00010000
00111000
00111100
00111000
00111100
NAME bedroom 265

TIL ea
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME bedroom 266

TIL eb
00001010
00000101
00001010
00000101
00001010
00000101
00001000
00000101
NAME bedroom 267

TIL ec
11000110
11000011
11000011
11000011
11000011
11000001
11000001
11000000
NAME bedroom 268

TIL ed
00111111
00100100
00110000
10110000
01110000
00110001
10010111
01011100
NAME bedroom 269

TIL ee
11000011
00000110
00001100
00110000
11000000
10000000
00000000
00000000
NAME bedroom 270

TIL ef
00111000
00010000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 271

TIL eg
00000000
00000000
00000000
00000010
00000100
00000101
00000101
00000101
NAME bedroom 272

TIL eh
11000000
11000000
11000000
11000000
11000000
11000000
11000000
11000000
NAME bedroom 273

TIL ei
00000000
00000000
00000000
00000000
00000000
00000000
00010000
00001000
NAME bedroom 274

TIL ej
00000000
00000000
00000000
00000000
00000000
01000000
01000000
00110000
NAME bedroom 275

TIL ek
00001000
00000101
00001010
00000101
00000010
00000101
00000010
00000001
NAME bedroom 276

TIL el
11000000
11000000
11000000
11100000
11100000
11100000
11100000
11100000
NAME bedroom 277

TIL em
00111000
00001000
00001000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 278

TIL en
00000000
00000000
10000000
11110000
10001000
10010000
10010000
10010000
NAME bedroom 279

TIL eo
00000000
00000000
00000000
00000000
00110000
00111111
00100000
00100000
NAME bedroom 280

TIL ep
00000111
00000111
00000111
00000111
00000011
00000011
10000011
10000011
NAME bedroom 281

TIL eq
00101100
00100100
00100110
01100011
01100011
01100001
01100000
01000100
NAME bedroom 282

TIL er
00000000
00000000
00000000
00000000
10000000
11000000
11000000
01100000
NAME bedroom 283

TIL es
01111000
11111000
10111000
00111000
00111100
00111100
00111100
00111100
NAME bedroom 284

TIL et
00000010
00000001
00000010
00000001
00000010
00000001
00000000
00000001
NAME bedroom 285

TIL eu
11100000
11100000
11100000
01100000
11100000
01100000
11100000
01100000
NAME bedroom 286

TIL ev
10010000
10010000
10010000
10010000
10010000
10010001
10011111
10010100
NAME bedroom 287

TIL ew
00000000
00000000
00000000
00000000
00000000
11100000
11011111
00110000
NAME bedroom 288

TIL ex
00000000
00000000
00000000
00000000
00010000
00001111
11111111
01010101
NAME bedroom 289

TIL ey
00000000
00000000
00000000
00000000
00000000
11111111
11111110
11010111
NAME bedroom 290

TIL ez
00100001
00100001
00100001
00100001
00100001
11100001
10100011
00100011
NAME bedroom 291

TIL f0
00000011
00000011
00000011
00000011
00001111
00001111
00001111
00001111
NAME bedroom 292

TIL f1
01000100
01000111
01000011
01000101
01100111
01100010
01110011
01110001
NAME bedroom 293

TIL f2
01110000
00101000
10011100
10001100
01000110
11100011
10100011
11000001
NAME bedroom 294

TIL f3
00111100
00111100
00111100
00111110
00111110
00111110
00111110
00111110
NAME bedroom 295

TIL f4
00000000
00000001
00000000
00000001
10001000
00000001
10001000
00000001
NAME bedroom 296

TIL f5
11100000
01100000
11100000
01100000
11100000
01100000
10100000
00100001
NAME bedroom 297

TIL f6
00000000
00000000
00000000
00000000
00000000
00000000
11111111
10000000
NAME bedroom 298

TIL f7
00000000
00000000
00000011
00000100
00000000
00000000
11110100
00001011
NAME bedroom 299

TIL f8
10011010
10010100
00111000
10010101
01001111
00000000
00000000
00000000
NAME bedroom 300

TIL f9
10101011
01010110
10101000
01010000
10100000
00000000
00000000
00000001
NAME bedroom 301

TIL fa
11101011
00011111
00111011
01100101
01001010
11010101
10101100
01010100
NAME bedroom 302

TIL fb
10101110
11111101
01111110
11010101
01111011
00011100
00001000
00000000
NAME bedroom 303

TIL fc
10100011
01100011
10100011
11111101
10100011
00000001
00000001
00000010
NAME bedroom 304

TIL fd
00001111
00010111
00010111
00000111
00000011
00000010
00000010
00000010
NAME bedroom 305

TIL fe
11100001
11100000
11100000
11100000
11100000
11100000
11100010
11100011
NAME bedroom 306

TIL ff
11000001
11100000
01100000
01110000
00111000
00111000
10011110
11000011
NAME bedroom 307

TIL fg
10000000
11000000
01100000
00110000
00010000
00010000
00001100
00000100
NAME bedroom 308

TIL fh
00111110
00111110
00111110
00111110
00111110
00111110
00111110
00111110
NAME bedroom 309

TIL fi
10001000
01000101
10001000
01000101
10101010
01000001
00101000
01000001
NAME bedroom 310

TIL fj
10100001
01100011
10100011
00100111
10100011
00100011
10110100
00110110
NAME bedroom 311

TIL fk
10000000
00000000
00000000
00000000
11000000
11111111
00000000
00000000
NAME bedroom 312

TIL fl
00010001
00011001
00111000
00101010
11101100
01001100
01001000
01001000
NAME bedroom 313

TIL fm
10000000
10111111
11100001
00000010
00000111
00001000
00000000
00000001
NAME bedroom 314

TIL fn
00000010
10000101
11000010
00110011
11000001
00000011
00000001
10000000
NAME bedroom 315

TIL fo
10101100
01110100
10100010
01011001
11111110
11111111
00000100
10000100
NAME bedroom 316

TIL fp
00000000
00000000
00000000
00001111
00000001
00000011
00000110
00000010
NAME bedroom 317

TIL fq
00000100
00000011
11110000
01100000
10010000
11100000
00000000
00000000
NAME bedroom 318

TIL fr
00000010
00000010
11000010
00110010
00001010
00000110
00000100
00000100
NAME bedroom 319

TIL fs
11100001
11110000
11111001
01111100
01011110
00111111
00011110
00011111
NAME bedroom 320

TIL ft
01001011
11100101
11110111
11110010
11011011
01111101
11101111
01110111
NAME bedroom 321

TIL fu
10000100
10000100
11000100
11100100
01100100
11110100
01110100
11011100
NAME bedroom 322

TIL fv
00111110
00110111
00110111
00110111
00110111
00110110
00110110
00110110
NAME bedroom 323

TIL fw
00001000
01010000
00001010
01010001
00001010
01000100
00101010
01000101
NAME bedroom 324

TIL fx
10110110
00111010
10101011
00100011
01100011
01000001
10000000
10000000
NAME bedroom 325

TIL fy
11001100
11001011
01011100
11110001
01000011
10000111
00000110
00000100
NAME bedroom 326

TIL fz
00000010
00000010
11111100
01010000
10000000
00000000
00000000
00000001
NAME bedroom 327

TIL g0
01110001
00001100
00000000
00000000
00000000
00000000
00000000
00101000
NAME bedroom 328

TIL g1
00000010
00000001
00000000
00000000
01100000
10000000
01111010
00001000
NAME bedroom 329

TIL g2
00000100
00111111
11000000
01111000
00000011
00000001
00000000
00000000
NAME bedroom 330

TIL g3
00000000
11100000
00011111
00000111
11111111
11110000
00000000
00000000
NAME bedroom 331

TIL g4
00111100
01110000
10001111
11110001
11000000
01000000
01000000
01100000
NAME bedroom 332

TIL g5
00000000
00000000
00000000
00000000
10000000
10000000
01000000
01000000
NAME bedroom 333

TIL g6
00001111
00000111
00000011
00000001
00000001
00000000
00000000
00000001
NAME bedroom 334

TIL g7
11111010
11111011
11111101
11111110
10110110
11111111
01111111
00111111
NAME bedroom 335

TIL g8
11111100
01111100
10011100
11001100
01101100
00111100
10011100
11001100
NAME bedroom 336

TIL g9
00110110
00110110
00111110
00111110
00011110
00011111
00011110
00011111
NAME bedroom 337

TIL ga
10101001
01010111
10101011
01010111
10101110
01011110
10101110
01011100
NAME bedroom 338

TIL gb
10000000
10000000
10000010
00000101
00001010
00010101
00101000
00010000
NAME bedroom 339

TIL gc
00000000
00100100
10101000
01010000
10110000
01001000
10001000
01110001
NAME bedroom 340

TIL gd
00000110
00000100
00000100
00001000
00001000
00011000
01111001
00100111
NAME bedroom 341

TIL ge
00000110
00011000
00000000
00000000
00011101
01101110
10001000
00000000
NAME bedroom 342

TIL gf
11010000
00000000
00000000
00000100
11111010
00000001
00000001
00000010
NAME bedroom 343

TIL gg
00001000
00001000
00001000
00001000
00001000
00001000
00000000
00000000
NAME bedroom 344

TIL gh
00000000
00000000
00000001
00000011
00000001
00000001
00000001
00000000
NAME bedroom 345

TIL gi
00000000
00100000
00000000
00000000
10000000
10001000
11001100
10101100
NAME bedroom 346

TIL gj
01100000
00110000
00110000
00111000
00011000
00011000
00011100
00001100
NAME bedroom 347

TIL gk
00100000
00100000
00010000
00010000
00001000
00000100
00000010
00000001
NAME bedroom 348

TIL gl
00000101
00000011
00000011
00000011
00001001
00000000
00000000
00000001
NAME bedroom 349

TIL gm
01111111
10111111
11101111
10001111
00000111
01110111
10111011
11111101
NAME bedroom 350

TIL gn
11101100
11111100
11111100
11101100
11101100
11011100
11111100
11101100
NAME bedroom 351

TIL go
00001110
00001110
00001110
00001110
00001110
00001111
00001110
00001111
NAME bedroom 352

TIL gp
10110100
01010100
10101000
01101000
11010000
01110000
11010000
10110000
NAME bedroom 353

TIL gq
00101000
01010000
00000000
00000000
00000000
00000001
00000001
00000001
NAME bedroom 354

TIL gr
00000110
00001100
00111000
01100000
10000000
10000001
00000011
00000110
NAME bedroom 355

TIL gs
00000000
00000000
00000000
01000000
10000000
00000000
10100000
01000000
NAME bedroom 356

TIL gt
00000001
00000000
00000000
00000001
00000001
00000010
00000100
00011000
NAME bedroom 357

TIL gu
00000000
10000000
10000000
00000000
00000111
00000000
00000001
00000010
NAME bedroom 358

TIL gv
00000000
00000000
00000000
00000000
11100000
00110000
11000000
00000000
NAME bedroom 359

TIL gw
11011000
01001000
01100000
01100000
00100000
00000000
00000000
00000000
NAME bedroom 360

TIL gx
00001110
00001110
00000110
00000110
00000110
00000111
00000011
00000011
NAME bedroom 361

TIL gy
00000001
00000000
00000000
00000000
00000000
00000000
00101000
01010001
NAME bedroom 362

TIL gz
00000001
10000001
10000000
01000000
01100000
00100000
00110000
00010000
NAME bedroom 363

TIL h0
11111000
11010000
11100001
11110101
11111101
11111110
01101111
00001111
NAME bedroom 364

TIL h1
01111100
11110100
11110000
11111000
11011100
10010100
00000000
10000000
NAME bedroom 365

TIL h2
00001111
00001111
00001111
00001111
00001111
00001111
00001111
00000111
NAME bedroom 366

TIL h3
10100000
11100000
01000000
11000000
10000000
10000000
00000000
00000000
NAME bedroom 367

TIL h4
00000010
00000010
00000010
00000110
00000010
00000100
00000100
00000100
NAME bedroom 368

TIL h5
00000000
00000001
00000011
00001110
00010011
00101100
01000000
01000000
NAME bedroom 369

TIL h6
10000000
01110000
11111111
00000000
10000000
01111111
00000000
00000000
NAME bedroom 370

TIL h7
00000000
11111111
11111111
00000000
00000111
11111000
00000000
00000000
NAME bedroom 371

TIL h8
00010000
11111111
11111000
00000111
11111000
00000000
00000000
00000000
NAME bedroom 372

TIL h9
00000100
11111111
00000000
11110000
00001111
00000000
00000000
00000000
NAME bedroom 373

TIL ha
01100000
11000000
11111111
00000011
11111101
00000000
00000000
00000000
NAME bedroom 374

TIL hb
00000000
00000000
11111111
11111111
11111111
10011100
00000000
00000000
NAME bedroom 375

TIL hc
00000011
00000011
11111111
11000001
10111001
00000111
00000001
00000001
NAME bedroom 376

TIL hd
00001000
11010101
10101000
10010100
10101010
10010100
10001010
10010101
NAME bedroom 377

TIL he
00011010
00001100
00001110
00000111
10000010
00000011
00000001
01000001
NAME bedroom 378

TIL hf
00000111
00000011
00000001
00000001
10000000
01000000
10100000
11010000
NAME bedroom 379

TIL hg
10000000
11000000
11100000
11100000
11110000
01111000
01110000
00100000
NAME bedroom 380

TIL hh
00000110
00001110
00001100
00011100
00011100
00011000
00111000
00110000
NAME bedroom 381

TIL hi
00000000
00000000
00000000
00000000
00000000
00000001
00000010
00001100
NAME bedroom 382

TIL hj
00000100
00001000
00001000
00010000
01110000
11000000
00000000
00000000
NAME bedroom 383

TIL hk
00000000
00010000
00010000
00010000
00010000
00111000
00001100
01001100
NAME bedroom 384

TIL hl
00000001
00000011
00000011
00000011
00000011
00000111
00000111
00000111
NAME bedroom 385

TIL hm
10001000
10010101
10001000
10010101
10001010
10010001
00001000
00000001
NAME bedroom 386

TIL hn
10000000
00000000
10100000
00000000
10000000
00000000
00000000
00000000
NAME bedroom 387

TIL ho
10101000
11010100
01001000
00100100
00100000
00010101
00011010
00001101
NAME bedroom 388

TIL hp
00000000
00000000
00000000
00000000
00000000
00000000
10000000
01000000
NAME bedroom 389

TIL hq
01110000
01110000
11110000
11100000
10100000
11000000
11000000
10000000
NAME bedroom 390

TIL hr
00011000
00100000
01000000
10000000
01000000
00100001
10000000
00000000
NAME bedroom 391

TIL hs
00000000
00000001
00000010
00001100
10011000
00000000
00000000
00000000
NAME bedroom 392

TIL ht
10101100
00101100
00101000
00101000
00101000
10111000
00101000
00011000
NAME bedroom 393

TIL hu
00000111
00001011
00001001
00001011
00010011
00001001
00001011
00001111
NAME bedroom 394

TIL hv
00000000
00000000
10000000
00000000
00000000
00000000
10000000
10000000
NAME bedroom 395

TIL hw
00001100
00000111
00000110
00000011
00000010
00000001
00000001
00000000
NAME bedroom 396

TIL hx
10100000
01000000
10100000
01010000
10100000
11010100
11101010
11010100
NAME bedroom 397

TIL hy
10000000
00100000
00000000
00000001
00000000
00000000
00000000
00000000
NAME bedroom 398

TIL hz
11010010
10000101
10101010
10000011
01000010
01010101
01101000
01101111
NAME bedroom 399

TIL i0
00010000
00000000
10100000
00000001
00000010
00000100
01111000
10000000
NAME bedroom 400

TIL i1
00011100
01011000
10001000
01001000
01011111
00101000
00010000
00000000
NAME bedroom 401

TIL i2
00000000
00000001
00111111
11111111
11111111
00000000
00000000
00000000
NAME bedroom 402

TIL i3
00000000
11111111
11111111
11111111
11111111
00000000
00000000
00000000
NAME bedroom 403

TIL i4
00000000
11111100
11111111
11110000
11111111
00000000
00000001
00011110
NAME bedroom 404

TIL i5
00000000
00000111
11111111
01111111
11111111
00001111
11110000
00000000
NAME bedroom 405

TIL i6
00000001
11111111
10000000
11111111
11111111
11000000
00000000
00000000
NAME bedroom 406

TIL i7
11111111
11111111
00000000
11000000
11111110
01111000
00000000
00000000
NAME bedroom 407

TIL i8
11111111
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 408

TIL i9
11111000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 409

TIL ia
11101010
01010101
00111010
00101101
00011010
00011101
00001010
00000011
NAME bedroom 410

TIL ib
00000000
00000000
10000000
01000000
10100000
01000000
10100000
01010000
NAME bedroom 411

TIL ic
00010000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 412

TIL id
00111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 413

TIL ie
11111110
00000011
00001100
00000000
00000000
00000000
00000000
00000101
NAME bedroom 414

TIL if
00000000
10000000
00000000
00000000
00000000
00000000
00000000
01010101
NAME bedroom 415

TIL ig
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01010000
NAME bedroom 416

TIL ih
00000000
00000001
00000000
00000001
00000010
00000000
00000010
00010101
NAME bedroom 417

TIL ii
00001010
01010101
00101010
01010101
10100000
00000101
10101010
00000000
NAME bedroom 418

TIL ij
10000000
01010000
10000000
01000000
00000000
01000000
10100000
00000000
NAME bedroom 419

TIL ik
00000011
00000001
00000001
00000000
00000000
00000000
00000000
00000000
NAME bedroom 420

TIL il
10100000
11010000
10001000
11000000
01101000
00100100
00010000
00010000
NAME bedroom 421

TIL im
00000010
00000101
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 422

TIL in
10101010
01000001
10101010
00000000
00000000
00000000
00000000
00000000
NAME bedroom 423

TIL io
00000000
01010001
10101010
00000000
00000000
00000000
00000000
00000000
NAME bedroom 424

TIL ip
00000010
01010100
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 425

TIL iq
10100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bedroom 426

TIL ir
00001000
00011000
00001100
00000000
00000000
00000000
00000000
00000000
NAME bedroom 427

TIL is
10010000
01101000
10110100
10011100
01101110
00011111
00000011
00000000
NAME hallway 1

TIL it
00000000
00000000
00000000
00000000
00000000
00000000
11000000
11111100
NAME hallway 2

TIL iu
00111111
00001011
00000010
00000010
00000010
00000010
00000010
00000010
NAME hallway 3

TIL iv
00000000
00000000
00000000
00000000
00000000
00000101
00000010
00000001
NAME hallway 4

TIL iw
00000011
00000111
00000111
00000111
00000111
00000111
00001111
00001111
NAME hallway 5

TIL ix
00000000
00000000
00000000
10000000
10000000
10000000
10000000
10000000
NAME hallway 6

TIL iy
00000000
00000000
00000000
00000000
00000000
00000000
00000111
00000011
NAME hallway 7

TIL iz
00000000
00000000
00000000
00000000
00000011
11111100
00000000
00000000
NAME hallway 8

TIL j0
00000000
00000000
00000000
00000000
10000000
01000000
00100000
00010000
NAME hallway 9

TIL j1
10000000
01000000
00100000
00010101
00001010
00000101
00000010
00000000
NAME hallway 10

TIL j2
10000000
01000000
00000000
00000001
10000000
01000001
00101010
00010101
NAME hallway 11

TIL j3
00000000
00000000
00000000
00000000
00100000
00010000
10001000
00000000
NAME hallway 12

TIL j4
00001111
00001111
00001111
00001111
00011111
00011111
00011111
00011110
NAME hallway 13

TIL j5
10000000
10000000
00000000
00000000
00000000
00000000
00000001
00000111
NAME hallway 14

TIL j6
00001110
00001011
00001000
00001000
01111000
10111000
11111100
10111110
NAME hallway 15

TIL j7
11000000
00110000
10001000
01101100
00011010
00001111
00001111
00001111
NAME hallway 16

TIL j8
00011000
00001100
00000011
00000110
00001111
11111110
11100000
11100000
NAME hallway 17

TIL j9
00000000
00000000
00000000
11110000
11011100
01100000
00010000
00001010
NAME hallway 18

TIL ja
00001000
00000101
00000000
00000000
00000000
00000000
00000000
00000000
NAME hallway 19

TIL jb
10000000
00000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME hallway 20

TIL jc
00011110
00011110
00010110
00000110
00000110
00000110
00000110
00000110
NAME hallway 21

TIL jd
00001110
00010110
00101001
00100100
00011100
00011110
00001111
00001111
NAME hallway 22

TIL je
00110011
00110000
10110000
01110000
00110000
00101100
00100010
11110001
NAME hallway 23

TIL jf
10001100
11001100
00111100
00011100
00011100
00011011
00011001
00011000
NAME hallway 24

TIL jg
00111000
00011100
00001111
00011011
00011001
00010000
10010000
01110000
NAME hallway 25

TIL jh
00000111
00001101
01111000
11100000
11000000
11100000
01111000
00010000
NAME hallway 26

TIL ji
10000000
11000000
00110000
00001100
00000110
00000011
00000000
00000011
NAME hallway 27

TIL jj
00000000
00000000
00000000
00000000
00000000
00000000
11000000
00100000
NAME hallway 28

TIL jk
00000000
00000000
00000000
00000000
10000000
01010000
10000000
00000000
NAME hallway 29

TIL jl
00000000
00000000
00000000
00110000
00011100
00010111
00010011
00010111
NAME hallway 30

TIL jm
00000000
00000000
00000000
00000000
00000000
00000000
10000000
11000000
NAME hallway 31

TIL jn
11110000
11111000
01111100
00111110
00101111
00010111
00001011
01000101
NAME hallway 32

TIL jo
00000100
00000100
00000100
00000100
10000100
11100100
11010100
11111100
NAME hallway 33

TIL jp
00001110
00001110
00001110
00011100
00011100
00011100
00011100
00001100
NAME hallway 34

TIL jq
01101100
00010010
00000001
00000000
01000000
01100000
11011000
11110100
NAME hallway 35

TIL jr
11011000
00111000
00111000
11110110
00110001
00011000
00001100
00000111
NAME hallway 36

TIL js
00011100
00011111
00010011
00010001
10010000
01010000
00110000
00111000
NAME hallway 37

TIL jt
00001100
00000010
11000001
10100000
11110000
01111000
00010100
00001111
NAME hallway 38

TIL ju
00000110
00001100
00111000
11100001
10110111
10011110
10000100
10000100
NAME hallway 39

TIL jv
00010000
00011100
01100110
10000110
10000100
10100100
11100100
11101100
NAME hallway 40

TIL jw
00000000
00000100
00000000
00000000
00000010
00000000
00000010
00000000
NAME hallway 41

TIL jx
10100000
01010000
10000000
01000000
00100000
00000000
00000000
00000000
NAME hallway 42

TIL jy
00010001
00100000
00100000
00100000
00100000
00100000
00100000
00100000
NAME hallway 43

TIL jz
11110000
11111000
01011000
00101100
00011110
00000101
00000010
00000001
NAME hallway 44

TIL k0
00000000
00000000
00000000
00000000
00000000
10000000
11000000
11110000
NAME hallway 45

TIL k1
00100010
01000001
00101000
00010101
00101000
00010100
00001000
00000000
NAME hallway 46

TIL k2
10111110
01011111
10100111
01010001
10001000
00000100
10001010
01010101
NAME hallway 47

TIL k3
00001101
00001101
11001101
11001101
01001101
00001101
00001100
00101101
NAME hallway 48

TIL k4
10011111
10000101
10000011
10000000
10000000
00000000
00000000
11010000
NAME hallway 49

TIL k5
00000001
10000000
10000000
11000000
00110000
00001000
00001000
00000110
NAME hallway 50

TIL k6
10110110
11110001
00110000
00111000
00101100
00000011
00000000
00000000
NAME hallway 51

TIL k7
00000011
10000001
01000001
00110001
00001001
10000111
11100001
01111111
NAME hallway 52

TIL k8
10000100
11110100
11101111
10100111
10011111
10000110
01000110
11000110
NAME hallway 53

TIL k9
11101100
01111100
11100100
11100100
01100100
01100100
01100100
01100110
NAME hallway 54

TIL ka
00100000
01100000
01100000
01100000
01100000
01000000
01000000
11000000
NAME hallway 55

TIL kb
01111000
00111000
00011110
00001111
00000111
00000011
00000000
00000000
NAME hallway 56

TIL kc
00000000
00000000
00000000
00000000
00000000
10000000
11010000
01101000
NAME hallway 57

TIL kd
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME hallway 58

TIL ke
00001000
11000100
00100010
00011001
00111010
01110001
10010000
00101000
NAME hallway 59

TIL kf
00101100
00101100
00101000
01001000
11001000
01111000
10101100
00011010
NAME hallway 60

TIL kg
00111000
00011100
00000111
00000001
00000000
00000000
00000000
00000000
NAME hallway 61

TIL kh
00000001
00000001
00000011
11000011
10100011
00011010
00000110
00000000
NAME hallway 62

TIL ki
00111101
00010111
00001111
00000011
00000001
00100000
01100000
01010000
NAME hallway 63

TIL kj
10110110
00001110
10000110
11100111
11110000
01111000
00011111
00011011
NAME hallway 64

TIL kk
01101100
01111100
01110111
01110101
11100000
11000000
01000000
11000000
NAME hallway 65

TIL kl
00000000
00000000
00000000
10000000
11100000
01100000
01010000
10010000
NAME hallway 66

TIL km
11000000
11000000
11000000
11000000
11000000
11000000
11000000
10000000
NAME hallway 67

TIL kn
00110000
00001100
00000010
00000110
00000110
00000110
00000110
00000100
NAME hallway 68

TIL ko
00100100
00011000
00000000
00000000
00000000
00000000
00000010
01000001
NAME hallway 69

TIL kp
10101001
01010111
00101010
01010001
00101000
00010101
00001100
00000011
NAME hallway 70

TIL kq
00000000
11000000
11100000
01110000
11111000
00111100
10001010
01010111
NAME hallway 71

TIL kr
01011100
11001110
11000011
10000001
10000000
11000000
11100000
00110100
NAME hallway 72

TIL ks
00000111
00000001
10000000
11000000
01110000
00111000
00001100
00000010
NAME hallway 73

TIL kt
11100001
10010001
01101110
00011001
00000100
00001110
00001100
00011100
NAME hallway 74

TIL ku
00100000
00100000
11100000
00100000
01100000
01100000
01100000
01100000
NAME hallway 75

TIL kv
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME hallway 76

TIL kw
10000000
10000000
10000000
10000000
10000000
10000000
10000000
00000000
NAME hallway 77

TIL kx
00001101
00001101
00001110
00001110
00001110
00001110
00001110
00001110
NAME hallway 78

TIL ky
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00000000
NAME hallway 79

TIL kz
11101000
10100101
01100000
00110100
00011110
00111011
10101010
11011001
NAME hallway 80

TIL l0
00000000
00000000
10000000
01000000
00000000
01000000
10100000
00010100
NAME hallway 81

TIL l1
11101001
01110100
00101110
00000101
00000000
00000000
00000000
00000000
NAME hallway 82

TIL l2
11000000
11110000
01111000
10010100
11101011
01011111
00000111
00000001
NAME hallway 83

TIL l3
00000000
00000000
00000000
00000000
00000010
10000001
11100000
11111000
NAME hallway 84

TIL l4
00011110
00000111
00000011
00000000
00000000
00010000
10001000
01000100
NAME hallway 85

TIL l5
00000001
00000010
10100110
11010110
00110100
00011100
10001000
01000000
NAME hallway 86

TIL l6
00011000
00111000
00111000
00111000
00110000
00110000
01110000
00110000
NAME hallway 87

TIL l7
01100000
01100000
01000000
11000000
11000000
11000000
11000000
11000000
NAME hallway 88

TIL l8
00000011
00000011
00000011
00010011
00100011
00010011
00100011
00000110
NAME hallway 89

TIL l9
00001110
00001110
00011110
00011110
00011110
00011100
00011100
00011100
NAME hallway 90

TIL la
00110111
00001111
00001011
00000100
00000000
00000001
00000010
00000000
NAME hallway 91

TIL lb
10000000
10010000
00000000
01000000
00100000
00000000
00000000
00000000
NAME hallway 92

TIL lc
00000000
00000000
00000000
00000010
00011101
01100011
00000000
00000001
NAME hallway 93

TIL ld
00000000
00000100
00000010
00000000
00000000
00000000
10000000
00000000
NAME hallway 94

TIL le
11111100
00111110
10001111
01000111
10100011
01010001
00101000
00010001
NAME hallway 95

TIL lf
00100010
00010001
00001000
11000001
11100000
11111000
01111110
00011111
NAME hallway 96

TIL lg
10100000
01010000
10001010
00000000
00000000
00000000
01000000
00100000
NAME hallway 97

TIL lh
00010000
00000010
00010000
00100000
00100000
00100001
00100010
00100100
NAME hallway 98

TIL li
11001000
01000000
11001000
11010001
11111010
11011100
11111110
10011101
NAME hallway 99

TIL lj
10101110
01010110
10101110
01010110
10101110
01010100
10101100
11011100
NAME hallway 100

TIL lk
00011100
00101100
00101100
00101100
00101100
01101100
01101100
01101100
NAME hallway 101

TIL ll
00000000
00000000
00000000
00000000
00010000
00101000
10100110
01000111
NAME hallway 102

TIL lm
00000010
00000001
00000011
00000000
00000000
01011111
00100000
01000000
NAME hallway 103

TIL ln
10000000
00000000
10000000
01000000
10000000
00000000
00000000
00000000
NAME hallway 104

TIL lo
00101000
00010101
00001010
00000101
00000000
00000000
00000000
00000000
NAME hallway 105

TIL lp
10000111
01010001
10101010
00010100
10001000
01000000
00000000
00000000
NAME hallway 106

TIL lq
11010000
11110000
11111000
01111111
00000111
00000001
00000010
00000101
NAME hallway 107

TIL lr
01101001
01110110
01101110
01011100
11111000
01010001
10101010
01000100
NAME hallway 108

TIL ls
00000111
00000001
10000010
00000001
10000000
00000100
00001010
00000001
NAME hallway 109

TIL lt
01101100
10011100
11101110
01011101
00101110
01010001
10101011
01010101
NAME hallway 110

TIL lu
00000000
00000000
00000000
10000000
01111000
10111000
01100110
10011101
NAME hallway 111

TIL lv
01111100
10111100
10111100
10111100
11111100
11111101
11111100
11111101
NAME hallway 112

TIL lw
00001000
10000100
00001010
00000101
00000010
00000101
00001010
00000100
NAME hallway 113

TIL lx
00100000
00010000
00101000
00010100
10000000
01000000
10100000
01100100
NAME hallway 114

TIL ly
10000000
00000000
00000000
00000000
00000000
00000000
00100000
00010000
NAME hallway 115

TIL lz
00000000
00000000
00000000
00000000
00000011
00000001
00000001
10000000
NAME hallway 116

TIL m0
00001111
00010000
00100000
01000000
10000000
10000000
11000000
11101000
NAME hallway 117

TIL m1
11101010
00010101
00101010
00000000
00000000
00000000
00000000
00000001
NAME hallway 118

TIL m2
10100000
01000001
00000001
00000001
00000101
00001010
00001000
10001000
NAME hallway 119

TIL m3
10001010
01000000
01000000
00000101
00000010
00000000
00000000
00000000
NAME hallway 120

TIL m4
00001011
00000101
00101010
00010001
00001000
00000000
00001000
00000100
NAME hallway 121

TIL m5
01000111
00110001
00001000
00000110
10000001
00010100
00001010
11100101
NAME hallway 122

TIL m6
11100000
10111000
01101110
00011011
10000110
01110001
00001110
01000001
NAME hallway 123

TIL m7
00000000
00000000
00000000
10000000
11000000
11110000
01111100
11010111
NAME hallway 124

TIL m8
01101100
11101101
11101100
11001100
01001110
01001100
01001100
10001001
NAME hallway 125

TIL m9
10000000
00000000
10000000
00000000
10000000
00000000
10000010
01000001
NAME hallway 126

TIL ma
00100010
01010111
10101011
01000101
00101000
00010100
00000010
00000000
NAME hallway 127

TIL mb
10111110
01010011
10101010
01110111
10011110
01000111
10000000
01000000
NAME hallway 128

TIL mc
00001000
00000000
00000000
00000000
10000000
11100000
10000000
00000000
NAME hallway 129

TIL md
00001100
00110000
00000000
00000000
00000000
00000000
00000000
00000000
NAME hallway 130

TIL me
01001100
01010010
00101001
00011100
00000111
00000001
00000001
00000000
NAME hallway 131

TIL mf
11010100
01110010
00111010
10011101
10000101
10000000
10000000
11000000
NAME hallway 132

TIL mg
00000010
00000010
11111100
01000000
10000000
10000000
00000000
00000000
NAME hallway 133

TIL mh
01110001
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME hallway 134

TIL mi
00000000
10000111
10000000
01100000
00011000
00000100
00000000
00000000
NAME hallway 135

TIL mj
00000000
10000000
01100000
00010000
00001000
00001000
00001000
00001000
NAME hallway 136

TIL mk
00110010
00010000
00001000
00001000
00001100
00001010
00010001
00100001
NAME hallway 137

TIL ml
10101000
00010100
00000010
00000000
00000000
00000000
00000000
00000000
NAME hallway 138

TIL mm
00111101
00010111
00001010
00000001
00000000
00000000
00100000
00110000
NAME hallway 139

TIL mn
10001010
11101001
10011000
11100100
00110011
00011100
10001011
01000100
NAME hallway 140

TIL mo
10000010
00000000
10000010
00000000
10000010
11000000
00100000
11011000
NAME hallway 141

TIL mp
00001001
00000110
00000000
00000000
00000000
00000000
00000000
00000000
NAME hallway 142

TIL mq
10000000
10010000
01001011
00100100
00011010
00000000
00000000
00000000
NAME hallway 143

TIL mr
01111010
10000001
00000010
00000001
00000000
01000000
00100000
00000100
NAME hallway 144

TIL ms
00100000
00000000
10100000
00010100
10001010
01000001
00100000
00000000
NAME hallway 145

TIL mt
00111110
00001101
10001011
01000100
00000000
01010000
00001000
00000000
NAME hallway 146

TIL mu
00000000
00000000
00001011
00010010
00000010
00001100
00111000
01010000
NAME cage up 1

TIL mv
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000101
NAME cage up 2

TIL mw
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01000001
NAME cage up 3

TIL mx
00101010
00110000
00101010
00011100
00101110
00010110
00101011
00010101
NAME cage up 4

TIL my
00000000
00000000
00000000
00000001
00000000
00000000
00000000
00000000
NAME cage up 5

TIL mz
10100000
00100000
00100000
00010000
10110000
01001100
00000010
00010101
NAME cage up 6

TIL n0
00000000
00000000
00000000
00000000
00000000
00000001
00000010
00000100
NAME cage up 7

TIL n1
00000000
00000000
00000000
00000000
00100000
00000100
10001101
01010111
NAME cage up 8

TIL n2
00000000
00000000
00000000
00000000
00000000
00000001
10101010
01010000
NAME cage up 9

TIL n3
00000000
00000000
00000010
00000100
00101010
01010100
00111000
01100000
NAME cage up 10

TIL n4
00000010
00000000
00000000
00000000
10000000
00000000
00000000
00000000
NAME cage up 11

TIL n5
10001000
01010000
00100000
00011111
00000000
00000000
00000000
00000000
NAME cage up 12

TIL n6
00001010
00000110
00000100
00000100
10001011
10000110
10111100
01000000
NAME cage up 13

TIL n7
00000000
00000000
00000000
00000100
00000011
00000000
00000000
00000000
NAME cage up 14

TIL n8
00000000
00000000
00000000
00000000
00000000
11000000
00111100
00000011
NAME cage up 15

TIL n9
00000011
00010001
00101011
00000101
00000000
00000000
00000000
11111100
NAME cage up 16

TIL na
00000100
00100100
11101100
10011010
10111010
00011010
00011010
00010001
NAME cage up 17

TIL nb
00000000
00000000
00000000
00000000
00000100
00001100
00001100
00001010
NAME cage up 18

TIL nc
00101000
01000101
00000011
00000101
00001001
00010011
00000010
00000010
NAME cage up 19

TIL nd
10101010
11110101
01101010
01010100
11101000
01010001
10000010
01010000
NAME cage up 20

TIL ne
10000001
00000000
10001000
00010000
10100000
01010000
00000000
00000000
NAME cage up 21

TIL nf
00111000
01111000
10000100
00000010
00000000
00000000
00000000
00000000
NAME cage up 22

TIL ng
00001010
00001011
00001010
00001011
00001001
00001001
00000111
00000101
NAME cage up 23

TIL nh
10000000
00000000
10000000
01000000
00000000
01000000
10000000
00000000
NAME cage up 24

TIL ni
00100010
00010100
00000000
00000101
00001010
00000000
10100000
01000000
NAME cage up 25

TIL nj
00100000
00000000
00001000
00111111
00001000
00001000
00001000
00001000
NAME cage up 26

TIL nk
00000000
00000000
11111111
11111111
00000000
00000000
00000000
00000000
NAME cage up 27

TIL nl
00000000
01111111
11111111
11111111
00000000
00000000
00000000
00000000
NAME cage up 28

TIL nm
00000000
10000011
11111111
11111111
00100100
00110100
00110100
00110100
NAME cage up 29

TIL nn
00000111
11111111
11111111
11111100
00011111
00000000
00000000
00000000
NAME cage up 30

TIL no
11111111
11111111
00000000
00000000
11111000
00000111
00000000
00000000
NAME cage up 31

TIL np
11111111
11110010
00001111
00000010
00000010
11101010
00011111
00001010
NAME cage up 32

TIL nq
11111111
00000000
11111111
00000001
00000000
00001111
11110000
00000000
NAME cage up 33

TIL nr
11111111
00000000
11111111
11111111
11110000
00000000
00000000
00000000
NAME cage up 34

TIL ns
11111111
00000000
11111111
11111111
00000000
00000000
00000000
00000000
NAME cage up 35

TIL nt
11111111
00011111
11100000
11111111
00100000
00100000
00100000
00110000
NAME cage up 36

TIL nu
11111110
11000000
00000000
10000000
00000000
00000000
00000000
00000000
NAME cage up 37

TIL nv
00001100
00001100
00001100
00001010
00001010
00001010
00001110
00001110
NAME cage up 38

TIL nw
00000110
00000001
00000010
00000001
00000010
00000001
00000000
00000000
NAME cage up 39

TIL nx
10000000
10010000
11100000
01010000
11000000
01010000
11000000
01010000
NAME cage up 40

TIL ny
10000000
00100000
00100000
00100000
00100000
00100000
00100000
00100000
NAME cage up 41

TIL nz
00001000
00001000
00001000
00001000
00001000
00001000
00001000
00001000
NAME cage up 42

TIL o0
00110100
00110100
00110100
00110100
00010100
00010100
00010100
00010100
NAME cage up 43

TIL o1
00001010
00000110
00000110
00000110
00000110
00000110
00000110
00000110
NAME cage up 44

TIL o2
01110000
01110000
01110000
01110000
01110000
01010000
01010000
01010000
NAME cage up 45

TIL o3
00001110
00001110
00000110
00000110
00000110
00000110
00000110
00000110
NAME cage up 46

TIL o4
00000010
00000001
00000010
00000100
00001011
00010001
00010010
00100100
NAME cage up 47

TIL o5
01000000
01000000
10100000
11000000
10000000
01000000
00000000
00000000
NAME cage up 48

TIL o6
00100000
00110010
10101100
00110100
00101100
01110100
00101100
00110100
NAME cage up 49

TIL o7
00001100
00001100
00001100
00001100
00001111
00001100
00001100
00001100
NAME cage up 50

TIL o8
00000000
00000000
00000000
00000000
11111111
11111111
00000000
00000000
NAME cage up 51

TIL o9
00000000
00000000
00000000
00000000
11111111
11100000
00000000
00000000
NAME cage up 52

TIL oa
00010100
00010100
00010100
00110100
11111111
01111111
00110100
00110100
NAME cage up 53

TIL ob
00000000
00000000
00000000
00000000
11111111
11000000
00000000
00000000
NAME cage up 54

TIL oc
00000000
00000000
00000000
01111111
10000000
00000000
00000000
00000000
NAME cage up 55

TIL od
00000110
00000110
00000110
11111111
00000110
00000110
00000110
00001110
NAME cage up 56

TIL oe
00000000
00000000
00000000
11111111
00000000
00000000
00000000
00000000
NAME cage up 57

TIL of
00000000
00000000
00111111
11000000
00000000
00000000
00000000
00000000
NAME cage up 58

TIL og
00000000
00000000
11111111
00111111
00000111
00000000
00000000
00000000
NAME cage up 59

TIL oh
01110000
00110000
00110000
11111110
11111111
00110001
00110000
00110000
NAME cage up 60

TIL oi
00000000
00000000
00000000
00000000
11000000
11111100
00000011
00000000
NAME cage up 61

TIL oj
00000110
00000110
00000110
00000110
00000110
00000110
11111110
00000110
NAME cage up 62

TIL ok
01001000
00110101
00101010
00100100
00000000
00000000
00000000
00000000
NAME cage up 63

TIL ol
10000000
00000000
00100000
00100000
00100000
00100000
01000000
01000000
NAME cage up 64

TIL om
00101000
00111100
00101000
00110100
00111000
00100101
00101000
00100111
NAME cage up 65

TIL on
00001100
00001100
00001100
00001100
10001100
00001100
10001100
00001100
NAME cage up 66

TIL oo
00110100
00110100
00110100
00110100
00110100
00110100
00110100
00110100
NAME cage up 67

TIL op
00000000
00000000
00000000
00000000
00000000
00000000
01000000
00000000
NAME cage up 68

TIL oq
00001110
00001110
00001110
00001100
00001100
00001100
00001100
00001100
NAME cage up 69

TIL or
00110000
00110000
00110000
00110000
00110000
00110000
00110000
00110000
NAME cage up 70

TIL os
00000100
00000100
00000100
00000100
00000100
00000100
00000100
00000100
NAME cage up 71

TIL ot
01000000
01000000
01000000
01000100
01001000
01000000
10000010
10010100
NAME cage up 72

TIL ou
00101010
00100111
00101011
00011111
00011011
00011011
00011001
00011001
NAME cage up 73

TIL ov
10001100
00001111
00001100
01001100
00001100
01001110
00001110
01001110
NAME cage up 74

TIL ow
00000000
11111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME cage up 75

TIL ox
00111111
11000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME cage up 76

TIL oy
11111111
00110100
01010100
01010100
01110100
01111100
01111100
01111100
NAME cage up 77

TIL oz
11111111
00001100
00001100
00001100
01001100
01001100
00101100
00101100
NAME cage up 78

TIL p0
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME cage up 79

TIL p1
11111111
00110000
00110000
00110000
00110000
00100000
00100000
00100000
NAME cage up 80

TIL p2
11111100
00000100
00000100
00000100
00000100
00001100
00001100
00001100
NAME cage up 81

TIL p3
00100010
00010000
00001010
00000100
00000011
00000101
00000011
00000101
NAME cage up 82

TIL p4
10100000
11000100
10000000
11000100
11001000
11000000
01001010
01000101
NAME cage up 83

TIL p5
00011001
00011101
00001101
00011101
10001010
01011100
10001000
01010100
NAME cage up 84

TIL p6
00101110
00001110
00001110
00001110
00001110
00001110
00001110
00001110
NAME cage up 85

TIL p7
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111
NAME cage up 86

TIL p8
01111100
01111100
01111100
01111100
01111100
01111100
01111100
11111111
NAME cage up 87

TIL p9
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111110
NAME cage up 88

TIL pa
00101100
00101100
00101100
00101100
00101100
00101100
00101100
00101100
NAME cage up 89

TIL pb
00100000
00100000
01100000
01100000
01000000
01000000
11000000
11000000
NAME cage up 90

TIL pc
00001100
00001100
00001100
00001100
00001100
00001100
00001100
00001100
NAME cage up 91

TIL pd
00000001
00000001
00000001
00000001
00000000
00000001
00000010
00000101
NAME cage up 92

TIL pe
10100000
11010001
10101010
01010000
10100000
01000100
10001000
00000000
NAME cage up 93

TIL pf
10001000
00010100
10101000
00000100
10101000
01111111
11111111
00011111
NAME cage up 94

TIL pg
00001111
00001100
00001100
00001101
00001100
11101100
11111110
11101101
NAME cage up 95

TIL ph
00001001
00111110
11000000
11111111
00000010
00000101
10101010
01000000
NAME cage up 96

TIL pi
11111111
00000000
00000000
11111000
10101111
01000000
10101010
01010101
NAME cage up 97

TIL pj
11111101
01111100
01111100
01110110
11111111
01111111
11111110
01110101
NAME cage up 98

TIL pk
11111111
00000000
00000000
00000000
11111111
11010101
10111111
01010101
NAME cage up 99

TIL pl
11111111
00011111
00000000
00000000
10101010
01111111
11101010
01010100
NAME cage up 100

TIL pm
11111111
11101100
00111111
00101100
10101110
11111101
10111110
00011100
NAME cage up 101

TIL pn
10000000
01111111
11111000
00000111
10101010
01010101
10101010
00010101
NAME cage up 102

TIL po
00000000
10000000
01111111
11111110
10000001
01010101
10101000
01010101
NAME cage up 103

TIL pp
00000001
00000001
11111101
00000011
11111111
01010100
10101010
01010101
NAME cage up 104

TIL pq
11000000
11000000
11000000
11111110
11111111
11000000
11101010
10000001
NAME cage up 105

TIL pr
00000000
00000000
00000000
00001111
11111111
00000000
00000000
01010101
NAME cage up 106

TIL ps
00001100
00001100
00001100
11111101
11111111
00001111
00001111
01001111
NAME cage up 107

TIL pt
00000010
00000101
00000000
11110001
11111111
11111111
11111101
11111111
NAME cage up 108

TIL pu
10100000
01000000
10000011
11111111
11111110
11111111
11111000
11111111
NAME cage up 109

TIL pv
11111111
00011111
11111111
11111100
01111111
00111111
11111100
11111111
NAME cage up 110

TIL pw
11111100
11011111
11111110
00011110
11111110
10011110
11110110
11111100
NAME cage up 111

TIL px
00001010
01011111
11111000
01000000
00101010
00010100
10000010
00000101
NAME cage up 112

TIL py
10101010
11111100
00000111
00000101
10101010
01010101
10100000
00000101
NAME cage up 113

TIL pz
11111100
00110100
11111110
01111111
10111110
01110100
00110110
01110101
NAME cage up 114

TIL q0
00000000
00000000
10101010
11111101
10101011
00000000
10101010
01010101
NAME cage up 115

TIL q1
10101010
01010101
10101010
01010101
11111111
01010101
00001010
01000000
NAME cage up 116

TIL q2
10111110
01011101
10111110
01011100
11111111
01011101
10001010
00001000
NAME cage up 117

TIL q3
10101000
01010101
10101010
01111111
11101010
00000000
00100000
01000001
NAME cage up 118

TIL q4
10101010
01010101
11111111
11010101
10101010
00000000
00101010
01100000
NAME cage up 119

TIL q5
10101011
11111101
10101010
01010000
10101010
01010101
10000000
00000000
NAME cage up 120

TIL q6
11111111
11010101
10101010
10000000
10101010
11010101
10000000
10001111
NAME cage up 121

TIL q7
11111110
01010101
00000000
01010100
10101010
01010111
01111010
10000001
NAME cage up 122

TIL q8
10101100
11111100
00001111
00011101
10111110
11000100
00000100
00010101
NAME cage up 123

TIL q9
01111111
11111111
11111111
11111110
00000000
11111111
10101000
00000001
NAME cage up 124

TIL qa
11111111
11111111
11111110
00000001
00111111
11111001
00000000
01111111
NAME cage up 125

TIL qb
11111110
11100111
00001100
00000111
01111111
00011111
00101111
11111100
NAME cage up 126

TIL qc
01100110
11111111
11111110
11111110
11111001
11100000
11111001
00111110
NAME cage up 127

TIL qd
10101010
01010101
10000111
00111000
11111111
00000000
11111111
00000101
NAME cage up 128

TIL qe
10101010
01010101
11111111
00000000
11111111
01010100
11111111
01010101
NAME cage up 129

TIL qf
10101100
01010101
11111111
00000000
11111111
00000000
11111111
01010101
NAME cage up 130

TIL qg
00000000
01010101
11111100
00000011
11111111
00010101
11111010
01010111
NAME cage up 131

TIL qh
00000010
01010100
00000000
11111111
11111111
01111111
10101000
11110101
NAME cage up 132

TIL qi
10101010
00010101
10100000
11111111
11111111
11111111
00000010
00011111
NAME cage up 133

TIL qj
10101000
01010101
00000000
11111111
11111110
11111111
10100000
11111111
NAME cage up 134

TIL qk
00011110
01010001
00001010
11000000
10111111
11111111
10111111
11110101
NAME cage up 135

TIL ql
10101111
11111101
10101011
00000001
11111111
11110101
11101010
01010101
NAME cage up 136

TIL qm
11111010
01010101
10101010
00000000
11111111
01011111
10101010
01010101
NAME cage up 137

TIL qn
10101010
01010100
10101010
00000000
11111111
11111111
10101010
01010101
NAME cage up 138

TIL qo
10000110
00000101
10111010
11100000
00000000
11111100
10101010
00000000
NAME cage up 139

TIL qp
10101010
01010000
10101010
00010101
00000010
00000000
00000000
00000000
NAME cage up 140

TIL qq
00001010
01010111
10111010
01010000
10000000
01000000
00001000
00000100
NAME cage up 141

TIL qr
11000001
00101111
00011000
00000101
10101010
01010000
00000000
00000000
NAME cage up 142

TIL qs
11011111
10000100
10101011
01010111
10101110
00011001
01111110
01010000
NAME cage up 143

TIL qt
11110010
00011111
11111010
11010001
00101111
11110001
10101111
01111100
NAME cage up 144

TIL qu
10101010
11111111
10101000
01110000
10011000
11111111
11111010
11010101
NAME cage up 145

TIL qv
10101111
11110101
00000000
00000000
00001010
01010101
10101000
01010101
NAME cage up 146

TIL qw
11111111
01010101
00000010
00000001
10101010
01010111
00001010
01010010
NAME cage up 147

TIL qx
11111111
01000000
10101000
01010101
10101010
11111111
10101111
00000000
NAME cage up 148

TIL qy
11111110
11011111
00110010
01010101
10101000
11100000
11111111
00000101
NAME cage up 149

TIL qz
10000111
01111111
11111111
11111111
00011110
11111111
11111111
00111111
NAME cage up 150

TIL r0
11111010
01100000
10101010
11000001
10101010
01010100
10000000
10000000
NAME cage up 151

TIL r1
10101010
01010100
10101010
00000101
10101010
01010101
00000010
00000000
NAME cage up 152

TIL r2
10101010
00000101
10101010
01010111
10111010
01010101
10000000
01010101
NAME cage up 153

TIL r3
10101010
01010001
11111111
11010101
00101010
01010101
00000011
01010101
NAME cage up 154

TIL r4
10101010
01000000
11101000
10000001
10101010
01010100
11111111
00000000
NAME cage up 155

TIL r5
00000000
00000000
00000000
01000000
10101000
01010101
10100000
00000100
NAME cage up 156

TIL r6
00000010
00000001
00000000
00000100
10100000
00000000
00000000
00000000
NAME cage up 157

TIL r7
00001010
01010000
10101010
00000000
00000000
00000000
00000010
00010101
NAME cage up 158

TIL r8
10101010
00010101
10100000
00000000
00000000
00010100
10101000
00000000
NAME cage up 159

TIL r9
10101011
01011100
00111111
01000000
10000000
00000000
00000000
00000000
NAME cage up 160

TIL ra
10101010
00000000
11000000
01100000
10000000
00000000
00000000
00000000
NAME cage up 161

TIL rb
00000000
11100000
00011110
00000001
00000000
00000000
00000000
00000000
NAME cage up 162

TIL rc
00001010
00000000
00000000
10000000
00000000
00000000
00000000
00000000
NAME cage up 163

TIL rd
11101010
00000000
00000000
00000000
00000000
00010101
00001000
00000000
NAME cage up 164

TIL re
10100000
00000101
00000000
00000001
00101010
00000000
00000000
00000000
NAME cage up 165

TIL rf
00000000
01000000
00000000
00000101
00000000
00000000
00000000
00000000
NAME cage up 166

TIL rg
10101000
00000000
10100000
01010101
10100000
00000000
00000000
00000000
NAME cage up 167

TIL rh
00101010
01010101
10101010
01010101
00000000
00000000
00000000
00000000
NAME cage up 168

TIL ri
10101010
00000000
10000000
01000000
00000000
00000000
00000000
00000000
NAME cage up 169

TIL rj
10101010
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME cage up 170

TIL rk
00000000
00000000
00000000
00000000
00000000
00000000
00100000
00100000
NAME bathroom 1

TIL rl
00000000
00001000
00001100
00001100
00001100
00001100
00001100
11111111
NAME bathroom 2

TIL rm
00000000
00000000
00000000
00000000
00000000
00000000
00000111
11111111
NAME bathroom 3

TIL rn
00000000
00000000
00000000
00000000
00000000
00000000
11111111
11111111
NAME bathroom 4

TIL ro
00000000
00000000
00000000
00000000
00000000
00000000
11110000
11111111
NAME bathroom 5

TIL rp
00000000
00000001
00000001
00000001
00000001
00000001
00000001
11110111
NAME bathroom 6

TIL rq
00000100
00000100
00000100
00000100
00100100
00100100
00100100
00100100
NAME bathroom 7

TIL rr
00100000
00100000
00100000
00100000
01100001
01100001
01100001
01010001
NAME bathroom 8

TIL rs
00000011
00011111
00000111
00000110
00000110
00000110
00000110
10000110
NAME bathroom 9

TIL rt
11111111
11111111
11111111
00001110
00001110
00001110
00001110
00001110
NAME bathroom 10

TIL ru
11111111
11111111
11100000
00000000
00000001
00000001
00000001
00000001
NAME bathroom 11

TIL rv
11111111
00000000
00000001
10000001
10000001
10000001
10000000
10000001
NAME bathroom 12

TIL rw
11111111
00000001
00000001
00000001
00000001
00000001
10000001
10000001
NAME bathroom 13

TIL rx
11111111
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME bathroom 14

TIL ry
11111111
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME bathroom 15

TIL rz
11111111
11111111
00000011
00000011
00000011
00000001
00000001
00000001
NAME bathroom 16

TIL s0
11100000
00000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME bathroom 17

TIL s1
00101000
00101000
00101000
00101000
00101000
00101000
00101000
00110000
NAME bathroom 18

TIL s2
01010001
01010001
01010001
01010001
01010001
01010001
01010001
01010001
NAME bathroom 19

TIL s3
10000110
10000110
10000100
10000110
10001100
10001100
10001100
10001100
NAME bathroom 20

TIL s4
00001110
00001110
00001110
00001110
00001110
00001101
00001111
00001111
NAME bathroom 21

TIL s5
00000001
00000001
00000001
00000001
00000000
00000000
00000001
00000011
NAME bathroom 22

TIL s6
10000001
10000001
10000001
10000001
10000001
10000001
11111111
11110001
NAME bathroom 23

TIL s7
10000001
10000001
10000001
10000000
10000000
11111110
11000011
10000000
NAME bathroom 24

TIL s8
00000001
00000001
00000001
00000001
00000011
00000011
00000011
00000011
NAME bathroom 25

TIL s9
00000000
00000000
00000000
00000000
00000000
00000110
00001100
00011100
NAME bathroom 26

TIL sa
00101001
00101001
00101001
00101001
00101001
00101001
00101001
00101001
NAME bathroom 27

TIL sb
10001100
00001100
00001100
00001100
00001100
10001100
00001100
00001100
NAME bathroom 28

TIL sc
00001111
00000111
00000111
00000111
00000111
01000111
00000111
00000111
NAME bathroom 29

TIL sd
11111100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bathroom 30

TIL se
10000001
11000001
10000001
00000001
00000001
00000001
00000000
00000000
NAME bathroom 31

TIL sf
10000000
10000000
10000000
10000000
10000000
10000000
11000000
11000000
NAME bathroom 32

TIL sg
00000011
00000011
00000011
00000011
00000011
00000011
00000011
00000011
NAME bathroom 33

TIL sh
10000000
10100000
10100000
10100000
10100000
10100000
10100001
10100001
NAME bathroom 34

TIL si
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000001
NAME bathroom 35

TIL sj
01010000
01010000
01110000
01100000
01100000
01100000
01100000
01100001
NAME bathroom 36

TIL sk
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01111110
NAME bathroom 37

TIL sl
00000000
00000000
00000000
00000000
00000000
00000001
00000011
00000010
NAME bathroom 38

TIL sm
00110100
00100110
01101110
11001100
10011100
10011010
00110010
00110100
NAME bathroom 39

TIL sn
00101001
00101001
00101001
00101001
00101001
00101001
00101001
00100101
NAME bathroom 40

TIL so
00000100
00000100
00000100
00000100
00000100
00000101
00000100
00000101
NAME bathroom 41

TIL sp
10000111
00000111
10100111
00000111
10100111
01000111
00000011
01000011
NAME bathroom 42

TIL sq
00000000
01000000
00100000
01010001
11111111
01010000
00101000
01000000
NAME bathroom 43

TIL sr
00000000
00000000
00000000
11111111
00001000
00000000
00000010
01010101
NAME bathroom 44

TIL ss
11000001
11000001
11000001
11111111
11111001
11100001
11100001
11000001
NAME bathroom 45

TIL st
00000000
00000000
00001000
00010100
00010100
00010100
00100100
00100100
NAME bathroom 46

TIL su
00000011
00000011
00000011
00000001
00000001
00000001
00000001
00000001
NAME bathroom 47

TIL sv
10100001
10100001
10100001
10100001
10100001
10100001
00100001
00100001
NAME bathroom 48

TIL sw
10000010
10000000
10000010
10000000
10000000
10000100
10000000
00000100
NAME bathroom 49

TIL sx
11100111
11101011
11101110
11101011
11101001
11101000
11101000
11101000
NAME bathroom 50

TIL sy
11000001
10000001
10000000
10000000
01000000
11100000
11110000
01110000
NAME bathroom 51

TIL sz
10000000
11000000
11100000
11100000
01100000
00110000
00010000
00011000
NAME bathroom 52

TIL t0
00000100
00000100
00001000
00000000
00000000
00000001
00000011
00000011
NAME bathroom 53

TIL t1
00100100
01101000
01111000
11010100
11110100
11101000
11101000
11010100
NAME bathroom 54

TIL t2
00100100
00100100
00100010
00100010
00100010
00100001
00000001
00000001
NAME bathroom 55

TIL t3
10000100
10000101
10000100
10000100
10000110
10000110
10000110
00000110
NAME bathroom 56

TIL t4
10000011
01000011
00001011
01000111
00001011
01010111
00101011
01010111
NAME bathroom 57

TIL t5
00110010
01000001
10000000
00000100
00000000
00000011
10011111
11111000
NAME bathroom 58

TIL t6
10101010
01010100
10100000
00000000
00000000
11111111
11111111
00000000
NAME bathroom 59

TIL t7
11000001
11000001
01000000
01000000
11111111
11111111
11111111
00000000
NAME bathroom 60

TIL t8
11000000
11000000
11000000
11000000
10000000
10000000
10000000
10000000
NAME bathroom 61

TIL t9
00100100
00100100
00100100
00100100
00100100
00100100
00101000
00101000
NAME bathroom 62

TIL ta
00100001
00100001
00100001
00100001
00100011
00100011
00100011
00100011
NAME bathroom 63

TIL tb
00000000
00000100
01000001
01000101
01000001
01000101
10000011
10000111
NAME bathroom 64

TIL tc
11101000
11111000
11111000
11101000
11101000
11101100
11101100
11101100
NAME bathroom 65

TIL td
00111000
00011000
00001100
00001110
00000110
00000011
00000011
00000001
NAME bathroom 66

TIL te
00001100
00001100
00001100
00001110
00001011
00001100
10001100
01111000
NAME bathroom 67

TIL tf
00000101
00000101
00001001
00001010
00010010
00010100
00000100
00001000
NAME bathroom 68

TIL tg
10010110
10011010
00100100
00000100
00000010
00000000
00000000
00000000
NAME bathroom 69

TIL th
00000110
00000110
00000110
00000100
00000100
00000100
00000100
00000100
NAME bathroom 70

TIL ti
00100110
00000110
00101100
00011100
00111001
00111000
01110000
01000001
NAME bathroom 71

TIL tj
10000000
00000000
00111111
01111111
11111100
01110001
11101010
11000000
NAME bathroom 72

TIL tk
00000000
00000000
11111111
11100000
10100000
01010101
10101010
00010101
NAME bathroom 73

TIL tl
00000000
00000000
11111111
00010100
10101000
00000100
10101000
00010100
NAME bathroom 74

TIL tm
00101000
00101000
00101000
00101000
00101000
00101000
00100100
00100100
NAME bathroom 75

TIL tn
00100011
00100011
10100101
10100101
11100101
01100101
00100101
01100101
NAME bathroom 76

TIL to
10000011
10011111
10011011
10011111
10011011
11011111
10011011
11011111
NAME bathroom 77

TIL tp
11101100
11111100
11101100
11111100
11101100
11111100
11101100
11111100
NAME bathroom 78

TIL tq
00000000
00001000
00010000
00001000
01101000
11010100
10000000
10000000
NAME bathroom 79

TIL tr
00111010
00111010
00110111
00101111
00101111
00101111
00111111
00111111
NAME bathroom 80

TIL ts
00010000
00010000
00100000
01000000
01000000
10000000
00000000
00000001
NAME bathroom 81

TIL tt
00000100
00000100
00000101
00000010
00000011
00000011
00000011
00000011
NAME bathroom 82

TIL tu
11000001
10000001
00000011
11111111
00000000
00000000
00000000
00000000
NAME bathroom 83

TIL tv
10000000
00000000
00000011
11111100
00000000
00000000
00000000
00000000
NAME bathroom 84

TIL tw
00100010
01010111
11111100
00000000
00000000
00000000
00000000
00000000
NAME bathroom 85

TIL tx
10101001
11111110
00000000
00000000
00000000
00000000
00000000
00000000
NAME bathroom 86

TIL ty
10000001
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME bathroom 87

TIL tz
00100100
11000100
11000100
11000100
10000100
00000100
00000100
00000100
NAME bathroom 88

TIL u0
01100101
01100101
01100101
01100101
01100111
01100111
01100111
01110111
NAME bathroom 89

TIL u1
10101010
11111100
10101110
11111100
10101010
11111100
01100010
01000100
NAME bathroom 90

TIL u2
11101001
11111101
11111110
11111110
11101100
11111100
11101111
01011011
NAME bathroom 91

TIL u3
00111111
00111111
00111111
00101111
00111111
01101111
01101111
11101111
NAME bathroom 92

TIL u4
00000011
00000011
00000110
00001100
00001100
00011000
00010000
00110000
NAME bathroom 93

TIL u5
11100000
11111101
00111111
00001111
00001101
00011101
00111001
00110001
NAME bathroom 94

TIL u6
00000000
00000000
00000000
00000000
10000000
10000000
10000011
11000100
NAME bathroom 95

TIL u7
00000011
00000011
00000011
00101101
01111111
11111111
01110111
11111111
NAME bathroom 96

TIL u8
10000000
10000000
10000000
10000000
10000000
10011111
11111111
11000000
NAME bathroom 97

TIL u9
00000000
00000000
00000000
00000000
11111100
11111111
00110011
11111100
NAME bathroom 98

TIL ua
00000000
00000000
00000000
00000000
11111111
11111110
11111111
00000000
NAME bathroom 99

TIL ub
00000000
00000000
00000000
00000000
11111111
11111111
11111111
00000000
NAME bathroom 100

TIL uc
10000000
10000000
10000000
10000000
11000000
11000000
11000000
00100000
NAME bathroom 101

TIL ud
00000100
00000100
00000100
00000000
00000000
00000000
00000000
01000100
NAME bathroom 102

TIL ue
00000000
00000000
00100000
00000000
00000000
00000000
00000000
00110000
NAME bathroom 103

TIL uf
01101111
01101111
01101110
01101100
01101000
01100101
01000111
11111111
NAME bathroom 104

TIL ug
00100010
01000000
10000000
00000000
00111111
11111110
11100000
10000000
NAME bathroom 105

TIL uh
01000001
01010000
01000000
11110000
10100000
11010000
01110000
00110000
NAME bathroom 106

TIL ui
11000000
11100000
01100000
00110000
00010000
00011000
00001100
00001110
NAME bathroom 107

TIL uj
11101111
11111110
11111111
11111111
11111111
11111110
11011111
11011111
NAME bathroom 108

TIL uk
01100000
11000000
11000001
10111001
10011101
10000111
10000101
10101001
NAME bathroom 109

TIL ul
01100001
11100001
11000011
10000011
00000111
00001110
00001100
00001100
NAME bathroom 110

TIL um
11000101
11111001
11111110
10011111
00100011
00000000
00000000
00000000
NAME bathroom 111

TIL un
11110111
11101100
00101100
11011000
11111000
00111100
00110110
00001011
NAME bathroom 112

TIL uo
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00100000
NAME bathroom 113

TIL up
00000000
00000000
00000001
00000001
00000011
00000101
00000101
00001010
NAME bathroom 114

TIL uq
00000000
00000000
00000000
10000000
00000000
00000000
00000000
00000000
NAME bathroom 115

TIL ur
00100000
00011111
00000000
00000000
00000000
00000000
00000000
00000000
NAME bathroom 116

TIL us
01001011
11111111
00111000
00000000
00000000
00000000
00000000
00000000
NAME bathroom 117

TIL ut
11111001
11001111
00010100
00010000
00010000
00011000
00011000
00011001
NAME bathroom 118

TIL uu
11110100
11010100
01011010
01001010
10100110
01100111
01100011
00110001
NAME bathroom 119

TIL uv
00000000
00000000
00000001
10000011
11000110
01000111
01001100
00001100
NAME bathroom 120

TIL uw
00011000
00001100
11101110
00110111
00011011
00011011
11001001
01100101
NAME bathroom 121

TIL ux
00000111
00000110
00000011
00000011
00000001
10000000
01000000
11000000
NAME bathroom 122

TIL uy
11011110
11111010
11111100
11110010
10000000
10000000
00000000
00000000
NAME bathroom 123

TIL uz
10100101
10101011
01010001
01000001
01000001
01100001
00100001
00100000
NAME bathroom 124

TIL v0
00011100
00011100
00011000
00111000
01111000
10111000
11101000
11101000
NAME bathroom 125

TIL v1
00000000
00000000
00000000
00000000
00000000
00000000
00001000
00000000
NAME bathroom 126

TIL v2
00000101
00000010
00000001
00000001
00000000
00000000
00000001
00000110
NAME bathroom 127

TIL v3
10000000
11000000
11111111
01100001
11100000
10100000
00110011
01010001
NAME bathroom 128

TIL v4
01000000
01000000
11100000
11000000
01000000
11000000
10110111
11111100
NAME bathroom 129

TIL v5
00001010
00011010
00011010
00010101
00110100
11111001
00111111
01011001
NAME bathroom 130

TIL v6
00000000
00000000
10000000
00000000
10000000
00000000
10000000
11110000
NAME bathroom 131

TIL v7
00000000
00000000
01000111
01111101
01111111
01000000
01100000
01100000
NAME bathroom 132

TIL v8
00000000
00000000
11111111
11111001
11111110
00000000
00000000
00000000
NAME bathroom 133

TIL v9
00001001
00001001
11101100
00001100
00001100
00001100
00001100
00001100
NAME bathroom 134

TIL va
01110001
01011000
11011100
11001100
01000110
01000110
01100011
01100001
NAME bathroom 135

TIL vb
00000100
10000100
10000010
01000110
01100001
00111000
00101000
00011010
NAME bathroom 136

TIL vc
00010110
00011011
00001111
00000111
00000011
11000011
00111101
00000111
NAME bathroom 137

TIL vd
11100000
01100000
00110000
00111000
10011100
10001100
10000110
01000111
NAME bathroom 138

TIL ve
00100000
00111100
00011111
00000011
00000001
00000001
00000001
00000000
NAME bathroom 139

TIL vf
11101100
11001111
11000011
10000011
00000000
10000000
11000000
11000000
NAME bathroom 140

TIL vg
00000000
00000000
10000000
01111101
11110110
00001111
00000000
00000000
NAME bathroom 141

TIL vh
00000001
00000001
00000111
11111010
11111100
00000001
00000001
00000001
NAME bathroom 142

TIL vi
10110000
01100000
11100000
11000000
11000000
10000000
10000000
00000000
NAME bathroom 143

TIL vj
00001000
00000000
00000000
00000000
00111111
00000001
00000001
00000011
NAME bathroom 144

TIL vk
01110000
10110001
10110010
11010000
11111110
01100111
11111000
11010000
NAME bathroom 145

TIL vl
00000000
01000000
00000000
00000000
10100000
11110000
10101000
00010101
NAME bathroom 146

TIL vm
01100000
01100000
00100000
00100000
00110000
00010000
00010000
00011000
NAME bathroom 147

TIL vn
00000000
10000000
01000000
00100000
00100000
00010000
00001000
10001111
NAME bathroom 148

TIL vo
00001110
00001110
00000110
00000011
00000011
00000011
00010001
11101101
NAME bathroom 149

TIL vp
00110001
00011000
00001100
00001110
00000110
00000111
10000011
10000011
NAME bathroom 150

TIL vq
10001111
10000111
11000010
01100011
00110001
00010000
00010000
10001100
NAME bathroom 151

TIL vr
00000000
10000000
10000000
11000000
11100000
11110000
11111001
01111000
NAME bathroom 152

TIL vs
00000011
00000001
00000001
00000000
00000000
00000001
11111110
01000000
NAME bathroom 153

TIL vt
00000000
00000000
10000000
10000000
11000000
11000000
10100000
10000000
NAME bathroom 154

TIL vu
00000000
00000001
00000001
00000000
00000000
00000000
00000001
00000011
NAME bathroom 155

TIL vv
11100010
01010011
01000000
10000000
01100000
10011111
00111111
01111001
NAME bathroom 156

TIL vw
00000000
00000000
00000000
00000000
01111111
11000000
00111111
11111111
NAME bathroom 157

TIL vx
00000011
00000101
00001010
00110100
11000100
00010100
00101000
11000000
NAME bathroom 158

TIL vy
00000101
00001001
00011111
00000001
00000011
00000011
00000101
00000110
NAME bathroom 159

TIL vz
11101010
10010001
11100000
00010000
10110000
01000000
10100000
01000100
NAME bathroom 160

TIL w0
10001010
01010001
10101010
00010100
00000010
00000000
00000000
00000000
NAME bathroom 161

TIL w1
00011011
00001111
10001100
00001100
10001100
00001100
00001110
00000101
NAME bathroom 162

TIL w2
01001110
00110010
11110000
00110000
00110000
10010000
10111111
11100001
NAME bathroom 163

TIL w3
11110010
11001101
11000011
11000001
11000001
11000001
11000010
00111100
NAME bathroom 164

TIL w4
10000001
10000001
11000000
01000000
01100000
00100000
00100000
00110000
NAME bathroom 165

TIL w5
10001101
11001111
11101100
01101100
01111100
00111100
00011100
00011110
NAME bathroom 166

TIL w6
01100100
10000000
00000000
00000100
00000010
00000000
00000010
00000000
NAME bathroom 167

TIL w7
00000000
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME bathroom 168

TIL w8
11000000
11000100
11001100
11001100
10001100
10001100
10001100
10001100
NAME bathroom 169

TIL w9
00000111
00101011
01010011
10010111
10100111
10101111
11001111
10011111
NAME bathroom 170

TIL wa
11111000
11110100
11100000
11100010
11000010
11000000
10000000
10000000
NAME bathroom 171

TIL wb
00000000
00000000
00000000
00000000
00000000
00000000
00000010
00000101
NAME bathroom 172

TIL wc
11000000
00110000
00001010
00000100
00011000
00001111
10000000
00000000
NAME bathroom 173

TIL wd
00000110
00000111
00000100
00000001
00000000
11111000
00010000
00100000
NAME bathroom 174

TIL we
10100000
01000000
10000000
00000000
10101010
01010101
10001010
00000001
NAME bathroom 175

TIL wf
00000000
00000000
00000000
00000000
00000000
00000000
10101000
01010000
NAME bathroom 176

TIL wg
00000110
00000110
00000010
00000010
00000010
00000011
00000001
00000001
NAME bathroom 177

TIL wh
00000001
00000010
00000100
00000100
00001110
00011000
00000000
00000000
NAME bathroom 178

TIL wi
00110000
00110000
00111000
00011000
00011000
00011000
00001100
00000100
NAME bathroom 179

TIL wj
00001110
00001111
00000110
00000110
00000111
00000011
00000001
00000110
NAME bathroom 180

TIL wk
00000000
00000000
00000000
00000000
00000110
01000100
10011111
11111100
NAME bathroom 181

TIL wl
00000001
00000001
01000101
00011111
01111100
11110111
11010011
00011011
NAME bathroom 182

TIL wm
01001100
01001100
01001100
01011100
10111100
00111100
11111100
11111100
NAME bathroom 183

TIL wn
00011111
00111110
00111110
01111100
11111100
11111000
01111000
01010000
NAME bathroom 184

TIL wo
00001000
00001001
00010010
00110101
01110010
01100100
11101010
01110100
NAME bathroom 185

TIL wp
10000000
01000000
00000000
00000000
10000000
00000000
10001000
01000000
NAME bathroom 186

TIL wq
01000000
10000000
10000000
01111100
00000010
00000010
00000010
00000010
NAME bathroom 187

TIL wr
00000000
00000000
00111111
00000111
00000000
00000000
00000000
00000000
NAME bathroom 188

TIL ws
00000000
00000000
11111000
11111111
01111110
00000000
00000000
00000000
NAME bathroom 189

TIL wt
00000100
00000010
00000000
11111000
00000000
00000000
00000000
00000000
NAME bathroom 190

TIL wu
11010000
00000000
00000000
00000000
00000000
00000000
00101000
01000000
NAME bathroom 191

TIL wv
00001001
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bathroom 192

TIL ww
10111100
11110110
11011110
01101111
00101111
00110110
00010010
00001011
NAME bathroom 193

TIL wx
01100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bathroom 194

TIL wy
00000000
00000000
00000000
00010101
10100000
00000000
00000000
00000000
NAME bathroom 195

TIL wz
00000000
00000000
10101010
01010101
00001010
00000101
00000000
00000000
NAME bathroom 196

TIL x0
00001000
01010101
10001010
01010100
10100000
00000000
00000000
00000000
NAME bathroom 197

TIL x1
00101010
01010101
10111111
00001100
00010000
00000101
00000000
00000000
NAME bathroom 198

TIL x2
00101010
01011111
11111010
01000001
10001010
01000000
00000000
00000000
NAME bathroom 199

TIL x3
10101000
01010000
10000000
00000000
00000000
00000000
00000000
00000000
NAME bathroom 200

TIL x4
00000101
00000101
00000000
00000000
00000000
00000000
00000000
00000000
NAME bathroom 201

TIL x5
00000000
00010100
00101000
00010000
00100010
00000101
10001010
01000101
NAME bathroomclose 1

TIL x6
00000000
01010000
10100000
00000000
10000000
01000000
10000000
01000101
NAME bathroomclose 2

TIL x7
10001010
00010000
00100000
00000101
00000000
00000000
00000000
00000000
NAME bathroomclose 3

TIL x8
10001010
01000101
10000010
00000101
00001000
00000001
00000010
00000000
NAME bathroomclose 4

TIL x9
10100010
01000000
10000000
00000100
10000000
00000000
00000000
00000000
NAME bathroomclose 5

TIL xa
00101000
00000000
00101000
00000100
00000000
00000100
00000000
00000100
NAME bathroomclose 6

TIL xb
00101000
01000000
00101000
01000100
00101000
01000100
00101000
01000000
NAME bathroomclose 7

TIL xc
00000000
00000001
00111111
00101111
00100000
00100000
00100000
00110000
NAME bathroomclose 8

TIL xd
00000000
11111111
11100000
11111000
00000111
00000000
00000000
00000000
NAME bathroomclose 9

TIL xe
00001110
11110111
00000001
00000000
11000000
00000000
00000000
00111111
NAME bathroomclose 10

TIL xf
00000001
11111110
11111111
00000000
00000000
00000000
11111111
10000000
NAME bathroomclose 11

TIL xg
11111111
00111111
11111111
00000000
00000000
00000000
11111111
00000000
NAME bathroomclose 12

TIL xh
11110000
11111111
11111111
00000001
00000000
00000000
00000000
11111111
NAME bathroomclose 13

TIL xi
00000000
00000000
11111111
11111000
00000000
00000000
00000000
11100000
NAME bathroomclose 14

TIL xj
00000000
00000000
00000000
11100100
00001100
00001100
00001100
00001100
NAME bathroomclose 15

TIL xk
00000000
00000101
00000000
00000101
00000000
00000000
00000000
00000000
NAME bathroomclose 16

TIL xl
00000000
00000001
00001000
00000101
10001010
00000100
10001010
00000100
NAME bathroomclose 17

TIL xm
00101000
01000000
10101000
01010000
10101000
01000000
10001000
01000000
NAME bathroomclose 18

TIL xn
00110000
00110000
00110000
00110000
00110000
00110000
00110000
01110000
NAME bathroomclose 19

TIL xo
00001111
00111000
11000000
10000000
10000000
10000000
10000000
10000000
NAME bathroomclose 20

TIL xp
00000000
00000000
00000010
00000100
00001000
00010000
01100000
10000000
NAME bathroomclose 21

TIL xq
00011100
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME bathroomclose 22

TIL xr
00010000
00010000
00100000
00100000
00100000
00000000
00000000
00000000
NAME bathroomclose 23

TIL xs
10001010
01000100
10001000
01000000
10101000
01000000
10101000
01000000
NAME bathroomclose 24

TIL xt
10001000
00000000
10001000
00000000
00001000
00000000
00000000
00000000
NAME bathroomclose 25

TIL xu
00000000
00000000
00000000
00000011
00001111
00011100
00011000
00101011
NAME bathroomclose 26

TIL xv
00000000
00000000
01111100
11101111
10000001
00111000
01100110
11000011
NAME bathroomclose 27

TIL xw
00000000
00000000
00000000
00000000
10000000
11000000
01100000
00110000
NAME bathroomclose 28

TIL xx
01110000
01110000
01110000
01110000
01110000
01110000
01110000
01110000
NAME bathroomclose 29

TIL xy
10000000
10000000
10000000
10000000
10000000
10001000
10001100
10001100
NAME bathroomclose 30

TIL xz
00000000
00000001
00000010
00000100
00001000
00000000
00000000
00000000
NAME bathroomclose 31

TIL y0
10000011
00000100
00000100
00001000
00110000
01000000
10000010
00000000
NAME bathroomclose 32

TIL y1
00000001
00000001
00000001
00010010
00010010
00010010
00010010
00010010
NAME bathroomclose 33

TIL y2
00001100
00001000
00001000
00001000
00001000
00001000
00001000
00011000
NAME bathroomclose 34

TIL y3
00101000
01000000
00100000
00010000
00000000
00000000
00000000
00000000
NAME bathroomclose 35

TIL y4
00111010
00110010
00010010
00011011
00011111
00001110
00000111
00000111
NAME bathroomclose 36

TIL y5
00000001
00000000
00000000
00000011
11001100
00111001
00001110
11111111
NAME bathroomclose 37

TIL y6
10110000
10110000
10110000
01100000
11100000
10000000
00000000
10000000
NAME bathroomclose 38

TIL y7
01110000
01110000
00110000
00110000
00110000
00110000
00110000
00110000
NAME bathroomclose 39

TIL y8
10001100
10000100
10000100
10001010
10001010
10001010
11001011
01001001
NAME bathroomclose 40

TIL y9
00000000
01000000
10000000
10000000
10000000
10000000
00000000
00000000
NAME bathroomclose 41

TIL ya
00010010
00010010
00010010
00010010
00010010
00010010
00000010
00000010
NAME bathroomclose 42

TIL yb
00011000
00011000
00011000
00011000
00011000
00011000
00011000
00111000
NAME bathroomclose 43

TIL yc
10000000
10000000
10000000
10000000
10000000
00000000
00000000
00000000
NAME bathroomclose 44

TIL yd
00001000
00000000
00001000
00000000
00001000
00000100
00000000
00000000
NAME bathroomclose 45

TIL ye
00000111
00000100
00000100
00000100
00001100
00001000
00001000
00001000
NAME bathroomclose 46

TIL yf
11111001
00000000
00000000
00000000
00001000
00000000
00001000
00110100
NAME bathroomclose 47

TIL yg
10000000
10000000
10000000
11000000
11000000
11000000
11000000
11000000
NAME bathroomclose 48

TIL yh
01001001
01001000
01001000
01001000
01001000
01001000
01001000
01000000
NAME bathroomclose 49

TIL yi
01000000
01000000
00100000
00110000
00110000
00111000
00111000
00011000
NAME bathroomclose 50

TIL yj
00001100
00001000
00010000
00110000
00100000
01100000
01100000
01100000
NAME bathroomclose 51

TIL yk
00000100
00000100
00100100
00100100
00100100
00100100
01000100
01000100
NAME bathroomclose 52

TIL yl
00111000
00111000
00111000
00111000
00111000
00111000
00111000
00110000
NAME bathroomclose 53

TIL ym
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00001001
NAME bathroomclose 54

TIL yn
00000000
00000000
00101001
00000010
00101010
00010010
00101010
01010010
NAME bathroomclose 55

TIL yo
00000000
00000000
00000000
00000000
00000000
00001000
00001000
00001000
NAME bathroomclose 56

TIL yp
00001000
00001000
00001000
00011000
00011000
00011000
00011000
00011000
NAME bathroomclose 57

TIL yq
00111000
00110100
00101000
00101101
00101010
00111100
00101010
00110101
NAME bathroomclose 58

TIL yr
11000000
11100000
11100000
01100000
01100000
01100000
01000000
01000000
NAME bathroomclose 59

TIL ys
00111100
00111100
00111100
00111100
00011000
00011100
00011100
00011100
NAME bathroomclose 60

TIL yt
00000000
00000000
00000001
00000001
00000000
00000000
00000000
00000000
NAME bathroomclose 61

TIL yu
00000000
00000011
00001111
10011100
11111000
00000000
00000000
00000000
NAME bathroomclose 62

TIL yv
11111100
11001100
10001100
00010101
00001001
00000100
00000111
00000011
NAME bathroomclose 63

TIL yw
01100000
01000000
10000000
01100000
01111000
01001100
11000100
10000010
NAME bathroomclose 64

TIL yx
01000100
01000100
00000100
00000100
00000100
00000100
00000100
00000100
NAME bathroomclose 65

TIL yy
00001001
00011001
00011001
00011001
00011001
00011001
00100101
00100101
NAME bathroomclose 66

TIL yz
00001010
01010110
00001001
01010001
10101001
01010001
10101000
01010000
NAME bathroomclose 67

TIL z0
00001000
00001000
00001000
00001000
00000100
00000100
00000101
00000101
NAME bathroomclose 68

TIL z1
00000000
00000000
10000000
10000000
10000000
10000000
00000000
00000000
NAME bathroomclose 69

TIL z2
00001000
00001000
00001000
00001000
00001001
00011001
00010000
00010000
NAME bathroomclose 70

TIL z3
00101110
00110101
00101100
10110100
00101110
00110101
11001110
11010101
NAME bathroomclose 71

TIL z4
01000000
01100000
10100000
00100000
10100000
01100000
10100000
01100000
NAME bathroomclose 72

TIL z5
00011100
00001100
00001100
00001100
00001100
00001100
00001100
00001100
NAME bathroomclose 73

TIL z6
00000001
00000111
00011111
01110000
00000000
00000000
00000000
11111111
NAME bathroomclose 74

TIL z7
10000010
10000011
01000001
00000001
00000000
00000000
00000000
11111110
NAME bathroomclose 75

TIL z8
00000100
00000100
10000100
11000100
11000100
11100100
01110100
01111100
NAME bathroomclose 76

TIL z9
00110000
00111000
00111000
00110000
00110000
00100000
00100000
00100000
NAME bathroomclose 77

TIL za
00100101
00100101
00100101
00100101
00100101
00100101
00100011
00000000
NAME bathroomclose 78

TIL zb
00101000
01010000
00100000
00010000
00100000
00000000
00000000
00000000
NAME bathroomclose 79

TIL zc
00000101
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME bathroomclose 80

TIL zd
00010000
00010000
00010000
00010000
00100111
00111001
00111111
00100011
NAME bathroomclose 81

TIL ze
00000110
00000101
00000110
00000101
00000110
10000001
11111111
11000001
NAME bathroomclose 82

TIL zf
00100000
01100000
00100000
01100000
10100000
00100000
00100000
10110000
NAME bathroomclose 83

TIL zg
00001100
00001100
00001110
00001100
00001100
00001111
00000000
00000000
NAME bathroomclose 84

TIL zh
00111111
00000000
00000000
00000000
00011110
11111111
00000010
00000100
NAME bathroomclose 85

TIL zi
10000000
00000000
00000000
00000000
00000010
11111111
10111111
00000101
NAME bathroomclose 86

TIL zj
00000000
00000000
00000000
00000101
11111110
01011111
11111111
01010000
NAME bathroomclose 87

TIL zk
00000000
00000000
10101010
01010101
10101010
11111111
11111111
00000000
NAME bathroomclose 88

TIL zl
00000001
00000000
10100000
01000000
10100000
11111111
11000000
00000000
NAME bathroomclose 89

TIL zm
11111111
00100000
00000000
00000000
00000111
11111111
00000000
00000000
NAME bathroomclose 90

TIL zn
00100000
00010000
00110000
00010000
10000000
11100000
00000000
00000000
NAME bathroomclose 91

TIL zo
01000001
01100001
01100001
01010001
01010001
01010001
10010001
10010001
NAME bathroomclose 92

TIL zp
00100000
00000000
00100000
00000000
00100000
00010000
10100000
00010000
NAME bathroomclose 93

TIL zq
00000000
00000000
00000000
00000000
00000001
00000011
00001110
00001111
NAME bathroomclose 94

TIL zr
00000000
00000000
00000000
01111111
11110000
10000000
00000001
00001110
NAME bathroomclose 95

TIL zs
00000000
00000000
00000000
11100000
01100000
11100000
10100000
00100000
NAME bathroomclose 96

TIL zt
00000000
00000000
00000000
00000000
00000011
00000111
00011000
00110000
NAME bathroomclose 97

TIL zu
00000000
00000000
00000000
00000000
00000000
11100000
01110000
00111010
NAME bathroomclose 98

TIL zv
00000000
00000010
00000010
00000010
00000001
00000001
00000000
00000000
NAME bathroomclose 99

TIL zw
10010001
10011011
10101010
10001101
10101100
01000101
10100000
01000100
NAME bathroomclose 100

TIL zx
10100000
00010000
10101000
00010000
00101000
01010000
00101000
01000000
NAME bathroomclose 101

TIL zy
00000000
00000000
00000110
00001010
00001010
00010001
01010001
01010001
NAME bathroomclose 102

TIL zz
00000000
00000000
00000001
00000111
00011100
00001000
00011000
00110000
NAME bathroomclose 103

TIL 10a
00000100
00000100
00000100
00000101
00000010
00000111
00000010
00000111
NAME bathroomclose 114

TIL 10b
11010001
01010001
10100001
01110000
10101000
00010000
10101000
01010000
NAME bathroomclose 115

TIL 10c
00000000
01000000
10000000
10000000
00000001
00000011
00000010
00000111
NAME bathroomclose 116

TIL 10d
01100000
01100000
11000000
11000000
11000000
10000000
10000000
00000000
NAME bathroomclose 117

TIL 10e
00011000
00011001
00001110
00001101
00011111
00000111
00000000
00000000
NAME bathroomclose 118

TIL 10f
10101010
01010101
10101011
01011110
11111101
11111011
00000111
00001100
NAME bathroomclose 119

TIL 10g
11100000
11000000
00001100
00111110
11110111
11011001
11100011
00000000
NAME bathroomclose 120

TIL 10h
10001000
10000000
10000011
10011111
11111110
11110110
00111111
00000111
NAME bathroomclose 121

TIL 10i
00000001
00000001
11100001
11111111
00011111
00111111
11111110
11110000
NAME bathroomclose 122

TIL 10j
11111110
10000111
10000000
00000000
00000000
00000000
00000000
00000000
NAME bathroomclose 123

TIL 10k
00000000
10000000
11111100
00011111
00000011
00000000
00000000
01010101
NAME bathroomclose 124

TIL 10l
00000000
00000000
00000000
00000000
10000000
11000000
00110000
00001000
NAME bathroomclose 125

TIL 10m
00000011
00000001
00000001
00000001
00000000
00000000
00000000
00000000
NAME bathroomclose 126

TIL 10n
10000000
11000000
01000000
11000000
10100000
11100000
11100000
11110000
NAME bathroomclose 127

TIL 10o
00000000
01000101
00101000
00010101
10101010
00010000
10101000
00010000
NAME bathroomclose 128

TIL 10p
10101000
00010000
00100000
00010000
00000000
00000000
00000000
00000000
NAME bathroomclose 129

TIL 10q
00000101
00001010
00001010
00011100
00001100
00001000
00011110
00011100
NAME bathroomclose 130

TIL 10r
00000000
00000000
00000000
00000011
00000111
00001110
00001110
00011011
NAME bathroomclose 131

TIL 10s
00111000
01110000
11000000
10010101
00101000
01000101
00101011
11001111
NAME bathroomclose 132

TIL 10t
00000010
00000101
00101010
01010111
10111111
11111111
11101000
10000000
NAME bathroomclose 133

TIL 10u
00000000
00010000
10001111
11111111
11111000
00000000
00000000
00000000
NAME bathroomclose 134

TIL 10v
00000000
00000001
11111111
11111111
00000000
00000000
00000000
00000000
NAME bathroomclose 135

TIL 10w
00101010
11111101
00101111
11111111
00000111
00000000
00000000
00000000
NAME bathroomclose 136

TIL 10x
10000000
01010001
11111010
11101111
11111111
00011111
00000011
00000000
NAME bathroomclose 137

TIL 10y
00100100
01000010
00000011
00000000
11110000
01111001
11001111
11111100
NAME bathroomclose 138

TIL 10z
00000000
01000000
11000000
00000000
01000000
10000000
00000000
00000000
NAME bathroomclose 139

TIL 11a
00001111
00001111
11111100
00000000
00000000
11111111
11111110
11111111
NAME bathroomclose 150

TIL 11b
11111110
10000000
00000000
00000000
01111111
11111100
00000111
11110001
NAME bathroomclose 151

TIL 11c
00000000
00000000
00111000
11100000
11111110
00000001
11111111
10000000
NAME bathroomclose 152

TIL 11d
00001100
00000100
00000110
00001110
00000111
11111111
11111111
11111111
NAME bathroomclose 153

TIL 11e
00000000
00000000
00000000
00000000
00000000
10000000
11000000
00000000
NAME bathroomclose 154

TIL 11f
00000001
00000001
00000000
00000001
00000011
00000001
00000001
00000000
NAME bathroomclose 155

TIL 11g
11000001
10011110
10001010
10010101
11101010
11010101
11001010
11010001
NAME bathroomclose 156

TIL 11h
11111111
01010101
10101010
01010101
10001010
01010101
00101010
01010000
NAME bathroomclose 157

TIL 11i
11111111
01010101
10100000
00000000
10101000
01010000
00000000
00000000
NAME bathroomclose 158

TIL 11j
00000000
01111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME bathroomclose 159

TIL 11k
11111111
00000101
00000000
00000000
00000000
00000000
00000000
00000000
NAME bathroomclose 160

TIL 11l
11111111
01010101
00001010
00000000
00000000
00000001
00000010
00000001
NAME bathroomclose 161

TIL 11m
11111111
01011111
10101010
01010101
00001010
01000000
00000000
01010101
NAME bathroomclose 162

TIL 11n
11111111
11111111
10000000
01010100
10100000
00000000
00000000
01010101
NAME bathroomclose 163

TIL 11o
11111111
00001110
00001110
00001110
00001110
00011110
00011110
01011110
NAME bathroomclose 164

TIL 11p
00000000
00010100
00101000
00010000
00100010
00000001
00000010
00000111
NAME bathroomopen 1

TIL 11q
00000111
00000111
00000110
00001111
00001110
00001110
00001110
00001110
NAME bathroomopen 2

TIL 11r
10001010
11110101
11111111
00001101
00000000
00000000
00000000
00000000
NAME bathroomopen 3

TIL 11s
10100010
01000000
11000000
01100100
11111110
00110111
00001001
00000000
NAME bathroomopen 4

TIL 11t
00001101
00001111
00001111
00001111
00001111
00001111
00001111
00001111
NAME bathroomopen 5

TIL 11u
00001111
00000000
00000111
00011111
00000000
01111111
11110000
00000111
NAME bathroomopen 6

TIL 11v
00000000
10000000
11111000
00000100
11111111
00000001
00111110
11000000
NAME bathroomopen 7

TIL 11w
00111100
00000111
00000001
00000000
10000000
11100000
00000000
00000001
NAME bathroomopen 8

TIL 11x
00000000
00000001
11111111
01101111
01101110
11111101
11111110
11111101
NAME bathroomopen 9

TIL 11y
00000000
11111111
11101010
11111101
10101111
01010101
10100000
01000000
NAME bathroomopen 10

TIL 11z
00001110
11110111
00101011
01010101
11101010
01010101
00000000
00000000
NAME bathroomopen 11

TIL 12a
00001100
00001100
00011100
00011100
00011100
00011100
00011100
00111100
NAME bathroomopen 22

TIL 12b
00011110
00011111
00011110
00011110
00011110
00011110
00011110
00011110
NAME bathroomopen 23

TIL 12c
00111111
11110000
00000000
00000000
00011111
01110000
00000011
00111111
NAME bathroomopen 24

TIL 12d
11111111
00000000
00000111
11111000
11111111
00000011
11111100
10000111
NAME bathroomopen 25

TIL 12e
11111111
01100010
10000100
01111111
10011101
11100101
11000101
11100101
NAME bathroomopen 26

TIL 12f
11111000
11111001
11111000
01111101
01101010
01111101
01111111
01111111
NAME bathroomopen 27

TIL 12g
10000000
01000000
10000000
00000000
00101010
00000001
10101000
11111111
NAME bathroomopen 28

TIL 12h
00000000
00000000
00000000
00000000
00000000
01010100
00100000
11111111
NAME bathroomopen 29

TIL 12i
00000000
00000000
00000000
00000000
00000000
00000000
10100000
11111111
NAME bathroomopen 30

TIL 12j
00000000
00000000
00000000
00000000
00000000
00000000
00011111
11111111
NAME bathroomopen 31

TIL 12k
00000000
00000000
00000010
00000011
00010011
00001111
11111111
11111111
NAME bathroomopen 32

TIL 12l
10111100
11111000
11111000
01111000
01111000
01111000
11111000
11111100
NAME bathroomopen 33

TIL 12m
00011110
00011110
00011110
00011110
00011110
00011110
00011110
00011110
NAME bathroomopen 34

TIL 12n
00000111
00111111
11110000
00000011
01111111
11000001
00001111
00010101
NAME bathroomopen 35

TIL 12o
11111011
00011100
01100000
11111111
00000111
01111111
10101000
01010011
NAME bathroomopen 36

TIL 12p
10000111
00000110
01111110
11111110
11111110
11101110
10101110
01101111
NAME bathroomopen 37

TIL 12q
11111111
11111100
11111010
11011101
11011000
11010000
11010000
11010000
NAME bathroomopen 38

TIL 12r
11111111
11111111
00001010
01010101
00101000
00000000
00000000
00000000
NAME bathroomopen 39

TIL 12s
11111111
11110101
10101010
00000001
00001010
00010000
00000000
00000000
NAME bathroomopen 40

TIL 12t
11111111
01110101
10101010
00010101
10001010
00000000
00000000
00000000
NAME bathroomopen 41

TIL 12u
11111111
11111111
10101010
01010101
00101010
00000000
00000000
00000000
NAME bathroomopen 42

TIL 12v
11111111
11111111
10101010
01000111
00101010
00000000
00000000
00000000
NAME bathroomopen 43

TIL 12w
11111111
11111101
10111111
11110101
10101010
00000000
00000000
00000000
NAME bathroomopen 44

TIL 12x
00111100
11111000
11111000
01011000
00011000
00011000
00011000
00011000
NAME bathroomopen 45

TIL 12y
00011110
00011110
00011110
00011110
00011110
00011111
00011110
00011010
NAME bathroomopen 46

TIL 12z
00000000
00010101
00101011
01011110
10101111
00011100
00100001
01001111
NAME bathroomopen 47

TIL 13a
00000000
00000000
00000000
00000000
10101000
01010000
11111110
11111111
NAME bathroomopen 58

TIL 13b
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111000
NAME bathroomopen 59

TIL 13c
00010000
00010000
00010000
00010000
00010000
00010000
00010000
00110000
NAME bathroomopen 60

TIL 13d
00011110
00011110
00011110
00011110
00011110
00011100
00011100
00011100
NAME bathroomopen 61

TIL 13e
00000000
00000011
00000110
00000000
00000001
00000010
00000011
00000000
NAME bathroomopen 62

TIL 13f
01111110
11100111
00001111
00111110
11110000
11000001
00011110
01100111
NAME bathroomopen 63

TIL 13g
11100111
00010111
00100111
00010101
00111111
11110111
11100011
01111111
NAME bathroomopen 64

TIL 13h
11111111
11111111
11101010
11110101
11101010
11100000
11100010
11100101
NAME bathroomopen 65

TIL 13i
11001111
11111100
10000000
00000000
00100000
01000001
00000010
01010101
NAME bathroomopen 66

TIL 13j
11111111
00000000
00000000
00000000
00000000
01010101
00000000
01000001
NAME bathroomopen 67

TIL 13k
11111111
00000000
00000000
00000000
00000000
01010000
00101010
01010000
NAME bathroomopen 68

TIL 13l
11111111
00111111
00000000
00000000
00000000
01010101
10000000
01010101
NAME bathroomopen 69

TIL 13m
11111111
11111111
00000000
00000000
00000000
01000000
00100000
01010101
NAME bathroomopen 70

TIL 13n
11111111
11111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME bathroomopen 71

TIL 13o
11110000
11111000
00111000
00110000
00110000
00100000
00100000
00100000
NAME bathroomopen 72

TIL 13p
00001100
00001100
00001100
00001100
00001101
00001101
00001110
00001100
NAME bathroomopen 73

TIL 13q
00000000
00000001
00000111
00111111
11001111
11111111
00111111
11111111
NAME bathroomopen 74

TIL 13r
10111011
11011111
11111101
11011111
11111111
11111101
11000111
00111111
NAME bathroomopen 75

TIL 13s
11111011
00011101
11111111
11111100
11110010
11100001
11111110
10000000
NAME bathroomopen 76

TIL 13t
11101010
11110101
11100000
00100001
00101000
11111111
01111111
00000000
NAME bathroomopen 77

TIL 13u
10101010
00000101
00001010
01010101
10111110
11111111
11000010
00000100
NAME bathroomopen 78

TIL 13v
10101010
01010101
10101010
01010101
10101010
11111111
10111111
00000101
NAME bathroomopen 79

TIL 13w
00001010
01000000
10101010
01010101
00000000
01011111
11111111
01010000
NAME bathroomopen 80

TIL 13x
10000010
01010101
10101010
00000000
10101010
11111111
11111111
01010101
NAME bathroomopen 81

TIL 13y
10000010
01010101
00000010
01010100
10100000
11111111
11000010
01010100
NAME bathroomopen 82

TIL 13z
00000001
01000000
10100000
00000000
00000111
11111111
10101010
00000000
NAME bathroomopen 83

TIL 14a
00000000
00011111
11100000
00000000
00000000
00011111
11100000
00000000
NAME livingleft 7

TIL 14b
00000000
10000000
01111100
00000100
00000100
10000100
01100110
00100110
NAME livingleft 8

TIL 14c
11100011
11111111
10000000
10000000
10000000
10000001
10000010
10000100
NAME livingleft 9

TIL 14d
11111111
11111111
00101000
01010001
10000010
00000101
00101010
01010100
NAME livingleft 10

TIL 14e
11111111
11111111
10000000
00000000
10000000
00000000
00000000
00000001
NAME livingleft 11

TIL 14f
11111111
11111111
00000010
00000100
00000000
01000000
10000000
00000000
NAME livingleft 12

TIL 14g
11111111
11111111
10001000
00010000
00000000
00000000
00000010
00000100
NAME livingleft 13

TIL 14h
11111111
11111111
00000000
00010000
00100000
00010001
00100010
01000100
NAME livingleft 14

TIL 14i
00001111
11111100
00000000
00010000
00101000
00010000
00100000
01000000
NAME livingleft 15

TIL 14j
00110000
00001101
00001111
00001110
00001101
00000101
00000101
00000100
NAME livingleft 16

TIL 14k
10000000
10000000
00000000
00001111
00111111
00000000
00000000
10000000
NAME livingleft 17

TIL 14l
00000000
00000000
01111100
11111111
11111100
00000000
00000000
11111111
NAME livingleft 18

TIL 14m
00000000
00000000
00000000
11111100
01111111
10000000
00000000
00000000
NAME livingleft 19

TIL 14n
00101110
00101110
01000110
01000110
11000110
01000110
01000110
01100110
NAME livingleft 20

TIL 14o
10001000
10010001
10101000
11000001
10000010
10000000
11000000
11000001
NAME livingleft 21

TIL 14p
10101000
01010100
10101000
01000000
10001000
01010001
10101010
01010000
NAME livingleft 22

TIL 14q
00000010
00000000
00000000
01000100
10001000
00010000
00100000
01000000
NAME livingleft 23

TIL 14r
00000000
00000001
00000010
00000100
00001000
00000100
00001000
00010000
NAME livingleft 24

TIL 14s
10001000
00010000
00000000
00000000
00000000
00000000
00001000
00010000
NAME livingleft 25

TIL 14t
00001000
00010001
00100000
00000000
00000000
00000001
00001010
00010100
NAME livingleft 26

TIL 14u
10000000
00000000
00001010
00010100
00000000
00000000
00001000
00010000
NAME livingleft 27

TIL 14v
00000100
00000101
00000101
00000101
00000101
00000100
00000100
00000100
NAME livingleft 28

TIL 14w
10000000
00000011
00000001
00000000
00000000
11111110
10001111
11111100
NAME livingleft 29

TIL 14x
11111111
01111101
10000000
00000000
00000111
00000000
00000000
00000000
NAME livingleft 30

TIL 14y
11000000
11111000
00111000
01111000
10000000
00000000
00000000
00000000
NAME livingleft 31

TIL 14z
00100110
00100100
00100110
00101101
01111000
01011000
00100000
01000000
NAME livingleft 32

TIL 15a
11101111
00110000
11111111
00000000
00000000
00000000
00000000
00000000
NAME livingleft 43

TIL 15b
11111111
00000000
11111111
00000010
00000010
00000100
00000111
00000000
NAME livingleft 44

TIL 15c
10000001
10000001
00000110
00000110
00001100
00001000
10111000
11110000
NAME livingleft 45

TIL 15d
10000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME livingleft 46

TIL 15e
10101000
10100000
10101000
10100001
10100000
11100000
11100000
11100100
NAME livingleft 47

TIL 15f
00000000
01000001
10001010
00010101
00101010
01000001
10000010
01000001
NAME livingleft 48

TIL 15g
10101010
01010100
10101000
01010000
10100000
01000001
10000010
00000100
NAME livingleft 49

TIL 15h
00001000
00010000
00100000
01000001
10000010
00000100
00001000
00010000
NAME livingleft 50

TIL 15i
00001000
00010000
10000000
00000000
00000010
00000100
00001000
01010000
NAME livingleft 51

TIL 15j
00000010
00000100
00001000
00000000
00000000
00000000
00000000
00000000
NAME livingleft 52

TIL 15k
00000000
00000000
00001000
00010000
00000010
00000100
00001010
01000000
NAME livingleft 53

TIL 15l
00000000
00000000
00000000
00000000
00000000
00000001
00000011
00000110
NAME livingleft 54

TIL 15m
00000000
00000011
00000111
00111000
01100000
11000000
10000000
00000000
NAME livingleft 55

TIL 15n
01111111
10000111
10001111
00000000
00000000
00000000
00000000
00000000
NAME livingleft 56

TIL 15o
11011000
11101100
11011110
00000011
00000001
00000001
00000000
00000000
NAME livingleft 57

TIL 15p
00000000
00000000
10000000
11000000
11000000
11100000
11100000
10110000
NAME livingleft 58

TIL 15q
00000000
00000000
00000000
00000000
00000000
00000000
00000100
01011111
NAME livingleft 59

TIL 15r
00000001
00000001
00000001
00000000
00000000
00000000
00000000
00000000
NAME livingleft 60

TIL 15s
11101010
11000101
11011111
11111111
11111000
11100000
11100010
11100001
NAME livingleft 61

TIL 15t
10000010
01000111
11111111
11111111
10100000
01010001
10100010
00000101
NAME livingleft 62

TIL 15u
00001000
00010000
11111111
11111111
10001010
00010101
10101010
01010100
NAME livingleft 63

TIL 15v
00100000
11111111
11111111
10000111
10101000
00010101
00100010
01000000
NAME livingleft 64

TIL 15w
10000000
00000000
11111111
10000101
10001010
00010101
00001010
00010100
NAME livingleft 65

TIL 15x
00100000
01000001
11111001
00111111
00100110
00010100
00100010
01010100
NAME livingleft 66

TIL 15y
10000000
01000100
11111111
11111111
00000000
00010001
00100000
00000001
NAME livingleft 67

TIL 15z
00011100
00011000
00111000
01110000
01100000
11000000
10000000
00000000
NAME livingleft 68

TIL 16a
10101000
01010000
10111111
01011111
11111111
01001111
00100010
01000100
NAME livingleft 79

TIL 16b
00001010
01010101
11111010
11111111
11111000
11111100
00100000
01010001
NAME livingleft 80

TIL 16c
00000000
00000000
00000000
00000001
00000011
00000010
00000110
00000110
NAME livingleft 81

TIL 16d
00000001
00000011
00000010
00000100
00000000
00000000
00000000
00000000
NAME livingleft 82

TIL 16e
00000111
00001110
00111100
00110000
01111100
01100000
11000000
10001101
NAME livingleft 83

TIL 16f
00001110
00001110
00011110
00011110
00110111
00110111
00100111
01100101
NAME livingleft 84

TIL 16g
11101010
11100001
11101010
11100100
11101010
11110100
11100000
11100111
NAME livingleft 85

TIL 16h
10001000
00010100
00101000
01010000
10100000
01000001
00000010
11111100
NAME livingleft 86

TIL 16i
00101010
01010100
10100000
01000101
10000010
00000100
00001000
00000111
NAME livingleft 87

TIL 16j
00100001
01000001
10000011
00000101
00001000
00010000
00100000
01000001
NAME livingleft 88

TIL 16k
10101000
01010101
10101000
11010001
10100010
11000000
10000000
01000101
NAME livingleft 89

TIL 16l
10000000
01000101
10001010
00000101
00001010
01000001
10000010
00010100
NAME livingleft 90

TIL 16m
10100010
01000000
10100000
01000100
10001000
00010000
00100000
01000000
NAME livingleft 91

TIL 16n
00000000
00000000
00000000
00000000
00000000
01000000
00000000
00000000
NAME livingleft 92

TIL 16o
10000110
01100110
00011100
00001110
00001000
00011000
00010000
00000000
NAME livingleft 93

TIL 16p
00000011
00000110
00011110
00111100
01110100
11101000
11000000
10000000
NAME livingleft 94

TIL 16q
00011111
00011111
00000000
00000000
00000000
00000000
00000000
00000000
NAME livingleft 95

TIL 16r
11111100
11111100
00000000
00000001
00000001
00000001
00000011
00000010
NAME livingleft 96

TIL 16s
01000101
11000111
10000111
10000111
10000111
00000111
00000011
00000010
NAME livingleft 97

TIL 16t
00000000
00000000
00000011
01111111
00000000
01111111
01111000
00000000
NAME livingleft 98

TIL 16u
00000000
00000000
11111000
11100111
00011111
11111111
00001111
00000000
NAME livingleft 99

TIL 16v
11111000
11100000
11100000
11100001
10011111
11111111
11111111
00000000
NAME livingleft 100

TIL 16w
00001100
00011111
01100111
11111110
11111111
11111111
11111111
00000011
NAME livingleft 101

TIL 16x
11111100
00111100
11101000
00010000
11100001
11111111
11111111
11111000
NAME livingleft 102

TIL 16y
10000010
01000010
10000010
00000010
11111111
11111111
11111111
00000001
NAME livingleft 103

TIL 16z
10000010
00010100
00001000
00010000
11111100
11111111
11111110
11111111
NAME livingleft 104

TIL 17a
00001110
00011011
00111100
00110000
01110000
11100000
11000000
11000000
NAME livingleft 115

TIL 17b
11001111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME livingleft 116

TIL 17c
11100000
00011111
00001000
00000110
00000001
00000000
00000000
00000000
NAME livingleft 117

TIL 17d
00001111
00000001
10000000
01000000
11100000
00010000
00011100
00001010
NAME livingleft 118

TIL 17e
00000000
11000000
00000000
00000001
00000001
00000010
00000110
00000100
NAME livingleft 119

TIL 17f
01000000
11000000
10000000
10000000
00000000
00000001
00000001
00000011
NAME livingleft 120

TIL 17g
00101010
01110100
01101010
11000100
10100010
11000101
01101010
11010000
NAME livingleft 121

TIL 17h
10001000
01000100
10101000
01010000
00100000
00010000
00100000
00000000
NAME livingleft 122

TIL 17i
00000000
00000000
00000000
00000001
00000000
00010100
10101010
00000000
NAME livingleft 123

TIL 17j
00000000
00000000
00001010
01000000
10101010
00000000
10101000
00000000
NAME livingleft 124

TIL 17k
00000000
00000000
10100000
01000000
00000000
00000000
00000000
00000000
NAME livingleft 125

TIL 17l
10000000
10000000
10000000
10000000
10000000
10000000
10000001
10000001
NAME livingleft 126

TIL 17m
00000000
00000000
00000000
00011110
01110111
11100011
11100011
11011011
NAME livingleft 127

TIL 17n
00000000
00000000
00000000
00000000
00000000
00000000
00111110
11111111
NAME livingleft 128

TIL 17o
00001010
00000101
00000011
00000001
00000001
00000000
00000000
10100001
NAME livingleft 129

TIL 17p
00001100
00001000
00001000
00010000
10100000
11000000
11000000
10000001
NAME livingleft 130

TIL 17q
00000110
00000111
00111110
00100101
01101010
11111111
11111100
01110101
NAME livingleft 131

TIL 17r
10101000
00010000
00000000
00000000
10000000
01000000
10000000
00000000
NAME livingleft 132

TIL 17s
00000000
01000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME livingleft 133

TIL 17t
00000000
00000000
10101010
00000000
00000000
00000000
00000000
00000000
NAME livingleft 134

TIL 17u
00000000
00010101
10100000
00000000
00000010
00000000
00000000
00000000
NAME livingleft 135

TIL 17v
00000010
01010100
00000000
00010101
10101010
00000000
00000000
00000000
NAME livingleft 136

TIL 17w
10101010
00000000
00001010
01010000
10101010
00000000
00000000
00000000
NAME livingleft 137

TIL 17x
10000000
01010101
10101000
00000000
10100000
00010000
00000000
00000100
NAME livingleft 138

TIL 17y
00000000
01000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME livingleft 139

TIL 17z
10000001
11000001
11010000
01001000
00001100
00000100
00000011
00000001
NAME livingleft 140

TIL 18a
00001000
00010000
00100000
00000000
00000000
00000000
00000000
00000000
NAME livingleft 151

TIL 18b
00000101
00000011
00000101
00001011
00000011
00000110
00000110
00000011
NAME livingleft 152

TIL 18c
01111000
00000111
01000001
11000010
01110100
10100100
11101100
11001000
NAME livingleft 153

TIL 18d
00010000
00001111
11111111
00000000
00000000
00100000
01000000
01000100
NAME livingleft 154

TIL 18e
00111110
11100000
11111111
00000000
00000000
00010001
00100010
00100010
NAME livingleft 155

TIL 18f
01110110
11101100
01101100
11011000
10101000
00110000
01100000
01000000
NAME livingleft 156

TIL 18g
00000000
00010000
00100100
00100000
00100000
00100001
00100000
01010101
NAME livingleft 157

TIL 18h
00100000
01000000
00100000
00000000
10000010
11000000
10101010
10010100
NAME livingleft 158

TIL 18i
00000010
01010000
00000000
00000000
00000000
00000000
00000000
00000000
NAME livingleft 159

TIL 18j
10101010
00000000
00000000
00000000
00001010
01010101
00000000
00000000
NAME livingleft 160

TIL 18k
10101000
00000000
00000010
01010000
10000000
01010101
00000000
00000000
NAME livingleft 161

TIL 18l
00000010
01010100
00000000
00000000
00000000
01010101
00000000
00000000
NAME livingleft 162

TIL 18m
00000000
00000000
00000000
00000000
00000000
01010000
00000010
00000000
NAME livingleft 163

TIL 18n
00000000
00000000
00000000
00000000
00001000
01000000
00000000
00000000
NAME livingleft 164

TIL 18o
00000001
00000000
00000000
00000001
00000001
00000001
00000000
00000000
NAME livingleft 165

TIL 18p
11010000
10110000
10100001
01100001
01000010
11000100
00001000
00001001
NAME livingleft 166

TIL 18q
10001000
10010000
00010001
00100011
01000101
10000110
10001011
00010111
NAME livingleft 167

TIL 18r
01100100
11100101
11001010
01001011
10111100
11010000
11101010
00010100
NAME livingleft 168

TIL 18s
11101010
01010101
00100000
00000001
00001011
01010111
10000100
00000100
NAME livingleft 169

TIL 18t
11100000
10000101
10001001
01010101
10101010
00000011
00100100
00000101
NAME livingleft 170

TIL 18u
10100010
10000000
00000000
00000100
10000000
00000000
00000000
01010100
NAME livingleft 171

TIL 18v
00000000
00000000
00000000
00010101
00000010
00010100
10100010
01010101
NAME livingleft 172

TIL 18w
00000000
00000000
00101010
00010101
10100000
00000000
10101010
01000000
NAME livingleft 173

TIL 18x
00000000
00000000
10100000
00000000
00000000
01010101
10000000
00000000
NAME livingleft 174

TIL 18y
00000000
00000000
00000000
00000000
00001010
01010101
00000000
00000000
NAME livingleft 175

TIL 18z
00010010
00100100
01000000
10000101
00101010
01010100
10000000
00000000
NAME livingleft 176

TIL 19a
00000000
01010101
10000000
01010101
10101010
00000000
00000000
00000000
NAME livingleft 187

TIL 19b
00000000
01010101
00000000
01010101
10101010
00000000
00000000
00000000
NAME livingleft 188

TIL 19c
00000000
00000000
00000000
00000000
10100000
00000000
00000000
00000000
NAME livingleft 189

TIL 19d
00000000
00000000
00000000
00000000
00000000
00010000
00101000
00010001
NAME kitchen 1

TIL 19e
00000000
00000000
00000000
00000000
00000000
00000000
00100000
00000101
NAME kitchen 2

TIL 19f
00000000
00000000
00000000
00000000
00000000
00000101
00101000
01000000
NAME kitchen 3

TIL 19g
00101000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 4

TIL 19h
00001000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 5

TIL 19i
00000000
00000000
00000000
00000000
00000000
00111111
00111111
01110101
NAME kitchen 6

TIL 19j
00000000
00000000
00000000
00000000
00000001
11111111
11111111
01010100
NAME kitchen 7

TIL 19k
00000000
00000000
00000000
00000000
11111111
11111100
11000000
00000000
NAME kitchen 8

TIL 19l
00000000
00000000
00000000
00011110
11111110
00000001
00000000
00000000
NAME kitchen 9

TIL 19m
00000000
00000000
00000000
00000000
00000000
11101000
00010101
00000101
NAME kitchen 10

TIL 19n
00000000
00000011
00001111
00000000
00000000
00000000
00000000
00000000
NAME kitchen 11

TIL 19o
11111111
00011111
11110000
10000000
11000000
11000000
11000000
11000011
NAME kitchen 12

TIL 19p
11111111
11111111
00000000
00000000
00000000
00000000
11000000
00100011
NAME kitchen 13

TIL 19q
11111111
11111111
00000000
00000000
00000000
00000000
11110000
00001000
NAME kitchen 14

TIL 19r
10000100
11111110
00000100
00000100
00000110
00001110
00001110
00000111
NAME kitchen 15

TIL 19s
00000000
00000000
00000000
00000000
00000000
00000100
00000000
00000101
NAME kitchen 16

TIL 19t
00101010
01010101
10100000
00010000
00000000
00000000
00000000
00000000
NAME kitchen 17

TIL 19u
00000101
00000101
00000011
00000011
00000011
00000011
00000011
00100011
NAME kitchen 18

TIL 19v
00000000
00000100
00000000
00000100
00000000
00000100
00000010
00000000
NAME kitchen 19

TIL 19w
00000000
00000000
00000000
00000000
00000000
01000000
10000000
01000000
NAME kitchen 20

TIL 19x
11101100
11110000
11000000
11000101
11101010
11110101
11101010
11110111
NAME kitchen 21

TIL 19y
00010100
00001000
00000000
00000000
10100000
01010001
10101010
11111111
NAME kitchen 22

TIL 19z
00000100
00000100
10000100
00000100
10100011
01010101
10101010
11111111
NAME kitchen 23

TIL 1a0
00000000
00000000
00000000
00000000
11111111
01010011
10101100
11110000
NAME kitchen 24

TIL 1a1
00000111
00000110
00000110
00000110
00000110
10000110
00000110
00000110
NAME kitchen 25

TIL 1a2
00001010
00000101
00001010
00000000
00000000
00000000
00000000
00000000
NAME kitchen 26

TIL 1a3
00000000
11110100
10101111
00000101
10100000
00000000
00000000
00000000
NAME kitchen 27

TIL 1a4
00000000
11000000
00100000
01010000
00000000
00000000
00000000
00000000
NAME kitchen 28

TIL 1a5
00000001
00000011
00000011
00000001
00000001
00000001
00000001
00000001
NAME kitchen 29

TIL 1a6
11100011
01110001
11110001
11110001
11110001
11110001
11110001
11110001
NAME kitchen 30

TIL 1a7
00000010
00000001
00000000
00000001
00000000
00000001
00000000
00000000
NAME kitchen 31

TIL 1a8
10000000
01000000
00000000
01000000
00000000
01000000
00000000
01000000
NAME kitchen 32

TIL 1a9
11111110
11100000
11100000
01100000
01100000
01100000
01100000
00100000
NAME kitchen 33

TIL 1aa
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00000010
NAME kitchen 34

TIL 1ab
00000110
00000110
00000110
00000110
00000110
00000010
11111111
00000000
NAME kitchen 35

TIL 1ac
00000000
00000000
00000000
00000000
00000000
00000000
11111111
00000111
NAME kitchen 36

TIL 1ad
00000000
00000000
00000000
00000000
00000000
00000000
11110011
11111111
NAME kitchen 37

TIL 1ae
00000000
00000000
00000000
00000000
00000000
00000000
11111111
11111000
NAME kitchen 38

TIL 1af
11110001
11110001
11110001
11110001
11110001
11110001
11110001
11110001
NAME kitchen 39

TIL 1ag
10000000
01000000
10000000
01000000
00000000
00000000
00000000
00000000
NAME kitchen 40

TIL 1ah
00100000
00101111
11110000
11111111
00000111
00000000
00000000
00000000
NAME kitchen 41

TIL 1ai
00001111
11110000
00000000
10000001
11111111
01000101
00101010
00000000
NAME kitchen 42

TIL 1aj
11111111
00000000
00000000
01010000
11111111
01010101
10000000
01010101
NAME kitchen 43

TIL 1ak
11111111
00001110
01111010
11100011
11100011
01000011
00100011
01000011
NAME kitchen 44

TIL 1al
00000000
00000000
00000000
00111111
01000000
01000000
01000000
01000111
NAME kitchen 45

TIL 1am
00000000
00000000
00001111
11110001
00001110
00100000
11000000
10000000
NAME kitchen 46

TIL 1an
00000000
00000000
11000000
11100000
00110000
00010000
00010000
00011000
NAME kitchen 47

TIL 1ao
00100000
00100000
00100000
00110000
00110000
00110000
00110000
00110000
NAME kitchen 48

TIL 1ap
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00011111
NAME kitchen 49

TIL 1aq
00000000
00000000
00000000
00000000
00000000
00000000
11111100
11100000
NAME kitchen 50

TIL 1ar
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000010
NAME kitchen 51

TIL 1as
00000011
00000011
00000011
00000010
11111111
11111111
11100010
00000001
NAME kitchen 52

TIL 1at
11110001
11110001
11110001
11110001
11110101
11111001
11110101
11111001
NAME kitchen 53

TIL 1au
10000000
10000000
10000000
10000000
10000000
10000000
10000011
11111111
NAME kitchen 54

TIL 1av
00000000
00000000
00000000
00000000
00000000
00000000
11111111
11111101
NAME kitchen 55

TIL 1aw
00000000
00000000
00000000
00000000
00000000
00000000
11100000
11111111
NAME kitchen 56

TIL 1ax
00000000
00000000
00000000
00000000
00000000
00000000
00000001
11111110
NAME kitchen 57

TIL 1ay
00000011
00000011
00000011
00000011
00000011
00000011
11111011
00000011
NAME kitchen 58

TIL 1az
00111001
00100111
00100000
00100000
00100000
00101000
00111101
00110010
NAME kitchen 59

TIL 1b0
01110000
10001000
00011000
00000110
00000001
00000000
10000000
01111111
NAME kitchen 60

TIL 1b1
00011000
00011000
00011000
00011000
00011000
00011000
00011000
11111000
NAME kitchen 61

TIL 1b2
00000000
00000101
00001010
00000000
00000000
00000001
00000000
00000001
NAME kitchen 62

TIL 1b3
00000000
01010100
10001010
01010000
10000000
00010000
10100000
01000000
NAME kitchen 63

TIL 1b4
10000001
00010001
00000011
00000001
00000001
00000001
00000001
00000001
NAME kitchen 64

TIL 1b5
11110001
11110001
11110001
11110001
11110001
11110001
11110001
11110000
NAME kitchen 65

TIL 1b6
10111111
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME kitchen 66

TIL 1b7
00000011
00001111
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 67

TIL 1b8
11111111
00000000
00000000
00000000
00000000
00000001
00000010
00000101
NAME kitchen 68

TIL 1b9
11111111
00000000
00001010
01010000
00101010
01010100
00100000
11111101
NAME kitchen 69

TIL 1ba
11111011
10000010
10000111
10000000
11000000
11000000
11000000
11000000
NAME kitchen 70

TIL 1bb
00000000
00000000
11111111
11111111
00101010
00000000
00000000
00000000
NAME kitchen 71

TIL 1bc
00000000
00000000
00000010
11111111
10111111
00000101
00000010
00000000
NAME kitchen 72

TIL 1bd
00000000
00000001
10100010
11111111
11111111
00000000
10101010
00010100
NAME kitchen 73

TIL 1be
00100000
01010100
10101010
11111111
11111110
00000000
10000000
00000000
NAME kitchen 74

TIL 1bf
00100000
00100011
11111100
11100000
11000000
10000000
11000000
10000000
NAME kitchen 75

TIL 1bg
11110000
11110000
11101000
11101000
11111000
11111000
10111000
10111000
NAME kitchen 76

TIL 1bh
10000000
10011110
10000001
10011111
10000000
10000000
10000000
10000000
NAME kitchen 77

TIL 1bi
00000000
00000011
11111111
10100000
00000000
00000000
00000000
00000000
NAME kitchen 78

TIL 1bj
00111111
11111111
10000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 79

TIL 1bk
11101010
11111100
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 80

TIL 1bl
11100000
01111111
01000000
00001000
00011000
00011000
00011000
00011100
NAME kitchen 81

TIL 1bm
00000000
11110000
00001111
00000000
00000000
00000000
00000000
00000000
NAME kitchen 82

TIL 1bn
00000000
00000000
11111111
00000000
00000000
00000000
00000000
00000000
NAME kitchen 83

TIL 1bo
00000000
00000000
11000000
00111001
00000110
00000000
00000000
00000000
NAME kitchen 84

TIL 1bp
00000000
00000000
00000111
11111101
00000111
00000111
00000111
00000111
NAME kitchen 85

TIL 1bq
11000000
11000000
10000000
00011100
00000000
00000000
01000000
01100000
NAME kitchen 86

TIL 1br
10110000
11100000
00000000
00000000
00000000
00000000
00000000
00000001
NAME kitchen 87

TIL 1bs
10000000
10000000
10000000
10000001
10000000
10000000
10000000
00000000
NAME kitchen 88

TIL 1bt
00000000
00000000
00000000
00000000
00000000
00000000
01000000
00100000
NAME kitchen 89

TIL 1bu
00001100
00001100
00001100
00001100
00001100
00011100
00011100
00011100
NAME kitchen 90

TIL 1bv
00000111
00000111
00000111
00000111
00000110
00000111
00000111
00010111
NAME kitchen 91

TIL 1bw
10100000
10100000
10100000
10100000
00100000
00100000
00100000
01000000
NAME kitchen 92

TIL 1bx
00000000
00000000
10000000
01000000
10000000
01000000
10100000
01010000
NAME kitchen 93

TIL 1by
00000000
00000000
00000000
00000000
00001010
00010100
00001000
00000101
NAME kitchen 94

TIL 1bz
00000000
00000000
00000000
00000000
00000000
00000001
00101000
01000101
NAME kitchen 95

TIL 1c0
00000000
00000000
00000000
00000000
00101000
01010100
10000000
01010101
NAME kitchen 96

TIL 1c1
00000000
00000000
00000000
00000000
00000000
00000000
10101010
01000001
NAME kitchen 97

TIL 1c2
00000000
00000000
00000000
00000000
00000000
00000101
10101010
01010101
NAME kitchen 98

TIL 1c3
00101000
00101000
00101000
00101000
00111000
00110000
10110000
01110000
NAME kitchen 99

TIL 1c4
00000000
00000000
00000000
00000000
00000000
00000000
00000010
01010000
NAME kitchen 100

TIL 1c5
00000000
00000000
00000000
00000101
00000010
01010001
00000010
00010001
NAME kitchen 101

TIL 1c6
00001111
01011111
10001111
01011111
10101111
01001111
00001001
01011001
NAME kitchen 102

TIL 1c7
10100000
01000001
10101010
01000101
00100111
11111111
00000111
11111111
NAME kitchen 103

TIL 1c8
10100000
01000101
10101010
01010111
11111111
11111111
11111111
11100000
NAME kitchen 104

TIL 1c9
00000000
00000000
10101000
11111111
11111111
11111111
11111111
00000000
NAME kitchen 105

TIL 1ca
00000000
00000000
00000000
11111111
11111111
11111111
11110000
00000000
NAME kitchen 106

TIL 1cb
00000001
00000001
11111111
11111111
11111110
00000000
00000000
00000000
NAME kitchen 107

TIL 1cc
10101000
10000001
11111111
11111111
00000000
00000000
00000000
00000000
NAME kitchen 108

TIL 1cd
00101010
01000001
11111111
11111111
01111111
11111111
00000000
00000111
NAME kitchen 109

TIL 1ce
00000000
11111110
11000001
11111111
11111111
11111111
11111100
11100011
NAME kitchen 110

TIL 1cf
00001010
00111111
11111111
11111100
11111111
11111110
00000000
00000000
NAME kitchen 111

TIL 1cg
10001010
11111111
11111111
00011111
11100001
00001111
00000000
00000000
NAME kitchen 112

TIL 1ch
00010000
11111111
11110000
11111111
11111111
11111111
00000000
00000000
NAME kitchen 113

TIL 1ci
00001010
11111111
01111111
11110000
11111111
11111111
00000000
00000000
NAME kitchen 114

TIL 1cj
10000000
00000101
11111111
01111111
11111111
11111000
00000000
00000000
NAME kitchen 115

TIL 1ck
00101010
01010000
11111111
11111111
11111111
00000001
00000000
00000000
NAME kitchen 116

TIL 1cl
10001000
00001000
11111111
11101111
11111111
11100000
00011000
00000000
NAME kitchen 117

TIL 1cm
10101010
01000000
11111000
11111111
11111111
00001111
00000000
00000000
NAME kitchen 118

TIL 1cn
00111111
00111100
00000111
00000100
00000010
00010101
00100001
00000010
NAME kitchen 119

TIL 1co
11110000
00000000
11100000
01010011
11111100
10011111
11111010
00010101
NAME kitchen 120

TIL 1cp
00000000
00000000
00000000
11000000
00000000
11010100
10101000
01000000
NAME kitchen 121

TIL 1cq
00000000
00000000
00100000
10100000
10100000
10100101
01101010
01111111
NAME kitchen 122

TIL 1cr
00000000
00000000
00000000
00000000
00000000
01000000
11110000
11010000
NAME kitchen 123

TIL 1cs
00111111
00000110
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 124

TIL 1ct
11110000
00000000
00000000
00000101
00101011
00000101
00000000
00000000
NAME kitchen 125

TIL 1cu
00000000
00000000
00101000
11111111
11111111
01010100
00000011
00001101
NAME kitchen 126

TIL 1cv
00000000
00000000
00000000
10000000
00000000
00000001
11111111
01010101
NAME kitchen 127

TIL 1cw
00000000
00000000
00000000
00000000
00000000
00000000
11111100
11000011
NAME kitchen 128

TIL 1cx
00000000
11111111
00000000
00000000
00000000
00000000
00000000
11100000
NAME kitchen 129

TIL 1cy
00000000
11000000
00000000
00000000
00000000
00000000
00000000
00000111
NAME kitchen 130

TIL 1cz
00000000
00000000
00000000
00000000
00000111
00000000
00011111
11111111
NAME kitchen 131

TIL 1d0
00000000
00000000
00000000
00000000
11111111
00011111
11111110
11111111
NAME kitchen 132

TIL 1d1
00000000
00000000
00000000
00000000
11110000
11000000
00000000
00000000
NAME kitchen 133

TIL 1d2
10101010
00000100
00000010
00000100
00000000
00000000
00000000
00000000
NAME kitchen 134

TIL 1d3
00001000
01010000
10000000
00000000
00000000
00000000
00000000
00000101
NAME kitchen 135

TIL 1d4
00000000
00001111
11110110
00000000
00000000
01010001
10101010
01000000
NAME kitchen 136

TIL 1d5
01111010
11110101
01111000
01110000
10110000
00110000
10101000
01101111
NAME kitchen 137

TIL 1d6
10101010
01010000
10000000
00000000
00000000
00000001
00001010
11111100
NAME kitchen 138

TIL 1d7
10101000
01010100
00000000
00000000
00000000
01000000
00000000
00000000
NAME kitchen 139

TIL 1d8
00001010
00010101
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 140

TIL 1d9
10101011
01000011
00000011
00000011
00000011
00000011
00000001
00000101
NAME kitchen 141

TIL 1da
10101010
11010001
10101010
10010100
10000000
00000000
00100000
01010000
NAME kitchen 142

TIL 1db
11111101
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 143

TIL 1dc
00101010
01110101
00111000
00010000
00001000
00000000
00000000
00000000
NAME kitchen 144

TIL 1dd
00000000
00000000
00000000
00000000
00000000
00000011
00000000
00000000
NAME kitchen 145

TIL 1de
00000000
00000001
00000010
00000000
00111111
11111111
00000011
00000000
NAME kitchen 146

TIL 1df
00101010
01000001
10101000
00000101
11111111
11100000
11111111
00000111
NAME kitchen 147

TIL 1dg
00001010
01111111
00101010
01000011
11111100
00000001
00000000
10000001
NAME kitchen 148

TIL 1dh
10000000
11111111
00000100
11101101
10111111
00011101
10101010
01111100
NAME kitchen 149

TIL 1di
00000000
11111111
10101000
01000000
11101000
01010000
10000000
00000000
NAME kitchen 150

TIL 1dj
01111000
11111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 151

TIL 1dk
00000010
11000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 152

TIL 1dl
11101000
00001000
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 153

TIL 1dm
00000000
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 154

TIL 1dn
00000000
11111111
00000111
00011000
01110000
00000000
00000000
00000000
NAME kitchen 155

TIL 1do
00000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 156

TIL 1dp
00000000
00000000
00000000
00000000
00000000
00000001
00000010
00000000
NAME doorway crowbar 1

TIL 1dq
00000000
00000000
00111000
00001100
00000110
00010011
00100001
00000000
NAME doorway crowbar 2

TIL 1dr
00000000
00000000
00000000
00000000
00000000
00000000
11000000
11100000
NAME doorway crowbar 3

TIL 1ds
00000000
00000000
00000000
00000000
00000000
00000001
00000011
00000111
NAME doorway crowbar 4

TIL 1dt
00000100
00011000
00110000
01000101
10101010
10010101
10101010
01010100
NAME doorway crowbar 5

TIL 1du
00000000
01000001
10101010
00010101
10100010
01000101
10101000
01010001
NAME doorway crowbar 6

TIL 1dv
00000000
00010001
00101010
01000001
00101010
00000101
10101010
01010101
NAME doorway crowbar 7

TIL 1dw
00000000
00000100
00001000
00000000
00001000
00000000
00001000
00000001
NAME doorway crowbar 8

TIL 1dx
00100010
01000000
00000010
01000100
10000000
00000101
10001000
00010100
NAME doorway crowbar 9

TIL 1dy
00100000
01010001
00000010
01010101
10101010
01000000
00101010
01010000
NAME doorway crowbar 10

TIL 1dz
01110000
01111000
10111110
01011111
00101111
01010111
10001010
00010101
NAME doorway crowbar 11

TIL 1e0
00000000
00000000
00000000
00000000
10000000
11000000
11100000
01110000
NAME doorway crowbar 12

TIL 1e1
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000111
NAME doorway crowbar 13

TIL 1e2
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00011111
NAME doorway crowbar 14

TIL 1e3
00000000
00000000
00000000
00000000
00000001
00000011
00000110
01001101
NAME doorway crowbar 15

TIL 1e4
00001110
00011101
00111010
01000101
10101010
00010100
00101000
01000100
NAME doorway crowbar 16

TIL 1e5
10101000
01000001
10000000
00000000
00000000
00000000
00000000
00000000
NAME doorway crowbar 17

TIL 1e6
10100000
00010001
00100010
00010001
00100010
00010001
00100000
00010000
NAME doorway crowbar 18

TIL 1e7
00101010
00010001
10100010
00000101
00100010
00000101
00100010
00000101
NAME doorway crowbar 19

TIL 1e8
00001000
00000001
00001010
00000101
00001000
00000001
00000000
00000000
NAME doorway crowbar 20

TIL 1e9
00000000
00000000
00100000
01000000
10000000
00000000
00000000
00000000
NAME doorway crowbar 21

TIL 1ea
00001000
00010101
00001000
00000000
00000000
00000000
00000000
00000000
NAME doorway crowbar 22

TIL 1eb
10111100
01011110
00101011
01010101
10001011
01010101
10101001
01000101
NAME doorway crowbar 23

TIL 1ec
10111111
11010000
10001010
11010101
10101010
01000100
10001000
01000000
NAME doorway crowbar 24

TIL 1ed
11111111
00000101
10101010
01010101
10101010
00000000
00000000
00000000
NAME doorway crowbar 25

TIL 1ee
11111111
00000000
00000000
00000000
10000000
00000000
00000000
00000000
NAME doorway crowbar 26

TIL 1ef
11111111
00011111
00000000
00000000
00000000
00000000
00000000
00000000
NAME doorway crowbar 27

TIL 1eg
11111111
11111110
00000010
00000000
00000000
00000000
00000000
00000000
NAME doorway crowbar 28

TIL 1eh
11101010
01010101
00101010
00000100
00000010
00000000
00000000
00000100
NAME doorway crowbar 29

TIL 1ei
10111000
01011001
00111000
01011001
10111000
01011001
10111000
01011000
NAME doorway crowbar 30

TIL 1ej
10101000
01000100
10101000
01000100
10001000
01000000
00001000
01000000
NAME doorway crowbar 31

TIL 1ek
00000000
00010000
00000000
00010000
00001000
00010000
00001000
00010000
NAME doorway crowbar 32

TIL 1el
00000010
00000101
00000010
00000101
00000010
00000100
00000000
00000100
NAME doorway crowbar 33

TIL 1em
00000000
00000000
00000100
00001110
00010010
00100011
01000001
01000001
NAME doorway crowbar 34

TIL 1en
10001001
00010101
00001011
00000101
00000011
00000101
00000011
00000101
NAME doorway crowbar 35

TIL 1eo
10100000
00000000
10000000
00010000
10001001
00000001
00000001
10000001
NAME doorway crowbar 36

TIL 1ep
00000000
00000000
01111111
10000000
00000000
00000000
00000000
00000000
NAME doorway crowbar 37

TIL 1eq
00000000
00000000
11111110
00000001
00000000
00000000
00000000
00000000
NAME doorway crowbar 38

TIL 1er
00000000
00000001
01111110
10000000
00000000
00000000
00000000
00000000
NAME doorway crowbar 39

TIL 1es
00000000
11100000
00010010
01010001
01010000
01010001
01010000
01010001
NAME doorway crowbar 40

TIL 1et
10111000
01011000
10111000
01011000
10111000
01011000
10111000
01011000
NAME doorway crowbar 41

TIL 1eu
00000000
01000000
00000000
01000000
10000000
00000000
00000000
00000000
NAME doorway crowbar 42

TIL 1ev
00001000
00010000
00001000
00010000
00001000
00010000
00001000
00010000
NAME doorway crowbar 43

TIL 1ew
00001000
00000100
00001000
00000000
00001000
00000000
00000000
00000000
NAME doorway crowbar 44

TIL 1ex
01000001
01000000
01000000
01001100
01000111
10000111
10001111
10011101
NAME doorway crowbar 45

TIL 1ey
10000001
10000001
10000001
10000001
10000001
10000001
10000001
10000001
NAME doorway crowbar 46

TIL 1ez
00000000
00000000
00000000
00100000
01100000
10100000
10100000
10100000
NAME doorway crowbar 47

TIL 1f0
01010000
01010000
00100000
00100000
00100000
00100000
00100000
01100000
NAME doorway crowbar 48

TIL 1f1
00011000
00011000
00011000
00011000
00011000
00011000
00011000
00011000
NAME doorway crowbar 49

TIL 1f2
00001000
00010000
00001000
00000000
00001000
00000000
00001000
00000000
NAME doorway crowbar 50

TIL 1f3
10011101
10011000
10011000
10001000
10001000
10001000
10001000
10001000
NAME doorway crowbar 51

TIL 1f4
10100000
10100000
00100000
00100000
00100000
00100000
00100000
00100000
NAME doorway crowbar 52

TIL 1f5
01100000
01100000
01100000
01000001
01000010
01000000
01000000
11000100
NAME doorway crowbar 53

TIL 1f6
00011000
00011000
00011000
00011000
00011000
00011000
00011000
00001000
NAME doorway crowbar 54

TIL 1f7
00001000
00000000
00001000
00000000
00000000
00000000
00000000
00000000
NAME doorway crowbar 55

TIL 1f8
10001000
10001000
10001000
10001011
10001110
10011100
11111000
10000000
NAME doorway crowbar 56

TIL 1f9
00000000
01000000
10100000
00100000
00010000
00010000
00011000
00110000
NAME doorway crowbar 57

TIL 1fa
10000001
10000001
10000001
11000001
11000001
11000001
11000001
11000001
NAME doorway crowbar 58

TIL 1fb
00100000
01000000
01000000
01000000
01000000
01000000
01000000
01000000
NAME doorway crowbar 59

TIL 1fc
11001000
11000000
10001000
10010000
10000000
10000000
10100000
10000000
NAME doorway crowbar 60

TIL 1fd
00010000
00010000
00010000
00110000
00110000
00110000
00110000
00110000
NAME doorway crowbar 61

TIL 1fe
00110011
01111100
00110000
00110000
00110000
00111001
00111110
00100000
NAME doorway crowbar 62

TIL 1ff
10000000
00000001
00000011
00000100
00011000
00001000
10001000
10001000
NAME doorway crowbar 63

TIL 1fg
11000000
10000000
10000000
00000000
00001000
00000000
00000000
00000000
NAME doorway crowbar 64

TIL 1fh
11000001
11000001
11000001
11000001
11000001
11000011
11000011
11000011
NAME doorway crowbar 65

TIL 1fi
11000000
10000000
10000000
10000000
11000000
11000000
11000000
11000000
NAME doorway crowbar 66

TIL 1fj
10000000
11000000
11000000
11000000
11000000
11000000
11000000
11000000
NAME doorway crowbar 67

TIL 1fk
00110000
00110000
00110000
00110000
00110000
00110000
00111010
00110000
NAME doorway crowbar 68

TIL 1fl
00000010
00000000
00000010
00000000
00000010
00000000
00000010
00000000
NAME doorway crowbar 69

TIL 1fm
01000000
01000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME doorway crowbar 70

TIL 1fn
10001000
10001000
10001000
10001000
10001000
10001000
10001000
10001000
NAME doorway crowbar 71

TIL 1fo
11000011
11000011
11100011
11100011
11100011
11100011
11100011
11110011
NAME doorway crowbar 72

TIL 1fp
00001110
00110011
01110011
11001001
10000011
10000011
11001110
01111100
NAME doorway crowbar 73

TIL 1fq
11000000
01000000
01000000
01000000
01000000
01000000
01000000
01000000
NAME doorway crowbar 74

TIL 1fr
00111010
00110000
00111010
00110100
00111010
00110100
00111010
00110101
NAME doorway crowbar 75

TIL 1fs
10000000
00000000
10000000
00000000
10000000
00000000
10000000
00000000
NAME doorway crowbar 76

TIL 1ft
00000010
00000100
00100000
00000100
00100000
00010100
00100000
00010100
NAME doorway crowbar 77

TIL 1fu
00000000
00010000
00000000
00010000
00001000
00010000
00101000
00010000
NAME doorway crowbar 78

TIL 1fv
00000000
00000001
00000000
01000101
10000000
01000101
00000010
01000101
NAME doorway crowbar 79

TIL 1fw
11110011
11110011
11110011
11110011
11110011
11110011
11110011
11110011
NAME doorway crowbar 80

TIL 1fx
11000000
11000000
11000000
11000000
11000000
10000000
10000000
10000000
NAME doorway crowbar 81

TIL 1fy
00111010
00110101
00111010
00111111
00111010
00110101
00111011
00110111
NAME doorway crowbar 82

TIL 1fz
10000000
11000000
11000000
01001000
10100000
01000000
11101010
01011100
NAME doorway crowbar 83

TIL 1g0
00000000
00000000
00000001
00001100
00000100
00001000
00000011
00000000
NAME doorway crowbar 84

TIL 1g1
00000000
00010100
00011000
10010100
00001000
01111100
01011000
11001100
NAME doorway crowbar 85

TIL 1g2
00101000
00010000
00101010
00010100
00100010
00010101
00100000
01010101
NAME doorway crowbar 86

TIL 1g3
10001000
10001000
10011000
10011000
01011000
01101000
01000000
00000000
NAME doorway crowbar 87

TIL 1g4
00000010
00000001
00000010
00000000
00000010
00000100
00001000
00000001
NAME doorway crowbar 88

TIL 1g5
00000010
01000101
00001000
01000101
00100000
00100101
10110000
01111101
NAME doorway crowbar 89

TIL 1g6
11110011
01110011
11110011
01110011
11110011
01110011
11110011
11110011
NAME doorway crowbar 90

TIL 1g7
01000000
01000000
11000000
01000000
11000000
01000000
11000000
01000000
NAME doorway crowbar 91

TIL 1g8
00111110
00110111
00011010
00010111
10011101
00010110
10011011
01010101
NAME doorway crowbar 92

TIL 1g9
10100000
01100100
11100100
11111000
10101100
11111110
11011110
11111111
NAME doorway crowbar 93

TIL 1ga
00000000
00000000
00000000
00000001
00000000
00000101
11000010
01000001
NAME doorway crowbar 94

TIL 1gb
01100001
00001000
00010001
10000100
10010111
00010001
10011000
01001000
NAME doorway crowbar 95

TIL 1gc
00101100
11000100
01001000
00011100
10101000
00100100
10111100
01010000
NAME doorway crowbar 96

TIL 1gd
10100000
01010101
10100000
01010101
10101000
00010101
10101000
00010100
NAME doorway crowbar 97

TIL 1ge
00100000
00000100
10100000
00000100
10100010
00000000
10100010
00000000
NAME doorway crowbar 98

TIL 1gf
00000010
00010101
00101010
00000000
00101011
01010000
00101110
01010111
NAME doorway crowbar 99

TIL 1gg
11011110
00011101
11100111
00011111
11101101
11111111
11111101
11111101
NAME doorway crowbar 100

TIL 1gh
11110011
11110001
11110001
11110001
10100001
11110001
11100001
10100001
NAME doorway crowbar 101

TIL 1gi
10000010
10000101
10001000
10000100
10001000
00010001
00101000
01010000
NAME doorway crowbar 102

TIL 1gj
10000000
01000000
00100000
01000000
10000000
01000101
00001000
01000100
NAME doorway crowbar 103

TIL 1gk
00000000
00000000
00000000
00000000
00000000
00010101
10101000
01010000
NAME doorway crowbar 104

TIL 1gl
00000000
00000000
00000000
00000001
10100000
00000000
00001010
01010101
NAME doorway crowbar 105

TIL 1gm
11101000
01000000
10101010
01100101
10101010
00100101
10101010
00110001
NAME doorway crowbar 106

TIL 1gn
10010010
01010101
10011001
01011110
10111101
01011111
10111010
01111111
NAME doorway crowbar 107

TIL 1go
11111111
11111111
10111011
11110111
11111111
11111111
10111111
11111111
NAME doorway crowbar 108

TIL 1gp
01010010
11000001
11010000
11100101
00011000
10111010
11010100
01101000
NAME doorway crowbar 109

TIL 1gq
10001011
01001011
10011111
00001110
10111111
01000011
10111111
11111111
NAME doorway crowbar 110

TIL 1gr
00101000
01010010
11101100
10111000
11011100
10111000
11010110
11111111
NAME doorway crowbar 111

TIL 1gs
10101010
01010100
10001110
01010101
10001010
01010101
10001111
01100111
NAME doorway crowbar 112

TIL 1gt
10100010
11100000
10110010
01000101
11110010
01101101
11111010
01101101
NAME doorway crowbar 113

TIL 1gu
10001000
00000000
10001000
01010000
10000000
00010111
10101110
01010101
NAME doorway crowbar 114

TIL 1gv
00101011
01000111
10011111
01010011
11100110
11100110
10101111
01011010
NAME doorway crowbar 115

TIL 1gw
11111111
11110011
11111111
11111111
11111111
11111111
10111111
11111111
NAME doorway crowbar 116

TIL 1gx
10100001
11110001
01110001
11110011
11111111
11111111
11111111
11111111
NAME doorway crowbar 117

TIL 1gy
10100000
01000001
10001011
11110111
11111111
11111111
11111111
11111111
NAME doorway crowbar 118

TIL 1gz
10101010
11010001
10111110
11101111
11111111
01111111
11111110
11111111
NAME doorway crowbar 119

TIL 1h0
10001010
01010101
10111010
01111111
11111111
11110101
11111011
01111111
NAME doorway crowbar 120

TIL 1h1
10101010
01010001
10101010
11111111
11111111
11110111
11111111
11111101
NAME doorway crowbar 121

TIL 1h2
00101010
00110000
10111110
11111101
11101011
11010111
11101010
11111111
NAME doorway crowbar 122

TIL 1h3
10111000
01011111
10111111
11111111
10111111
11011110
11110010
11111101
NAME doorway crowbar 123

TIL 1h4
00111111
10011101
00101111
11111011
10001111
11011011
10101001
01110111
NAME doorway crowbar 124

TIL 1h5
11000100
01011000
10011111
11111111
11011100
11111111
11111111
01111111
NAME doorway crowbar 125

TIL 1h6
10111111
11111111
01100111
11111111
11111111
01101111
11110011
01111111
NAME doorway crowbar 126

TIL 1h7
11111110
11110100
11111101
11100110
11001110
11110111
11011111
11111101
NAME doorway crowbar 127

TIL 1h8
10001010
01011101
10001010
01000111
10001011
01111111
00010011
00101111
NAME doorway crowbar 128

TIL 1h9
11111010
00111101
00111100
11110101
01111110
11110111
10111100
01111111
NAME doorway crowbar 129

TIL 1ha
11110101
01001101
10111111
10011111
01110011
01001111
11101111
10100111
NAME doorway crowbar 130

TIL 1hb
11010111
01101101
11001111
01011110
11111101
11111001
00010011
11101111
NAME doorway crowbar 131

TIL 1hc
11111111
11111111
01111111
11111101
11111010
11110101
11101011
11010101
NAME doorway crowbar 132

TIL 1hd
11111111
11111111
11111111
11111111
11111111
01111111
10001010
10110101
NAME doorway crowbar 133

TIL 1he
11111111
11111111
11111111
11101111
11101111
11111110
11111111
01011101
NAME doorway crowbar 134

TIL 1hf
11111011
11111111
11111111
11101111
11111110
01111001
11111011
11010101
NAME doorway crowbar 135

TIL 1hg
11111111
11111101
11111111
11111111
10111111
10111111
11101111
11111111
NAME doorway crowbar 136

TIL 1hh
11111111
11111101
11111111
11111111
10111110
11111110
11111010
11011111
NAME doorway crowbar 137

TIL 1hi
11101111
11111111
11111111
11111111
01111111
11111111
11101011
11110111
NAME doorway crowbar 138

TIL 1hj
11111010
11111111
11111100
11111111
11111111
01110111
11101011
11010101
NAME doorway crowbar 139

TIL 1hk
10111101
00011101
10111110
11011111
11111110
11111111
11111011
11110100
NAME doorway crowbar 140

TIL 1hl
11111111
11111111
11111111
11111111
01111111
11111111
10111111
11110110
NAME doorway crowbar 141

TIL 1hm
11011111
11111111
11111111
11101111
11111011
01110011
11111010
11111110
NAME doorway crowbar 142

TIL 1hn
11111111
01101101
11111110
11111111
11111111
00111111
11111111
11110110
NAME doorway crowbar 143

TIL 1ho
01001111
00101111
00100011
00010111
00010101
00011111
00101011
00001111
NAME doorway crowbar 144

TIL 1hp
10110101
11111111
11111101
11110111
01111111
11111111
10111110
00111011
NAME doorway crowbar 145

TIL 1hq
11010111
11111111
11111111
11111111
10111111
11111111
11111111
11111111
NAME doorway crowbar 146

TIL 1hr
11111111
11111111
11111111
11111111
11111110
11111101
11111010
11110101
NAME doorway crowbar 147

TIL 1hs
11101010
11010100
10001010
01010100
10101000
01010001
10100010
01000100
NAME doorway crowbar 148

TIL 1ht
01010010
00000101
00001010
01010101
10101001
01010000
00100000
01000000
NAME doorway crowbar 149

TIL 1hu
10100000
00001001
00101000
01000000
10000000
10000000
00000000
00000001
NAME doorway crowbar 150

TIL 1hv
10001011
01010011
00000000
00000100
10101000
01000001
00000010
00010010
NAME doorway crowbar 151

TIL 1hw
11111010
11111101
11111111
11010111
10101111
00111111
00111111
01100110
NAME doorway crowbar 152

TIL 1hx
11111111
01100111
11101011
11110111
11111010
11111101
11111000
11010011
NAME doorway crowbar 153

TIL 1hy
11101111
11111101
11111111
11011101
11111010
11011101
01100101
00000000
NAME doorway crowbar 154

TIL 1hz
11111010
01111111
10111011
11011111
10011011
01101101
01001000
00010000
NAME doorway crowbar 155

TIL 1i0
11111111
11111101
11111110
11111101
11111010
00110001
00100000
00010001
NAME doorway crowbar 156

TIL 1i1
11111011
11101110
11111111
01111110
10111101
01011100
10100111
01010111
NAME doorway crowbar 157

TIL 1i2
11110111
01111111
11110111
01111110
10111101
11101111
11111001
01111111
NAME doorway crowbar 158

TIL 1i3
11010100
11111111
11110010
01110100
11111000
10111110
11010100
10110110
NAME doorway crowbar 159

TIL 1i4
01110111
00001001
00011111
00010110
00001111
00101111
00101110
01010101
NAME doorway crowbar 160

TIL 1i5
11111111
11011111
11111111
11011111
01111111
11111111
11110110
01100011
NAME doorway crowbar 161

TIL 1i6
11111111
01111111
11110111
11111110
01111110
11111001
11110110
10110001
NAME doorway crowbar 162

TIL 1i7
11101010
10010101
00101010
00010101
00001010
01010100
10001000
00000000
NAME doorway crowbar 163

TIL 1i8
10101000
01010000
10101000
01010000
00000000
00000000
00000000
00000000
NAME doorway crowbar 164

TIL 1i9
00010010
00000000
00000010
00000000
00000000
00000000
00000000
00000000
NAME doorway crowbar 165

TIL 1ia
00101011
01111110
00111111
11101010
00011111
01110100
00000000
00000000
NAME doorway crowbar 166

TIL 1ib
01110111
11100110
00100100
01000000
00000000
00000000
00000000
00000000
NAME doorway crowbar 167

TIL 1ic
00001010
10000000
00000000
00000001
00001000
00000000
00000000
00000000
NAME doorway crowbar 168

TIL 1id
00000000
00010000
00000000
00010000
00000000
00010000
00000000
00010001
NAME doorway crowbar 169

TIL 1ie
00000000
00000000
00001010
00000100
00001000
00010001
10000000
00000000
NAME doorway crowbar 170

TIL 1if
10101001
00010101
00001010
00000101
10001000
00000100
00000010
00000000
NAME doorway crowbar 171

TIL 1ig
10111001
11110001
01101001
00110011
00001001
00000111
00000010
00000001
NAME doorway crowbar 172

TIL 1ih
11101000
11101111
01111011
10000000
00010100
00000010
10010100
01001001
NAME doorway crowbar 173

TIL 1ii
00000000
00000000
00000000
00000000
00001111
10011100
11111000
10000000
NAME doorway no 1

TIL 1ij
00000000
01100000
11100000
10110000
00010000
00010000
00011000
00111000
NAME doorway no 2

TIL 1ik
00110011
01111100
00110000
00110000
00110000
00111011
00111111
00101111
NAME doorway no 3

TIL 1il
10000000
00000001
00000011
00000111
00111100
11111000
11100000
00000000
NAME doorway no 4

TIL 1im
11100000
11000000
10000000
00000000
00001000
00000000
00000000
00000000
NAME doorway no 5

TIL 1in
01010000
01000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME doorway no 6

TIL 1io
00000101
10101000
01000000
01000001
10100001
00000001
01000000
00010000
NAME end1 1

TIL 1ip
00001111
00000000
00010100
10100011
00000100
10100100
10010100
11100010
NAME end1 2

TIL 1iq
01000000
11000000
00101000
00100010
00010111
00000100
00001110
00100100
NAME end1 3

TIL 1ir
00100001
10000000
00000000
00011000
00010010
00001101
00111011
11111000
NAME end1 4

TIL 1is
10111100
10011001
10011011
00000101
01110111
01011111
11101110
11111111
NAME end1 5

TIL 1it
01100101
00101011
11001011
00001011
10111011
11111111
11001101
10111111
NAME end1 6

TIL 1iu
00111100
11101100
11011000
11010101
10101111
11110111
01110011
10010000
NAME end1 7

TIL 1iv
00100000
10000101
11000010
00010000
01101100
10000000
11000111
01111101
NAME end1 8

TIL 1iw
00000000
00010000
01000000
00000001
00001100
10000000
01010000
10011000
NAME end1 9

TIL 1ix
00000000
00000000
00000000
00000000
00101011
11001010
01000000
00100000
NAME end1 10

TIL 1iy
00000000
00000001
00011000
00000100
00011010
10001011
10011111
00100100
NAME end1 11

TIL 1iz
10101000
10101001
10011011
11010010
00001011
11111000
11101110
00100100
NAME end1 12

TIL 1j0
00110000
01011010
01010001
01000011
11100000
11111111
11110000
10110000
NAME end1 13

TIL 1j1
00000000
00000000
00000000
00000000
00000000
00000100
00001001
00110000
NAME end1 14

TIL 1j2
00000000
00000000
00000001
00000101
01000000
00010100
10001000
00101001
NAME end1 15

TIL 1j3
00000000
00010000
01000000
00010011
01001000
00100001
10000000
00110001
NAME end1 16

TIL 1j4
10000001
00010100
10100010
10001000
00111000
00000000
00101000
00000000
NAME end1 17

TIL 1j5
00000011
10010000
00100110
10001000
10000100
10111000
01100001
01101101
NAME end1 18

TIL 1j6
00000100
00011111
11101101
10001111
11110011
10000111
01101110
11011011
NAME end1 19

TIL 1j7
01011111
11111011
10111111
11111011
11110111
01110011
10101011
11110110
NAME end1 20

TIL 1j8
01010111
11011110
11111011
01111110
01111111
11010111
10111111
11101111
NAME end1 21

TIL 1j9
10011111
10111111
10111111
11111110
11010111
10011111
01110011
10111111
NAME end1 22

TIL 1ja
11101100
11111111
11110111
11111011
01110110
11101100
11111101
11011011
NAME end1 23

TIL 1jb
11001100
01101100
11011000
11111111
00010101
00010110
10111011
11110000
NAME end1 24

TIL 1jc
11000110
00101010
11110000
11001001
00110011
11101011
10001010
01001101
NAME end1 25

TIL 1jd
11110101
11001000
11101011
11011100
11110010
10101101
10110111
11101111
NAME end1 26

TIL 1je
00111111
00000010
10011011
10011110
01111001
11101111
10110111
10010111
NAME end1 27

TIL 1jf
01010011
11100101
11000001
00111101
01101111
11111110
11101001
10111011
NAME end1 28

TIL 1jg
11101100
11001100
11011010
01100001
11101101
11100111
11101111
11111111
NAME end1 29

TIL 1jh
00000001
00000000
10011000
01011011
01010111
11111111
11111111
11111111
NAME end1 30

TIL 1ji
00001110
11010001
10011100
11100001
11111110
01111110
11001111
11110101
NAME end1 31

TIL 1jj
11100000
01001100
01000001
11100000
01101110
01111100
11111100
00111111
NAME end1 32

TIL 1jk
01110110
10010110
01010001
00100011
00001100
00001101
10010110
00110000
NAME end1 33

TIL 1jl
00001010
11000000
00010100
00001000
10010011
00000010
10110010
00010000
NAME end1 34

TIL 1jm
10010111
01100111
10011111
10101000
10110010
11111011
10111010
10101111
NAME end1 35

TIL 1jn
11111011
01111111
11111110
11111111
10111101
11111111
11101011
11111101
NAME end1 36

TIL 1jo
11110111
11101110
11111111
01110011
11111011
11111101
11011011
11110111
NAME end1 37

TIL 1jp
01111111
11111110
10110110
11111110
11111101
11111111
10101101
01111101
NAME end1 38

TIL 1jq
01111011
10111011
11110111
11111001
01101111
01111110
11111001
11101101
NAME end1 39

TIL 1jr
11110010
11110010
11101101
10110010
10100110
11111111
11110111
10111111
NAME end1 40

TIL 1js
01100011
11001101
01111101
11011111
11111011
11111011
11111111
11111111
NAME end1 41

TIL 1jt
11101110
00101101
10111110
10111111
11111111
10111111
10111011
11111111
NAME end1 42

TIL 1ju
01111111
11111000
10101111
11100011
10011110
11110111
11111111
11111111
NAME end1 43

TIL 1jv
01111111
11111011
01111111
00111111
01011111
11111111
01111111
11111111
NAME end1 44

TIL 1jw
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111011
NAME end1 45

TIL 1jx
01111101
10111010
11111010
11110011
11101111
10100101
11111011
11111110
NAME end1 46

TIL 1jy
11011111
11100100
01101001
11110111
10000111
11111011
10101101
11011000
NAME end1 47

TIL 1jz
10000000
01010000
11001101
00101110
01100011
01110111
00010001
10011111
NAME end1 48

TIL 1k0
00000101
11101010
10101001
01111110
01010100
00101111
00111010
01010010
NAME end1 49

TIL 1k1
00111011
01000011
11001110
10011001
10101111
11010111
11011111
01011011
NAME end1 50

TIL 1k2
11011111
00100000
11111101
01111011
01111110
00001111
01101110
10111111
NAME end1 51

TIL 1k3
10100011
11111111
11111001
01001110
10110101
00110111
01101101
11111101
NAME end1 52

TIL 1k4
11111011
11010111
11110111
11110101
11110001
11110111
00011110
10111011
NAME end1 53

TIL 1k5
10110111
01111110
10110111
11111111
01111111
11111111
11111111
11111111
NAME end1 54

TIL 1k6
11111011
11110111
11111111
11111111
11011111
11111111
11111111
11111111
NAME end1 55

TIL 1k7
11101111
10111111
11111111
11111111
10111111
11111111
11111101
11111111
NAME end1 56

TIL 1k8
11111101
11111111
11111111
11111111
11111111
11101111
11111111
11111111
NAME end1 57

TIL 1k9
11111111
11111011
11111111
11111111
11111111
11111111
11111111
11111111
NAME end1 58

TIL 1ka
11111111
11111111
11111111
11111111
11111111
11110111
11111111
11111111
NAME end1 59

TIL 1kb
11111111
11111111
10111111
11111111
11011011
11111111
11011111
11111111
NAME end1 60

TIL 1kc
11111111
11111111
11111110
11110111
11110110
11111111
11111111
11010111
NAME end1 61

TIL 1kd
10111111
11011111
11111011
11101111
11011101
10001111
11111010
10111111
NAME end1 62

TIL 1ke
11011111
11101111
10111110
01111001
11111111
10010111
11101111
00111111
NAME end1 63

TIL 1kf
11111101
01101011
01010011
00111110
10111111
11001011
11011010
11001101
NAME end1 64

TIL 1kg
10011011
10010001
10110011
11111100
11111011
01110101
10101111
01110101
NAME end1 65

TIL 1kh
00101101
10110111
01111010
11010111
11010110
11100011
11001111
01111111
NAME end1 66

TIL 1ki
11111110
10111101
11011110
10111011
11111111
11111110
11111010
11111111
NAME end1 67

TIL 1kj
11100011
11011111
11001110
11011110
11111111
11111111
10101011
10111110
NAME end1 68

TIL 1kk
11101110
10111111
10111101
11111111
10110111
11111111
10101101
10011111
NAME end1 69

TIL 1kl
10111101
11111011
11111111
11111111
10111111
11111111
01111101
11111111
NAME end1 70

TIL 1km
11111111
11100111
11111111
10111111
11111111
11011111
11011101
11011101
NAME end1 71

TIL 1kn
11111111
10111111
11111111
11111101
11111111
11000011
10011111
11011101
NAME end1 72

TIL 1ko
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11101111
NAME end1 73

TIL 1kp
11111111
11111111
11101111
11111111
11111111
11111111
11110111
11111111
NAME end1 74

TIL 1kq
11011110
00011111
11111011
11011101
11111011
11111101
11110101
11001111
NAME end1 75

TIL 1kr
11111011
11111111
11111110
00011111
11111111
11111111
11111111
11111111
NAME end1 76

TIL 1ks
11101101
11110111
11111111
11101110
11101011
11111111
11111000
10011111
NAME end1 77

TIL 1kt
01101010
10001110
10110001
01111110
11101111
10110111
11111111
11111111
NAME end1 78

TIL 1ku
11111011
11111110
11101010
00011111
01111111
00111001
11001011
11010111
NAME end1 79

TIL 1kv
11110111
00111101
11111111
11110111
11111111
11111011
11110100
01111110
NAME end1 80

TIL 1kw
10111111
11111101
11110111
11111111
11111011
01011111
10111111
11111111
NAME end1 81

TIL 1kx
01111111
11111111
11111111
11111100
11110111
11111111
11111111
11111001
NAME end1 82

TIL 1ky
11101111
11110011
11111111
11010111
11111111
11111111
01110011
11011111
NAME end1 83

TIL 1kz
11111111
11111110
11111111
11111111
11111101
01111101
10111001
11111001
NAME end1 84

TIL 1l0
11111111
11101111
10111111
11011111
11111111
11101111
10101111
11111111
NAME end1 85

TIL 1l1
11101111
01111111
01111110
11101110
11110001
00111111
01001110
11111110
NAME end1 86

TIL 1l2
11011111
11001111
11111011
10001110
11111011
01111111
00110110
10111101
NAME end1 87

TIL 1l3
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10111111
NAME end1 88

TIL 1l4
11111111
11111101
11111111
11111111
11111111
11111011
11111111
11011111
NAME end1 89

TIL 1l5
11111011
01110101
11110100
11101110
11011010
10100111
01101001
10011010
NAME end1 90

TIL 1l6
11111111
11111110
11110010
10111111
00010111
10111011
11111111
01101001
NAME end1 91

TIL 1l7
11111111
11111011
11101011
11111111
11100111
10101010
01011110
00100110
NAME end1 92

TIL 1l8
11111011
01011111
11110111
10111111
11111111
11101110
11111111
11001111
NAME end1 93

TIL 1l9
11111111
11011110
11111001
11110001
11010110
11111111
11111110
10010111
NAME end1 94

TIL 1la
11111110
10011111
11010011
10011101
10000010
10111000
11001111
10010111
NAME end1 95

TIL 1lb
11011110
00110000
11111011
10111110
10111111
11111101
11111101
11101110
NAME end1 96

TIL 1lc
11111111
10011111
11110111
11111111
11111111
11111111
10111111
11111111
NAME end1 97

TIL 1ld
11001101
11111111
11111111
11111111
11110111
11111111
11111111
10111101
NAME end1 98

TIL 1le
10111111
11101011
10111111
11111111
11011111
11111111
11111111
11111111
NAME end1 99

TIL 1lf
11111111
11111111
11011110
11111111
11111011
11111111
11111111
11110111
NAME end1 100

TIL 1lg
11110000
11101111
11011111
11111111
11111111
11111111
11111111
11111111
NAME end1 101

TIL 1lh
11110101
10111110
11111111
11111111
11110111
11111111
11111111
11111111
NAME end1 102

TIL 1li
10101010
11111110
11011100
10101111
11000101
11110010
11111110
11111010
NAME end1 103

TIL 1lj
11111111
11111111
11100011
11110100
00011110
11101001
10101011
01111001
NAME end1 104

TIL 1lk
11111011
10110111
10000110
00110000
10100010
10010110
00111010
00011100
NAME end1 105

TIL 1ll
01010000
10110011
01110110
00000100
00011000
10001110
00111100
11110111
NAME end1 106

TIL 1lm
01000101
10101011
01110101
11100110
01010101
11000101
00011010
10111101
NAME end1 107

TIL 1ln
11101101
01001001
01111111
11111111
11100101
10100101
11111100
11001101
NAME end1 108

TIL 1lo
10111111
01011011
11101011
11111111
01010111
11110111
11111101
11110101
NAME end1 109

TIL 1lp
01111001
11111011
11011010
11111111
11111111
01111111
10100100
11110100
NAME end1 110

TIL 1lq
00111101
11111101
11111110
10101010
10100111
10010100
11000001
11111000
NAME end1 111

TIL 1lr
11011101
10110010
11111110
01101110
01011101
01111010
00111111
01111110
NAME end1 112

TIL 1ls
11111011
11111100
11111111
11111011
00111111
10111101
11111011
01011101
NAME end1 113

TIL 1lt
11101011
01111111
11111111
11111111
11110111
11111111
11111111
11111111
NAME end1 114

TIL 1lu
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111110
NAME end1 115

TIL 1lv
11111111
11111101
11011111
11111111
11111111
11111111
11111111
11111111
NAME end1 116

TIL 1lw
11111000
11111111
11111101
11111111
11111111
11101111
11111011
11101111
NAME end1 117

TIL 1lx
00101011
10011001
00101000
10110001
10100010
11001110
11100001
11001111
NAME end1 118

TIL 1ly
00011000
00100110
11100001
10011100
01100111
11011011
10001111
10110001
NAME end1 119

TIL 1lz
11111110
11110100
11111110
11111111
11111111
01111111
01111101
11111111
NAME end1 120

TIL 1m0
11111001
11000001
11111110
11101111
11101110
11011011
11001101
11010101
NAME end1 121

TIL 1m1
10101101
11011011
00101010
11101101
11111101
01011001
11111111
11010111
NAME end1 122

TIL 1m2
10011101
10111101
10111011
11110100
10001001
11110100
11011110
00110111
NAME end1 123

TIL 1m3
01100010
00010110
11010100
11011100
01000011
10001000
00101010
11010010
NAME end1 124

TIL 1m4
11111000
10010011
00011110
10010111
00111000
01000000
11011101
01100011
NAME end1 125

TIL 1m5
11001001
01001001
11001000
01110110
01111011
10101011
00010101
11110111
NAME end1 126

TIL 1m6
10101111
01011111
10101010
10101111
11111111
00111111
00111111
10011101
NAME end1 127

TIL 1m7
01111111
01111111
11111111
10111111
11111111
11111111
11111111
11111011
NAME end1 128

TIL 1m8
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11011111
NAME end1 129

TIL 1m9
11111111
11011111
11111111
11101111
11111111
11101111
11111111
11011111
NAME end1 130

TIL 1ma
11111100
11111111
11011111
11111011
11111111
11111110
11101111
01111110
NAME end1 131

TIL 1mb
10010110
10101111
00010001
10101111
11110110
11111111
01110111
11101011
NAME end1 132

TIL 1mc
01111011
01111111
11111111
11111111
11110111
11110111
11101111
11111111
NAME end1 133

TIL 1md
11111111
11111111
11111110
11111111
11110111
11111111
11111111
11111111
NAME end1 134

TIL 1me
01101101
11101101
11111110
11011111
10111111
11011111
11111111
11111111
NAME end1 135

TIL 1mf
10010101
11001101
11111011
11011010
11111111
11110110
11111111
11101111
NAME end1 136

TIL 1mg
11111011
11110010
11110000
11010010
10011101
10110000
11011111
10111111
NAME end1 137

TIL 1mh
10000100
00000101
00010000
11000100
10110101
10001100
11000000
00110010
NAME end1 138

TIL 1mi
11010110
00010101
00101111
00001111
01000110
00000011
01001011
00110011
NAME end1 139

TIL 1mj
01011011
11001110
10101111
01111101
10001111
01111010
00100110
11011101
NAME end1 140

TIL 1mk
10011111
11111111
11011111
01111111
10111101
01111001
11111111
11111011
NAME end1 141

TIL 1ml
11111111
11111111
11111111
01011110
11111111
10111101
11111111
11101111
NAME end1 142

TIL 1mm
11111111
11101111
11111111
11111111
11101111
11101111
11111111
11111111
NAME end1 143

TIL 1mn
11111010
11111011
11111111
11110111
10111011
10111011
10111101
11111011
NAME end1 144

TIL 1mo
10111111
11111011
11111111
11111111
11111111
11110111
11111111
01111110
NAME end1 145

TIL 1mp
01111101
11011111
11111111
01111111
11111111
11110111
11111111
11111111
NAME end1 146

TIL 1mq
11111111
11101111
10111111
11111111
11111111
11111111
11111111
11111111
NAME end1 147

TIL 1mr
11111111
11111111
11111111
11110111
11111111
11111111
11111111
01111111
NAME end1 148

TIL 1ms
10111111
11111111
11111011
11101110
11111111
11111011
11110111
11111111
NAME end1 149

TIL 1mt
11111101
11101110
11111111
11111101
11111111
10111111
11111111
11111111
NAME end1 150

TIL 1mu
11001101
11111101
11011110
11111110
01110101
11101100
11010101
10111111
NAME end1 151

TIL 1mv
10000000
00000100
00000010
11110000
00001111
10100010
10011110
11111100
NAME end1 152

TIL 1mw
11001111
00001111
01111110
11101111
10010110
11011011
11111111
11101101
NAME end1 153

TIL 1mx
01111011
11111111
11111110
11111111
11101111
11111111
11111111
11111111
NAME end1 154

TIL 1my
11111111
10111111
11011111
11111011
11111111
01111111
11110110
11111011
NAME end1 155

TIL 1mz
11001110
11010011
01111011
11111111
11111110
10011010
11111111
10111111
NAME end1 156

TIL 1n0
10111111
11111111
11111111
01101111
11011111
11111111
10111111
11111111
NAME end1 157

TIL 1n1
11011111
11110111
11110111
01111111
10011111
01111111
11110111
11111110
NAME end1 158

TIL 1n2
11111111
11111101
11111111
11111111
11111111
11110111
01111111
11111111
NAME end1 159

TIL 1n3
11111111
11111111
01111111
11111111
11110101
11111111
11111111
10101101
NAME end1 160

TIL 1n4
01110111
11111100
11011111
11111111
11111111
10111111
11111111
11101111
NAME end1 161

TIL 1n5
11111111
01111011
11101111
11111110
11111111
11011011
11111111
11011111
NAME end1 162

TIL 1n6
11111111
01111111
11111111
11100101
11111111
11111111
11111111
11111111
NAME end1 163

TIL 1n7
11111111
10011111
11011111
11110111
11111110
11111111
11111111
11111111
NAME end1 164

TIL 1n8
11111111
10111111
11111111
11111111
11110111
11111011
11111111
11111111
NAME end1 165

TIL 1n9
11111111
11111011
10111111
11011111
10111110
11111111
11111101
11111101
NAME end1 166

TIL 1na
11001111
11010100
11110111
11110110
11101110
11111110
11111101
11110011
NAME end1 167

TIL 1nb
01011111
11101111
11010111
01111111
11111111
11011110
11111101
01111110
NAME end1 168

TIL 1nc
11111111
10111111
11111111
11100111
11111111
11111111
11011110
01111111
NAME end1 169

TIL 1nd
11111111
11111111
11111111
11111111
11111111
11111110
11100111
10111111
NAME end1 170

TIL 1ne
11101111
11011101
11101111
11111111
11111111
11011111
11111110
11111110
NAME end1 171

TIL 1nf
11111111
11111111
11011111
11100111
10111111
10111111
11011111
11011111
NAME end1 172

TIL 1ng
11101111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME end1 173

TIL 1nh
01111101
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME end1 174

TIL 1ni
01111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME end1 175

TIL 1nj
11111011
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME end1 176

TIL 1nk
11111101
11110111
11111111
11111111
11111111
11111111
11111111
11111111
NAME end1 177

TIL 1nl
11111110
11111011
11111110
11111110
11111011
11111111
11111111
11111111
NAME end1 178

TIL 1nm
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01111101
NAME end1 179

TIL 1nn
10111111
11111101
11111010
11011111
11111110
11111110
11111001
11011011
NAME end1 180

TIL 1no
11011111
01010111
11000111
11110011
01000101
11111001
11011101
11010111
NAME end1 181

TIL 1np
11010111
11111111
11101111
11111111
11111110
10111111
11111111
01111111
NAME end1 182

TIL 1nq
11111101
11111011
11111111
10111111
11111111
10101111
11111110
11111111
NAME end1 183

TIL 1nr
11111111
00011111
11111111
11111101
11111111
11101111
11111111
11111111
NAME end1 184

TIL 1ns
11111111
00111111
11111111
11111111
11111111
11111111
11101111
11111111
NAME end1 185

TIL 1nt
11111111
11011111
11111111
11111111
11111111
11011111
11111111
11111111
NAME end1 186

TIL 1nu
11101111
11011111
11111111
10111111
11111111
11111101
11111111
11111001
NAME end1 187

TIL 1nv
01010010
10010111
11011111
11111111
11111111
01001101
11101110
11111111
NAME end1 188

TIL 1nw
11111111
11111111
11101101
11101101
11111111
11100011
11111111
11111111
NAME end1 189

TIL 1nx
11111111
11111110
11111100
11111111
11111101
11111111
11111111
11111111
NAME end1 190

TIL 1ny
11111111
11111111
11111111
11111011
11111111
11111111
11111111
11111111
NAME end1 191

TIL 1nz
11111111
11011111
11011111
11111111
11111111
11111111
11111111
11111111
NAME end1 192

TIL 1o0
11111111
11111011
11111111
11100111
11111111
11111111
11111111
11111111
NAME end1 193

TIL 1o1
11011111
11111111
10101111
11111011
10011111
10111110
11111111
11111111
NAME end1 194

TIL 1o2
00000000
00000000
00000000
00000000
00001000
00001000
00001000
00100000
NAME end2 1

TIL 1o3
00000000
00000000
00000000
00000000
01000000
00000000
00000000
00000000
NAME end2 2

TIL 1o4
00000100
00000000
00000000
00000000
00000000
00000000
10000000
00000000
NAME end2 3

TIL 1o5
00000000
00000000
10000000
00000010
00011000
10000000
01000100
00110010
NAME end2 4

TIL 1o6
01000000
00000000
00000001
00000000
00000000
00000000
00000100
01000000
NAME end2 5

TIL 1o7
00000000
00000000
00100000
00000000
00000000
00000000
00000000
00000000
NAME end2 6

TIL 1o8
00000000
00000000
00000000
00000001
00001000
00010000
00000000
00000000
NAME end2 7

TIL 1o9
00000000
00000000
00101010
01000000
00000000
00010000
00100000
01000001
NAME end2 8

TIL 1oa
00000000
00000000
00000000
00000000
00000000
00010100
10000000
01000000
NAME end2 9

TIL 1ob
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00111001
NAME end2 10

TIL 1oc
00000001
00100010
11000000
00110101
01000010
00011000
10000010
00100011
NAME end2 11

TIL 1od
01010001
01010000
01011001
01100010
10000101
00000011
00110100
01001100
NAME end2 12

TIL 1oe
00000000
00000000
10000000
01000000
01000000
01000000
00000000
10000000
NAME end2 13

TIL 1of
00000000
00000000
00000000
00000010
00000000
01000000
00000000
00000000
NAME end2 14

TIL 1og
00000000
00000010
01000100
00000000
00000000
00101110
00000000
00010000
NAME end2 15

TIL 1oh
00000000
00000000
01000000
00000001
00000000
00000000
00000100
01000100
NAME end2 16

TIL 1oi
00101011
10000000
00011000
00000011
00110000
00000011
00001110
00001101
NAME end2 17

TIL 1oj
00100001
01100101
01100010
01011100
11001000
00010100
00101101
10111111
NAME end2 18

TIL 1ok
00011000
00010100
01111110
01100110
10000000
11111110
00111010
11100111
NAME end2 19

TIL 1ol
00001010
01000000
00000000
00010000
00100000
01000000
10001010
00010101
NAME end2 20

TIL 1om
00000000
00000000
00000000
00000101
00000010
00000101
00000000
00000001
NAME end2 21

TIL 1on
10101000
01010001
10001010
00010000
10000000
00000000
00000010
00010101
NAME end2 22

TIL 1oo
10000000
00000000
00000000
00000001
00000011
00000100
10000000
00000000
NAME end2 23

TIL 1op
00000000
00000101
00001011
00100000
00011010
10011000
00110111
00001100
NAME end2 24

TIL 1oq
00010100
00100000
00011111
01110001
00011101
00100010
01000000
10011000
NAME end2 25

TIL 1or
11001000
10010011
10010001
01010001
01000000
00101000
01000010
00110100
NAME end2 26

TIL 1os
10101100
10100111
01000001
00100011
10110010
00101110
11011011
11011111
NAME end2 27

TIL 1ot
00000010
00000000
11100000
01001000
10100000
00000000
10100000
10000100
NAME end2 28

TIL 1ou
00000000
00010000
00000000
00000001
00000100
00000000
00100000
00000000
NAME end2 29

TIL 1ov
00000000
00000000
00000000
00000000
00000000
00001000
00001000
10111000
NAME end2 30

TIL 1ow
00000110
00000000
00100000
00100000
00000000
00000000
01010000
10010000
NAME end2 31

TIL 1ox
00000001
00000101
00000100
00000100
00000000
00001000
01100010
00001001
NAME end2 32

TIL 1oy
00001100
10100011
00011100
10011111
10100111
10000110
10111111
11010001
NAME end2 33

TIL 1oz
01000100
10001000
01010101
01110101
11110111
11111101
11101111
10111011
NAME end2 34

TIL 1p0
01000111
01100011
00000110
01111100
11101111
11010101
01110100
01000111
NAME end2 35

TIL 1p1
00100010
00000100
00000000
10000100
00011100
10011001
00110010
01111100
NAME end2 36

TIL 1p2
00000000
00000000
00100000
01000000
11000000
00000001
00000010
01000100
NAME end2 37

TIL 1p3
10100010
00000000
01000000
01000001
10001000
01010001
00100010
01010001
NAME end2 38

TIL 1p4
00101000
01010010
10000000
00000110
00101110
01010011
10010110
00010100
NAME end2 39

TIL 1p5
00010010
10010011
00001000
10000101
00110001
01111100
00010011
01110100
NAME end2 40

TIL 1p6
10010001
00110010
10010000
01001101
11001100
10110011
00011101
11101110
NAME end2 41

TIL 1p7
00100000
10101111
11010011
00100101
01111100
01011111
00001110
01110110
NAME end2 42

TIL 1p8
01111110
01010110
11110111
11111111
11111110
11111111
01011110
10010101
NAME end2 43

TIL 1p9
01000010
00001000
01100000
11110001
11000010
11000100
11000000
10000000
NAME end2 44

TIL 1pa
01000011
00000000
00000000
00001100
00000011
00000010
00000010
00010001
NAME end2 45

TIL 1pb
00000000
00000001
10001010
10000100
00001100
01100010
00100011
00110111
NAME end2 46

TIL 1pc
01000101
00000100
10001000
01111101
10001011
00110100
00000010
00101000
NAME end2 47

TIL 1pd
00000000
00000001
01001000
00000010
11000001
10000000
00000001
00001010
NAME end2 48

TIL 1pe
00001111
00010111
10011111
01111111
10010101
00110111
00101111
00011111
NAME end2 49

TIL 1pf
11111111
11111111
11111011
11111111
11111110
11110111
11111111
11111111
NAME end2 50

TIL 1pg
11100101
11011001
11110110
11111101
11110001
01010100
11011101
11111011
NAME end2 51

TIL 1ph
10001000
11111010
11101000
11010110
01110111
01111110
01111101
11100111
NAME end2 52

TIL 1pi
00001000
01000011
00000000
00100000
10000000
01100000
10001011
00001111
NAME end2 53

TIL 1pj
10100000
00000000
00000010
00100100
00001110
11000100
11001010
00011101
NAME end2 54

TIL 1pk
00101010
01010001
00100010
00000100
00110000
01001100
10000001
10011000
NAME end2 55

TIL 1pl
00011111
00001011
00000001
01000101
00001000
10010001
01010100
00110111
NAME end2 56

TIL 1pm
10111001
01010001
11010011
11001011
01011001
00010110
01100110
01010111
NAME end2 57

TIL 1pn
11101011
10110101
01011111
11100011
11111111
01011111
11111111
11111111
NAME end2 58

TIL 1po
01111110
11111010
01111000
11010100
11101100
11101011
11111010
11111100
NAME end2 59

TIL 1pp
10000000
00110010
10010100
10000000
10000000
00010000
01100000
00000000
NAME end2 60

TIL 1pq
00000101
00000001
00000101
00000001
00000000
00000000
00001000
00001110
NAME end2 61

TIL 1pr
01110110
00110010
10000110
10010111
11100011
11010010
10110010
10000111
NAME end2 62

TIL 1ps
11001001
01111000
01011010
01111011
00111110
10100100
00110011
10100111
NAME end2 63

TIL 1pt
10000100
00000000
01000000
00000000
00010000
10001000
11000000
01100000
NAME end2 64

TIL 1pu
00000011
10101011
01000111
00001001
00000000
00100010
01010000
00000001
NAME end2 65

TIL 1pv
11111111
11111111
11111111
11111111
11111111
01111111
10111111
00111111
NAME end2 66

TIL 1pw
11111111
11111110
11111111
11111110
11111111
11111111
11111111
11111111
NAME end2 67

TIL 1px
11111010
10111101
11111110
11101011
10011010
11111110
11001101
10011000
NAME end2 68

TIL 1py
10111100
01110100
10101000
11000111
10110000
11000100
11111111
11111111
NAME end2 69

TIL 1pz
10100010
11001000
11000010
00110010
00010010
01100000
00001111
11111001
NAME end2 70

TIL 1q0
10100000
10011010
00111110
01010111
00001111
00001111
00101101
10011001
NAME end2 71

TIL 1q1
10000001
11111111
00101111
11111011
01011101
11101011
10111111
11110101
NAME end2 72

TIL 1q2
10100111
11101111
11111111
11111111
11111111
11111110
11111111
11111110
NAME end2 73

TIL 1q3
01111111
11111111
10111111
00111111
11111111
11110111
11111101
11111101
NAME end2 74

TIL 1q4
11101110
10110111
11110110
11110100
11010000
11010000
01010010
11000000
NAME end2 75

TIL 1q5
00000000
00000010
00010000
00000000
00000000
00000000
00000000
00000000
NAME end2 76

TIL 1q6
00001010
00001000
00000011
00001000
00000110
00000001
00000011
00000001
NAME end2 77

TIL 1q7
00001111
00111110
11011100
00011111
10001111
00010101
10001101
10110001
NAME end2 78

TIL 1q8
11011111
00101111
00110111
11111111
01111111
00111111
11111111
01111111
NAME end2 79

TIL 1q9
11110010
11111011
11110010
11111100
11101100
11100100
11100000
11110101
NAME end2 80

TIL 1qa
01000100
00000011
10001100
01000001
10000001
01010000
11010001
01000001
NAME end2 81

TIL 1qb
00111111
11011111
11001111
00101111
00000111
00011011
01101011
00001000
NAME end2 82

TIL 1qc
11111110
11111101
11111111
11110111
11111111
00101110
10111101
10111001
NAME end2 83

TIL 1qd
11110011
10000010
11001010
01110111
10101001
10101111
01101111
10111110
NAME end2 84

TIL 1qe
01111011
01111011
11110110
00110110
11111011
11010111
11111111
11111111
NAME end2 85

TIL 1qf
11001111
11110111
11111111
11011111
11110101
11111110
01011111
11111111
NAME end2 86

TIL 1qg
11110111
00110101
10110011
11101010
11111111
11111011
11111111
11111110
NAME end2 87

TIL 1qh
11111111
11111111
01101111
11110111
11111111
11111111
11111111
10111110
NAME end2 88

TIL 1qi
11111111
11111111
11100001
10110010
11111011
10101110
10010010
10111101
NAME end2 89

TIL 1qj
01011111
11111111
11111101
10001000
00001000
10001000
10100000
01110100
NAME end2 90

TIL 1qk
01100000
11000000
10000010
00000000
00001010
00000100
00000000
00000001
NAME end2 91

TIL 1ql
00000000
00000010
00100011
01000100
00101010
00010100
10111100
01000000
NAME end2 92

TIL 1qm
00000001
00001000
00000110
00000010
00000011
00001011
00101111
00000111
NAME end2 93

TIL 1qn
01000000
10011111
11111111
11101111
01111110
11111111
10111111
01111111
NAME end2 94

TIL 1qo
11111111
11111111
11111111
11111111
11111111
01111101
11001111
00110101
NAME end2 95

TIL 1qp
10111001
11100101
10001010
10010101
11101110
11111101
10001010
10010000
NAME end2 96

TIL 1qq
10000100
01000010
10001000
01000101
00000000
00010101
10000000
10000101
NAME end2 97

TIL 1qr
11000100
00010100
01000000
11000100
00110011
00101101
00000100
00000000
NAME end2 98

TIL 1qs
10000001
10001000
10100000
10000011
00000000
01101010
00011110
00010100
NAME end2 99

TIL 1qt
11111110
10111111
01011010
00111011
10101111
01011110
00011110
00110101
NAME end2 100

TIL 1qu
11111111
11111111
11101111
11111111
11111111
11111111
01111111
11111111
NAME end2 101

TIL 1qv
11111011
11111111
11111111
11111111
11111011
11111110
11111111
11100011
NAME end2 102

TIL 1qw
10111011
11111111
11111111
11111111
10110111
10111111
11011111
01111111
NAME end2 103

TIL 1qx
11111111
11101111
11111111
11111111
11111111
11011011
11110111
10111111
NAME end2 104

TIL 1qy
11101010
11110101
11011100
11011110
11110101
11110110
10010001
11001111
NAME end2 105

TIL 1qz
10000000
00000000
11000100
00101010
10000100
00110011
10000000
00111111
NAME end2 106

TIL 1r0
00011010
00010101
00101010
01010101
00101011
01011111
10111111
01101001
NAME end2 107

TIL 1r1
10101010
01010001
11001000
01010001
10100000
01010001
10000010
11010001
NAME end2 108

TIL 1r2
00101011
01011101
10001010
01010111
00101011
01011100
10000011
01000100
NAME end2 109

TIL 1r3
10110111
11011111
10111111
11111111
11111111
11111011
11110111
11111111
NAME end2 110

TIL 1r4
11111111
10111101
00010101
11110011
10011010
11111001
11110111
11110100
NAME end2 111

TIL 1r5
01100010
10100111
10010000
00000000
11110000
00110111
00100011
01001100
NAME end2 112

TIL 1r6
11001110
00000101
00110100
10100000
00001000
10101000
00100001
00000010
NAME end2 113

TIL 1r7
00000101
00101000
11010000
01110001
00000010
01101000
10000010
00011110
NAME end2 114

TIL 1r8
00111000
10100000
00001001
11101111
00000110
10101100
11110010
10000001
NAME end2 115

TIL 1r9
00110110
01111110
10111011
10100101
00110111
11011011
01010101
00110100
NAME end2 116

TIL 1ra
11111111
11111101
10111101
11011111
01001010
01101011
11001100
11010101
NAME end2 117

TIL 1rb
11110101
11110010
11010111
10011100
01011111
10011111
00100111
11010010
NAME end2 118

TIL 1rc
11101111
11111111
10101111
11111110
10101111
11111111
11111111
11000101
NAME end2 119

TIL 1rd
11111110
11011101
11111111
01111111
11101111
11011111
11101101
10101110
NAME end2 120

TIL 1re
10110010
10110001
11011011
11111100
11111110
11110110
01101101
11010111
NAME end2 121

TIL 1rf
01000000
10100101
00101110
01000100
11000001
01000111
11101001
10101001
NAME end2 122

TIL 1rg
10111111
11011111
01011101
01111111
10111111
11111111
01001011
01111101
NAME end2 123

TIL 1rh
11101000
11110000
11110110
11010000
11001110
10010100
00001000
10100000
NAME end2 124

TIL 1ri
10001101
10100111
11110100
11100001
01100100
10010111
01100110
00011111
NAME end2 125

TIL 1rj
11111011
11101111
10111100
01011111
11111110
01011111
11101111
11110110
NAME end2 126

TIL 1rk
10010110
10111110
01010010
11110101
10110101
11100010
00010001
10000101
NAME end2 127

TIL 1rl
01101010
00010000
00001000
01000110
00100001
01010110
11010000
01100110
NAME end2 128

TIL 1rm
01000010
11000000
00111011
01000111
00000111
10000111
11010111
11000111
NAME end2 129

TIL 1rn
00000101
00101010
11111010
11110001
11110011
11111110
11111111
11111111
NAME end2 130

TIL 1ro
00001010
10110100
00111111
10101001
10010001
01000111
11010100
00010000
NAME end2 131

TIL 1rp
11111011
10001101
11010101
00110000
10000110
01001110
11011110
01110101
NAME end2 132

TIL 1rq
01010110
00100111
11101101
01001110
00111100
00110111
11010101
10111011
NAME end2 133

TIL 1rr
11110100
11110111
11101100
11001110
01001101
01100010
10001110
11100011
NAME end2 134

TIL 1rs
10111010
10110000
01010011
10111101
01000111
01011011
11101001
11110111
NAME end2 135

TIL 1rt
10111101
11110110
11111111
10111001
11110111
01111011
01100101
11110110
NAME end2 136

TIL 1ru
01110111
10011111
11110010
10111111
10111111
01010010
00011111
11101111
NAME end2 137

TIL 1rv
11110000
00111101
11011100
11010100
11011010
01111100
01100111
11111111
NAME end2 138

TIL 1rw
11111010
10110010
10111010
11110100
10111100
10010000
10111000
10110001
NAME end2 139

TIL 1rx
00001000
01110000
00000000
00001000
00100000
01000011
00100010
01000100
NAME end2 140

TIL 1ry
00110111
00011011
01111111
01110111
11111111
00101011
11000101
11001111
NAME end2 141

TIL 1rz
11100111
11110111
11111111
11010011
11111111
11011111
11111111
11110110
NAME end2 142

TIL 1s0
11011100
11011000
01111010
10111001
11011101
11101010
11100011
01111100
NAME end2 143

TIL 1s1
11010011
10101110
10111111
11010110
11110111
01101100
11010001
01001100
NAME end2 144

TIL 1s2
10111111
01011111
11010111
10100111
10010111
00001111
01100111
11000111
NAME end2 145

TIL 1s3
11111111
11111110
11111111
11111110
11111110
11111110
11111110
11111110
NAME end2 146

TIL 1s4
00111101
10001101
10001111
10100101
00010111
11100101
01100000
00111111
NAME end2 147

TIL 1s5
11101010
01011100
10001010
10111111
00111101
11111001
10111011
11011100
NAME end2 148

TIL 1s6
10101011
10010110
11111000
11101011
11011111
11110111
10110101
11011111
NAME end2 149

TIL 1s7
01111110
00010011
00111011
01110001
11111110
10111111
01111111
11101101
NAME end2 150

TIL 1s8
11001001
11110101
01101110
00111000
00111100
01111010
10010010
01000110
NAME end2 151

TIL 1s9
10111010
11111000
11011111
01011110
11011001
11011011
10111010
11011111
NAME end2 152

TIL 1sa
11111111
11111111
01111111
01111111
11111111
10111111
11111111
10111111
NAME end2 153

TIL 1sb
11110010
11111100
01011011
11101100
11111110
11111100
11111111
11100101
NAME end2 154

TIL 1sc
10101010
01000100
11000010
01001100
11100010
01001100
11101010
00000100
NAME end2 155

TIL 1sd
10111111
00110111
00101111
01101111
01011111
11011111
11011101
11111111
NAME end2 156

TIL 1se
11111101
11111111
11111111
11111111
11111111
11111111
11110011
11110111
NAME end2 157

TIL 1sf
10100000
11011110
01110011
01010110
11111100
11111001
11011111
11101111
NAME end2 158

TIL 1sg
10001111
11101110
00101010
11101101
11111111
11111111
11111111
11011110
NAME end2 159

TIL 1sh
01011111
00011111
01001111
11010111
11101111
11110111
01101111
11011111
NAME end2 160

TIL 1si
11111110
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME end2 161

TIL 1sj
10011111
00011101
11111110
11011110
11101011
11111110
11111010
11111111
NAME end2 162

TIL 1sk
11011111
11111111
10111111
11111111
11000111
11010111
11111111
10111111
NAME end2 163

TIL 1sl
01111111
00001011
10101111
01100011
11111101
11111111
11110111
11111111
NAME end2 164

TIL 1sm
10111011
11101110
01111111
11111111
11101101
11111101
11011100
11111100
NAME end2 165

TIL 1sn
00111110
11111111
11111111
11111111
11001111
11111111
11101111
11111101
NAME end2 166

TIL 1so
11110001
10111111
11110111
11110101
11111111
11111111
11111111
11111110
NAME end2 167

TIL 1sp
11111111
11111111
11101111
11111111
11111111
11111111
11111101
11111110
NAME end2 168

TIL 1sq
11111111
11111111
11111111
11111111
11111111
01111111
11111111
11111101
NAME end2 169

TIL 1sr
11111111
11110110
11111110
11111101
11110110
11110100
11011111
01101101
NAME end2 170

TIL 1ss
11110110
11110100
10101011
11011100
10110110
11001111
11110011
11111101
NAME end2 171

TIL 1st
11101011
11110111
10111111
11111111
00111110
00111111
10011110
11101100
NAME end2 172

TIL 1su
11111101
11111111
11111111
11010111
00011111
11110111
10100010
11011110
NAME end2 173

TIL 1sv
11111100
11101111
11111111
01111111
11111101
11111011
11111111
11111011
NAME end2 174

TIL 1sw
11111101
11111111
11110111
11011111
11100011
10111111
10010011
11111111
NAME end2 175

TIL 1sx
10001111
11010111
11011111
01111111
11111111
11110111
11011111
01111111
NAME end2 176

TIL 1sy
11111110
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME end2 177

TIL 1sz
01011111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME end2 178

TIL 1t0
11111101
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME end2 179

TIL 1t1
11110111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME end2 180

TIL 1t2
11110111
11011111
11101111
11101111
11111101
11111111
11111111
11111111
NAME end2 181

TIL 1t3
10001101
01111111
01111111
11111111
10111111
11101011
11111111
11111111
NAME end2 182

TIL 1t4
11111100
11001011
11111111
11011111
10111111
11111110
11111110
11110111
NAME end2 183

TIL 1t5
01111111
11001111
11011001
01111101
11110111
11101011
00111110
01110101
NAME end2 184

TIL 1t6
01011110
00111011
11111101
10101110
01110101
11001001
01110111
11111110
NAME end2 185

TIL 1t7
11011110
11101111
10101010
11111111
11110011
11111100
11111111
10111111
NAME end2 186

TIL 1t8
11100010
10010101
10111111
11101111
01100101
11111101
01111101
11111001
NAME end2 187

TIL 1t9
10011111
10101111
11001111
11101111
11101111
10111111
11011111
11101111
NAME end2 188

TIL 1ta
11111111
11111111
11111100
11111111
11111111
11111110
11111111
11111111
NAME end2 189

TIL 1tb
01110111
11111111
01111111
11111111
11111111
10111011
10111111
01101111
NAME end2 190

TIL 1tc
11111111
01111111
01111111
11111101
11111110
11111111
11111111
11111110
NAME end2 191

TIL 1td
11111111
11111000
11011111
11111111
11111111
11111110
11111111
10111111
NAME end2 192

TIL 1te
11101111
11110111
01111111
10111011
11001111
11011111
11111111
11111111
NAME end2 193

TIL 1tf
11101011
11101111
11111011
11111110
11010111
11111111
11111101
11111111
NAME end2 194

TIL 1tg
11100110
11001101
00111011
11111111
11111111
11111111
11111011
11111111
NAME end2 195

TIL 1th
11111111
00100111
11010111
11011111
11110111
01111111
11111111
10111111
NAME end2 196

TIL 1ti
11111101
11111111
11111110
11111011
11111111
11111111
11111101
11111011
NAME end2 197

TIL 1tj
11011111
11110111
01111101
10111000
11111111
11111110
10111111
01111111
NAME end2 198

TIL 1tk
11111111
11111111
11111101
11000111
11111100
11111010
10001101
11111010
NAME end2 199

TIL 1tl
11111111
11111111
11111101
11111111
11111111
11111111
11111111
11111111
NAME end2 200

TIL 1tm
11111111
11111111
11111111
11111111
10111111
11111111
11111111
11111111
NAME end2 201

TIL 1tn
11111110
11111011
11111111
11111111
11111111
11111111
11111111
11111111
NAME end2 202

TIL 1to
11111111
11111000
11111111
11111111
11111111
11111111
11111111
11111111
NAME end2 203

SPR 10
00000000
00001000
00001000
00001000
01001001
00101010
00011100
00001000
NAME outcab
DLG x
POS 8 7,14

SPR 11
00001000
00011100
00101010
01001001
00001000
00001000
00001000
00000000
NAME intokitchen
DLG y
POS 10 13,13

SPR 12
00001000
00000100
00000010
01111111
00000010
00000100
00001000
00000000
NAME toexit
DLG z
POS 10 14,14

SPR 13
00000000
00111000
01000100
10000010
10011110
10000010
01000100
00111000
NAME microwave
DLG 10
POS 11 14,5

SPR 14
00100000
00000000
10001000
00000001
01000000
00000000
00000100
00010000
>
00000000
00100100
00000000
00100000
00000101
00000000
00100000
00000000
NAME realcrowbar
DLG 12
POS 12 1,5

SPR 15
00000000
00001000
00001000
00001000
01001001
00101010
00011100
00001000
NAME backfromdoorway
DLG 13
POS 12 8,14

SPR 16
00000000
00001000
00001000
00001000
01001001
00101010
00011100
00001000
NAME outkitchen
DLG 14
POS 11 7,14

SPR 17
00001000
00001000
01001001
00101010
00011100
00001000
00000000
00000000
NAME outliveroom
DLG 15
POS 10 13,15

SPR 18
00111100
01000010
01000010
01001110
01011010
01000010
01000010
00111100
NAME finaledoor
DLG 1a
POS 13 9,8

SPR 19
00000000
00111000
01000100
10011010
10000010
10000010
01000100
00111000
NAME dress knob
DLG 8
POS 3 10,10

SPR A
00000000
01110000
10001000
10001000
10001000
01110100
00000010
00000001
POS 0 8,7
ITM 1 1

SPR b
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME nothing
DLG b

SPR c
00011000
00100100
00100100
00001100
00010000
00010000
00000000
00010000
NAME help
DLG 4
POS 3 12,1

SPR d
00111100
01000010
11000011
10100101
10011001
10000001
10000001
11111111
NAME inventory
DLG 5
POS 3 14,1

SPR h
00000000
00001000
00001000
00001000
01001001
00101010
00011100
00001000
NAME back
DLG c
POS 3 7,14

SPR j
00010000
00100000
01000000
11111110
01000000
00100000
00010000
00000000
NAME leftbedroom
DLG e
POS 4 1,2

SPR k
00000000
00001000
00001000
00001000
01001001
00101010
00011100
00001000
NAME backbedroom
DLG d
POS 4 2,3

SPR l
00100000
00110000
00010000
00011110
00100010
10000001
01100001
00011000
NAME faucet
DLG p
POS 7 13,9

SPR m
00000000
00000000
00100000
01010000
01001000
00110000
00000000
00000000
NAME bathroomknob
DLG f
POS 5 13,11

SPR n
00000000
00000000
00000000
00001000
00010100
00010010
00001100
00000000
NAME josiedoor
DLG g
POS 5 0,4

SPR o
00000000
00000000
10001000
01011000
00110000
01100000
11000000
00000000
NAME showerhead
DLG h
POS 7 4,2

SPR q
00000000
00001000
00001000
00001000
01001001
00101010
00011100
00001000
NAME outcage
DLG k
POS 6 7,14

SPR r
00000000
00001000
00001000
00001000
01001001
00101010
00011100
00001000
NAME outbathroom
DLG l
POS 7 7,14

SPR s
00000000
00001000
00001000
00001000
01001001
00101010
00011100
00001000
NAME outhallway
DLG m
POS 5 1,14

SPR t
00001000
00010000
00100000
01111111
00100000
00010000
00001000
00000000
NAME inliveroom
DLG n
POS 5 0,13

SPR u
00000000
00011100
00010000
00011100
00010000
00011100
00010000
00010000
NAME toothburshtop
DLG t
POS 9 5,10

SPR v
00010000
00010000
00010000
00010000
00010000
00010000
00010000
00010000
NAME toothbrush2
DLG t
POS 9 5,11

SPR w
00000000
00000000
00010000
00001000
01111100
00001000
00010000
00000000
>
00000000
00000000
00001000
00000100
00111110
00000100
00001000
00000000
NAME opencab
DLG u
POS 8 10,3

SPR x
00000000
00000000
00001000
00010000
00111110
00010000
00001000
00000000
>
00000000
00000000
00010000
00100000
01111100
00100000
00010000
00000000
NAME closecab
DLG v
POS 9 1,3

SPR y
00010000
00010000
00010000
00010000
00010000
00010000
00010000
00010000
NAME tooth2b
DLG t
POS 8 5,11

SPR z
00000000
00011100
00010000
00011100
00010000
00011100
00010000
00010000
NAME toothbrushb
DLG t
POS 8 5,10

SPR 1a
00000001
00110010
00101100
00111000
01000000
01000000
00111111
00000000
>
00000000
00110000
00101111
00111000
01000000
01000000
00111111
00000000
NAME rat1
DLG 1c
POS 15 7,11

SPR 1b
11100000
00010000
00001000
01000100
10100100
10010100
11111100
00000000
>
00000000
11110000
00001000
01000100
10100100
10010100
11111100
00000000
NAME rat2
DLG 1c
POS 15 8,11

SPR 1c
00011000
00100100
00100100
00001100
00010000
00010000
00000000
00010000
NAME help bedroom
DLG 4
POS 4 12,1

SPR 1d
00011000
00100100
00100100
00001100
00010000
00010000
00000000
00010000
NAME helphall
DLG 4
POS 5 12,1

SPR 1e
00011000
00100100
00100100
00001100
00010000
00010000
00000000
00010000
NAME helpbath
DLG 4
POS 7 12,1

SPR 1f
00011000
00100100
00100100
00001100
00010000
00010000
00000000
00010000
NAME helplive
DLG 4
POS 10 12,1

SPR 1g
00011000
00100100
00100100
00001100
00010000
00010000
00000000
00010000
NAME helpkitch
DLG 4
POS 11 12,1

SPR 1h
00011000
00100100
00100100
00001100
00010000
00010000
00000000
00010000
NAME helpdoor
POS 12 12,1

SPR 1i
00111100
01000010
11000011
10100101
10011001
10000001
10000001
11111111
NAME inventorybed
DLG 5
POS 4 14,1

SPR 1j
00111100
01000010
11000011
10100101
10011001
10000001
10000001
11111111
NAME invenhall
DLG 5
POS 5 14,1

SPR 1k
00111100
01000010
11000011
10100101
10011001
10000001
10000001
11111111
NAME invenbath
DLG 5
POS 7 14,1

SPR 1l
00111100
01000010
11000011
10100101
10011001
10000001
10000001
11111111
NAME invenlife
DLG 5
POS 10 14,1

SPR 1m
00111100
01000010
11000011
10100101
10011001
10000001
10000001
11111111
NAME invenkitch
DLG 5
POS 11 14,1

SPR 1n
00111100
01000010
11000011
10100101
10011001
10000001
10000001
11111111
NAME invendoor
DLG 5
POS 12 14,1

ITM 0
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME nothingitem
DLG 3

ITM 1
00000000
00010000
00010000
00101000
11000110
00101000
00010000
00010000
>
00000000
00010000
00000000
00101000
10010010
00101000
00000000
00010000
NAME dress shine
DLG 7
BLIP 8

ITM 3
00000000
00000000
00000000
11100000
10101010
11111111
00000000
00000000
NAME keys
DLG a
BLIP 4

ITM 4
00000000
00010000
00010000
00101000
11000110
00101000
00010000
00010000
>
00000000
00010000
00000000
00101000
10010010
00101000
00000000
00010000
NAME cagefirst
DLG i
BLIP 3

ITM 5
00000000
00010000
00010000
00101000
11000110
00101000
00010000
00010000
>
00000000
00010000
00000000
00101000
10010010
00101000
00000000
00010000
NAME toiletint
DLG o
BLIP 8

ITM 6
00000000
00010000
00010000
00101000
11000110
00101000
00010000
00010000
>
00000000
00010000
00000000
00101000
10010010
00101000
00000000
00010000
NAME decor
DLG q
BLIP 8

ITM 7
00000000
00010000
00010000
00101000
11000110
00101000
00010000
00010000
>
00000000
00010000
00000000
00101000
10010010
00101000
00000000
00010000
NAME window
DLG r
BLIP 8

ITM 8
00000000
00010000
00010000
00101000
11000110
00101000
00010000
00010000
>
00000000
00010000
00000000
00101000
10010010
00101000
00000000
00010000
NAME certinfo
DLG s
BLIP 8

ITM 9
00000000
00111100
01000010
01111110
00100100
00100100
00100100
00111100
NAME meds
DLG w
BLIP 4

ITM a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM b
00000000
01001001
00100000
10000100
00000010
01001000
00010000
00000010
>
00000000
00000010
01001001
00000000
10100100
00000000
00001010
00100000
NAME fooood
DLG 11
BLIP 4

ITM c
00000000
00010000
00010000
00101000
11000110
00101000
00010000
00010000
>
00000000
00010000
00000000
00101000
10010010
00101000
00000000
00010000
NAME sinkmat
DLG 16
BLIP 8

ITM d
00000000
00010000
00010000
00101000
11000110
00101000
00010000
00010000
>
00000000
00010000
00000000
00101000
10010010
00101000
00000000
00010000
NAME window
DLG 17
BLIP 8

ITM e
00000000
00010000
00101000
01000100
10000010
10000100
01001000
00110000
NAME paper
DLG 18
BLIP 4

ITM f
00000000
00010000
00010000
00101000
11000110
00101000
00010000
00010000
>
00000000
00010000
00000000
00101000
10010010
00101000
00000000
00010000
NAME futon
DLG 19
BLIP 8

ITM g
00000000
00010000
00010000
00101000
11000110
00101000
00010000
00010000
>
00000000
00010000
00000000
00101000
10010010
00101000
00000000
00010000
NAME cage2nd
DLG 1b

ITM h
00000000
01101100
10010010
10000010
01000100
01000100
00101000
00010000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME end item
DLG 1d

DLG 3
we all have to find some way to make ends meet, right?{pg}i don't know if i say that to make myself feel better or if i actually believe it{pg}don't think i believe in much of anything anymore
NAME exit narration 1

DLG 4
"""
{
  - firsthelp == 0 ?
    it's 5am. nearly time for work.{pg}{firsthelp = 1}
}{
  - everythinggot == 6 ?
    i'm ready to go.
}{shuffle
  - {
      - {item "3"} == 0 ?
        i still need to get my housekeys
    }
  - {
      - {item "9"} == 0 ?
        i still need to take my medication
    }
  - {
      - brushed == 0 ?
        i still need to brush my teeth
    }
  - {
      - fed == 0 ?
        i still need to eat something
    }
  - {
      - dressed == 0 ?
        i still need to get dressed
    }
}
"""
NAME help dialog

DLG 5
"""
i am carrying:{pg}{
  - {item "3"} == 1 ?
    my keys{pg}
  - else ?
    {not = not + 1}
}{
  - {item "b"} == 1 ?
    a slice of cold pizza{pg}
  - else ?
    {not = not + 1}
}{
  - {item "e"} == 1 ?
    an old college paper{pg}
  - else ?
    {not = not + 1}
}{
  - not == 3 ?
    nothing
}{not = 0}
"""
NAME inventory dialog

DLG 7
lord, i've had this thing since middle school{pg}free poster they gave away at space camp back then. my mom got it framed.{pg}i can't bring myself to throw it away no matter how faded it is.{secretprog = secretprog + 1}
NAME dress shine dialog

DLG 8
"""
{
  - a == 1 ?
    {
      - dressed == 1 ?
        {blip "wrong"}i'm already dressed
      - else ?
        {blip "pick up"}better get dressed before i'm late for work{dressed = 1}{everythinggot = everythinggot + 1}{exit "3" 8 8 "fade_w"}
    }
  - else ?
    {blip "wrong"}i haven't showered yet. i can't get dressed like this.
}
"""
NAME dress knob dialog

DLG 9

NAME nothingitem dialog

DLG 10
"""
{
  - {item "b"} == 0 ?
    {blip "wrong"}am i really going to turn on the microwave with nothing in it?
  - else ?
    {wvy}...{/wvy}{blip "microbeep"}{blip "microbeep"}{pg}perfectly serviceable pizza!{item "b" 0}{fed = 1}{everythinggot = everythinggot + 1}
}
"""
NAME microwave dialog

DLG 11
let's see...{pg}look's like all we've got is pizza from the other night{pg}i probably still have time to heat it up
NAME fooood dialog

DLG 12
"""
REN-issued crowbar for{pg}...{pg}"particularly disobedient inventory"{pg}{
  - everythinggot == 6 ?
    {pg}i'm ready to head out.{pg}{
      - secretprog == 10 ?
        {blip "9"}...hey, what's that noise in the hallway?{exit "14" 8 8 "wave"}
      - else ?
        {exit "13" 8 8 "wave"}
    }
  - else ?
    don't need to grab that until i'm ready to leave
}
"""
NAME crowbar dialog

DLG 13
{exit "10" 8 8 "fade_b"}
NAME backfromdoorway dialog

DLG 14
{exit "10" 8 8 "fade_b"}
NAME outkitchen dialog

DLG 15
{exit "5" 8 8 "fade_b"}
NAME outliveroom dialog

DLG 16
it's a novelty christmas bathmat{pg}yes, it's august{secretprog = secretprog + 1}
NAME sinkmat dialog

DLG 17
forecast called for 86 degrees{pg}lots of sunshine{pg}hope that's hot enough for my supervisor to actually{pg}y'know{pg}turn on the ac{secretprog = secretprog + 1}
NAME window dialog 1

DLG 18
this is where the tv was before--{pg}hey, wait a minute{pg}it's an old paper i wrote in college{pg}"mars for the rich: REN's intergalactic colonization and potential ramifications" {pg}what a nerd!{pg}...{pg}what a nerd...{secretprog = secretprog + 1}
NAME paper dialog

DLG 19
the couch folds out into a bed{pg}the listing for this place said "3 bedrooms" when we got the lease{pg}{wvy}shockingly{/wvy}, roommate applications ghost josie and i when they learn where they'll be sleeping{secretprog = secretprog + 1}
NAME futon dialog

DLG a
can't forget to lock the door on my way out{pg}last time josie forgot to, someone took our tv{pg}i still think it was her ex.{everythinggot = everythinggot + 1}
NAME keys dialog

DLG b

NAME nothing dialog

DLG c
{exit "4" 8 8 "fade_b"}
NAME back dialog

DLG d
{exit "3" 8 8 "fade_b"}
NAME backbedroom dialog

DLG e
{exit "5" 8 8 "fade_b"}
NAME leftbedroom dialog

DLG f
{exit "7" 8 8 "fade_b"}
NAME sprite m dialog

DLG g
{blip "wrong"}my roommate josie's room.{pg}she's probably still sleeping.
NAME josiedoor dialog

DLG h
"""
{
  - a == 0 ?
    {blip "pick up"}i'm super sore and smell awful. i should probably shower{pg}{wvy}...{/wvy}{blip "6"}{pg}...that's better{a = 1}{everythinggot = everythinggot + 1}
  - else ?
    {blip "wrong"}no need to shower twice
}
"""
NAME showerhead dialog

DLG i
{exit "6" 8 8 "fade_b"}i used to have a pet rat{pg}i loved him{pg}...i should really sell this at some point.{secretprog = secretprog + 1}
NAME gotocage dialog

DLG k
{exit "5" 8 8 "fade_b"}
NAME outcage dialog

DLG l
{exit "5" 8 8 "fade_b"}
NAME outbathroom dialog

DLG m
{exit "4" 8 8 "fade_b"}
NAME outhallway dialog

DLG n
{exit "10" 8 8 "fade_b"}
NAME inliveroom dialog

DLG o
landlord replaced the toilet not too long ago{pg}we're {wvy}so{/wvy} not getting our deposit back, are we{secretprog = secretprog + 1}
NAME item 5 dialog

DLG p
{exit "8" 8 8 "fade_b"}
NAME faucet dialog

DLG q
a pendant flag...thing, from my university days{pg}it's only a little torn up{secretprog = secretprog + 1}
NAME item 6 dialog

DLG r
ugh. i thought the paint would be enough to hide the water damage{pg}...think this'll effect getting my deposit back?{secretprog = secretprog + 1}
NAME window dialog

DLG s
"operations in logistics and solutions certificate"{pg}do any of those words mean anything put together like that{pg}my job gave me this. i don't really care but josie thought i should hang it up{pg}i guess it proves i've accomplished {wvy}something{/wvy}{secretprog = secretprog + 1}
NAME item 8 dialog

DLG t
"""
{
  - brushed == 0 ?
    mom said if you don't brush your teeth they'll all fall out{pg}{wvy}...{/wvy}{blip "6"}wouldn't want that!{brushed = 1}{everythinggot = everythinggot + 1}
  - else ?
    i don't have all day to brush my teeth over and over
}
"""
NAME toothburshtop dialog

DLG u
{exit "9" 8 8 "slide_l"}
NAME opencab dialog

DLG v
{exit "8" 8 8 "slide_r"}
NAME closecab dialog

DLG w
dang. last pill{pg}nearest doctor's office closes at 3pm. my shift wraps up at 5.{pg}whatever.{everythinggot = everythinggot + 1}
NAME meds dialog

DLG x
{exit "7" 8 8 "fade_b"}
NAME outcab dialog

DLG y
{exit "11" 8 8 "fade_b"}
NAME intokitchen dialog

DLG z
{exit "12" 8 8 "fade_b"}
NAME toexit dialog

DLG 1a
here goes nothing{pg}another day{pg}{wvy}another...{/wvy}{pg}{wvy}ugh{/wvy}{exit "18" 8 8 "wave"}{pg}...do i smell smoke....?{exit "17" 8 8 "fade_b"}
NAME finaledoor dialog

DLG 1b
{blip "uh oh"}{exit "15" 8 8 "tunnel"}
NAME cage2nd dialog

DLG 1c
it's my old pet rat...{pg}how is he{pg}what is{pg}{shk}how{/shk}{pg}{exit "13" 8 8 "wave"}{pal "1"}
NAME rat2 dialog

DLG 1d
...that's...{pg}...that's the REN warehouse...{pg}{wvy}...that's my job{/wvy}{pg}{wvy}...did i really give up everything...{/wvy}{pg}{wvy}...just for it all to go up in flames?{/wvy}{pg}...{pg}...did i?{pg}...{end}the end{tune "1"}
NAME item h dialog

VAR brushed
0

VAR fed
0

VAR everythinggot
0

VAR dressed
0

VAR secretprog
0

VAR firsthelp
0

VAR not
0

TUNE 4
2C,0,2D,0,2F,0,2D,0,2D#,0,3G,0,0,D,2C,0
16C2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME rattune
TMP SLW
SQR P8 P4

TUNE 5
t,s,d5,0,l,2t,0,s,l,0,2t,0,d5,l,t,d5
16l2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
d5,4l,0,0,0,t,d5,t,d5,t,3s,0,0,l,t,d5
16l2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME action
KEY C,D,E,F,G,A,B d,r,m,f,s,l,t
TMP MED
SQR P4 P2
ARP INT5

TUNE 6
d,r,4d,0,0,0,r,r,4d,0,0,0,d,r,d,d
16f2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME title
KEY C,D,D#,F,G,G#,A# d,r,m,f,s,l,t
TMP SLW
SQR P2 P4
ARP UP

TUNE 7
4d,0,0,0,4r,0,0,0,4f,0,0,0,0,r,m,d
16d2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME interest
KEY C,D,D#,F,G,G#,A# d,r,m,f,s,l,t
TMP MED
SQR P2 P4
ARP UP

TUNE 8
4m,0,0,0,4s,0,0,0,4t,0,0,0,0,l,t,s
16d2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME interestdynamo
KEY C,D,D#,F,G,G#,A# d,r,m,f,s,l,t
TMP MED
SQR P2 P4
ARP UP

TUNE 9
2d,0,3r,0,0,2d,0,4m,0,0,0,2r,0,3d,0,0
16d2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME vinale
KEY C,D,D#,F,G,G#,A# d,r,m,f,s,l,t
TMP SLW
SQR P2 P8
ARP DWN

BLIP 3
D#2,D2,F3
NAME uh oh
ENV 233 145 5 175 191
BEAT 79 77
SQR P4
RPT 1

BLIP 4
D#2,B2,C
NAME pick up
ENV 117 107 3 173 66
BEAT 54 0
SQR P8

BLIP 5
F2,F2,C#
NAME wrong
ENV 78 90 4 174 155
BEAT 85 0
SQR P8

BLIP 6
F#,E5,C#5
NAME showering
ENV 432 19 10 363 336
BEAT 75 365
SQR P2

BLIP 7
D#,D#,D#
NAME microbeep
ENV 10 61 8 266 45
BEAT 0 0
SQR P8

BLIP 8
D3,B3,G#5
NAME lore
ENV 219 150 7 252 195
BEAT 32 140
SQR P2
RPT 1

BLIP 9
B,F#,F#
NAME ratnoise
ENV 75 109 6 160 95
BEAT 95 0
SQR P8


</script>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:0px;
	overflow:hidden;
	background:#ffffff;
}

#game {
	background:black;
	width:100vw;
	max-width:100vh;
	margin:auto;
	display:block;
}
</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	var gameCanvas = document.getElementById("game");
	var gameData = document.getElementById("exportedGameData").text.slice(1);
	var defaultFontData = document.getElementById(defaultFontName).text.slice(1);
	loadGame(gameCanvas, gameData, defaultFontData);
	initSystem();
}
</script>

<!-- system -->
<script>
function InputSystem() {
	var self = this;

	this.Key = {
		LEFT: 37,
		RIGHT: 39,
		UP: 38,
		DOWN: 40,
		SPACE: 32,
		ENTER: 13,
		W: 87,
		A: 65,
		S: 83,
		D: 68,
		R: 82,
		SHIFT: 16,
		CTRL: 17,
		ALT: 18,
		CMD: 224
	};

	var pressed;
	var ignored;
	var touchState;

	var isRestartComboPressed = false;

	var SwipeDir = {
		None : -1,
		Up : 0,
		Down : 1,
		Left : 2,
		Right : 3,
	};

	function resetAll() {
		isRestartComboPressed = false;

		pressed = {};
		ignored = {};

		touchState = {
			isDown : false,
			startX : 0,
			startY : 0,
			curX : 0,
			curY : 0,
			swipeDistance : 30,
			swipeDirection : SwipeDir.None,
			tapReleased : false
		};
	}

	resetAll();

	function stopWindowScrolling(e) {
		if (e.keyCode == self.Key.LEFT || e.keyCode == self.Key.RIGHT || e.keyCode == self.Key.UP || e.keyCode == self.Key.DOWN || !isPlayerEmbeddedInEditor) {
			e.preventDefault();
		}
	}

	function isRestartCombo(e) {
		return (e.keyCode === self.Key.R && (e.getModifierState("Control")|| e.getModifierState("Meta")));
	}

	function eventIsModifier(event) {
		return (event.keyCode == self.Key.SHIFT || event.keyCode == self.Key.CTRL || event.keyCode == self.Key.ALT || event.keyCode == self.Key.CMD);
	}

	function isModifierKeyDown() {
		return (self.isKeyDown(self.Key.SHIFT) || self.isKeyDown(self.Key.CTRL) || self.isKeyDown(self.Key.ALT) || self.isKeyDown(self.Key.CMD));
	}

	this.ignoreHeldKeys = function() {
		for (var key in pressed) {
			if (pressed[key]) { // only ignore keys that are actually held
				ignored[key] = true;
				// bitsyLog("IGNORE -- " + key, "system");
			}
		}
	}

	this.onkeydown = function(event) {
		enableGlobalAudioContext();
		// bitsyLog("KEYDOWN -- " + event.keyCode, "system");

		stopWindowScrolling(event);

		isRestartComboPressed = isRestartCombo(event);

		// Special keys being held down can interfere with keyup events and lock movement
		// so just don't collect input when they're held
		{
			if (isModifierKeyDown()) {
				return;
			}

			if (eventIsModifier(event)) {
				resetAll();
			}
		}

		if (ignored[event.keyCode]) {
			return;
		}

		pressed[event.keyCode] = true;
		ignored[event.keyCode] = false;
	}

	this.onkeyup = function(event) {
		// bitsyLog("KEYUP -- " + event.keyCode, "system");
		pressed[event.keyCode] = false;
		ignored[event.keyCode] = false;

		isRestartComboPressed = false;
	}

	this.ontouchstart = function(event) {
		enableGlobalAudioContext();

		event.preventDefault();

		if( event.changedTouches.length > 0 ) {
			touchState.isDown = true;

			touchState.startX = touchState.curX = event.changedTouches[0].clientX;
			touchState.startY = touchState.curY = event.changedTouches[0].clientY;

			touchState.swipeDirection = SwipeDir.None;
		}
	}

	this.ontouchmove = function(event) {
		event.preventDefault();

		if( touchState.isDown && event.changedTouches.length > 0 ) {
			touchState.curX = event.changedTouches[0].clientX;
			touchState.curY = event.changedTouches[0].clientY;

			var prevDirection = touchState.swipeDirection;

			if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Left;
			}
			else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Right;
			}
			else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Up;
			}
			else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Down;
			}

			if( touchState.swipeDirection != prevDirection ) {
				// reset center so changing directions is easier
				touchState.startX = touchState.curX;
				touchState.startY = touchState.curY;
			}
		}
	}

	this.ontouchend = function(event) {
		event.preventDefault();

		touchState.isDown = false;

		if( touchState.swipeDirection == SwipeDir.None ) {
			// tap!
			touchState.tapReleased = true;
		}

		touchState.swipeDirection = SwipeDir.None;
	}

	this.isKeyDown = function(keyCode) {
		return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
	}

	this.anyKeyDown = function() {
		var anyKey = false;

		for (var key in pressed) {
			if (pressed[key] && (ignored[key] == null || ignored[key] == false) &&
				!(key === self.Key.UP || key === self.Key.DOWN || key === self.Key.LEFT || key === self.Key.RIGHT) &&
				!(key === self.Key.W || key === self.Key.S || key === self.Key.A || key === self.Key.D)) {
				// detected that a key other than the d-pad keys are down!
				anyKey = true;
			}
		}

		return anyKey;
	}

	this.isRestartComboPressed = function() {
		return isRestartComboPressed;
	}

	this.swipeLeft = function() {
		return touchState.swipeDirection == SwipeDir.Left;
	}

	this.swipeRight = function() {
		return touchState.swipeDirection == SwipeDir.Right;
	}

	this.swipeUp = function() {
		return touchState.swipeDirection == SwipeDir.Up;
	}

	this.swipeDown = function() {
		return touchState.swipeDirection == SwipeDir.Down;
	}

	this.isTapReleased = function() {
		return touchState.tapReleased;
	}

	this.resetTapReleased = function() {
		touchState.tapReleased = false;
	}

	this.onblur = function() {
		// bitsyLog("~~~ BLUR ~~", "system");
		resetAll();
	}

	this.resetAll = resetAll;

	this.listen = function(canvas) {
		document.addEventListener('keydown', self.onkeydown);
		document.addEventListener('keyup', self.onkeyup);

		if (isPlayerEmbeddedInEditor) {
			canvas.addEventListener('touchstart', self.ontouchstart, {passive:false});
			canvas.addEventListener('touchmove', self.ontouchmove, {passive:false});
			canvas.addEventListener('touchend', self.ontouchend, {passive:false});
		}
		else {
			// creates a 'touchTrigger' element that covers the entire screen and can universally have touch event listeners added w/o issue.

			// we're checking for existing touchTriggers both at game start and end, so it's slightly redundant.
			var existingTouchTrigger = document.querySelector('#touchTrigger');

			if (existingTouchTrigger === null) {
				var touchTrigger = document.createElement("div");
				touchTrigger.setAttribute("id","touchTrigger");

				// afaik css in js is necessary here to force a fullscreen element
				touchTrigger.setAttribute(
					"style","position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden;"
				);

				document.body.appendChild(touchTrigger);

				touchTrigger.addEventListener('touchstart', self.ontouchstart);
				touchTrigger.addEventListener('touchmove', self.ontouchmove);
				touchTrigger.addEventListener('touchend', self.ontouchend);
			}
		}

		window.onblur = self.onblur;
	}

	this.unlisten = function(canvas) {
		document.removeEventListener('keydown', self.onkeydown);
		document.removeEventListener('keyup', self.onkeyup);

		if (isPlayerEmbeddedInEditor) {
			canvas.removeEventListener('touchstart', self.ontouchstart);
			canvas.removeEventListener('touchmove', self.ontouchmove);
			canvas.removeEventListener('touchend', self.ontouchend);
		}
		else {
			//check for touchTrigger and removes it

			var existingTouchTrigger = document.querySelector('#touchTrigger');

			if (existingTouchTrigger !== null) {
				existingTouchTrigger.removeEventListener('touchstart', self.ontouchstart);
				existingTouchTrigger.removeEventListener('touchmove', self.ontouchmove);
				existingTouchTrigger.removeEventListener('touchend', self.ontouchend);

				existingTouchTrigger.parentElement.removeChild(existingTouchTrigger);
			}
		}

		window.onblur = null;
	}
}
</script>

<script>
// init global audio context
var audioContext = new AudioContext();

function enableGlobalAudioContext() {
	audioContext.resume();
}

function SoundSystem() {
	var self = this;

	// volume
	var maxGain = 0.15;

	// curves for different pulse wave duties (ratios between on and off)
	var dutyCycle_1_8 = new Float32Array(256);
	for (var i = 0; i < 256; i++) {
		dutyCycle_1_8[i] = ((i / 256) * 2) - 1.75;
	}

	var dutyCycle_1_4 = new Float32Array(256);
	for (var i = 0; i < 256; i++) {
		dutyCycle_1_4[i] = ((i / 256) * 2) - 1.5;
	}

	var dutyCycle_1_2 = new Float32Array(256);
	for (var i = 0; i < 256; i++) {
		dutyCycle_1_2[i] = ((i / 256) * 2) - 1.0;
	}

	var dutyCycles = [
		dutyCycle_1_8,
		dutyCycle_1_4,
		dutyCycle_1_2 // square wave
	];

	function createPulseWidthModulator() {
		// the base oscillator: start with a sawtooth wave that we'll shape into a pulse wave
		var oscillator = audioContext.createOscillator();
		oscillator.type = "sawtooth";

		// create a gain node to control the volume of the sound
		var volumeControl = audioContext.createGain();
		volumeControl.gain.value = 0;

		// create a wave shaper that turns the sawtooth wave into a pulse
		// by mapping any negative value to -1 and any positive value to 1
		var pulseCurve = new Float32Array(256);
		for (var i = 0; i < 128; i++) {
			pulseCurve[i] = -1;
		}
		for (var i = 128; i < 256; i++) {
			pulseCurve[i] = 1;
		}

		var pulseShaper = audioContext.createWaveShaper();
		pulseShaper.curve = pulseCurve;

		var dutyShaper = audioContext.createWaveShaper();
		dutyShaper.curve = dutyCycle_1_2;

		oscillator.connect(dutyShaper);
		dutyShaper.connect(pulseShaper);
		pulseShaper.connect(volumeControl);
		volumeControl.connect(audioContext.destination);
		oscillator.start();

		return {
			oscillator: oscillator,
			volumeControl: volumeControl,
			dutyShaper: dutyShaper
		};
	}

	var pulseChannels = [createPulseWidthModulator(), createPulseWidthModulator()];

	this.setPulse = function(channel, pulse) {
		var pulseChannel = pulseChannels[channel];
		pulseChannel.dutyShaper.curve = dutyCycles[pulse];
	}

	this.setFrequency = function(channel, frequencyHz) {
		var pulseChannel = pulseChannels[channel];
		// set frequency in hertz
		pulseChannel.oscillator.frequency.setValueAtTime(frequencyHz, audioContext.currentTime);
	}

	this.setVolume = function(channel, volumeNorm) {
		var pulseChannel = pulseChannels[channel];
		pulseChannel.volumeControl.gain.value = volumeNorm * maxGain;
	}

	this.mute = function() {
		for (var i = 0; i < pulseChannels.length; i++) {
			pulseChannels[i].volumeControl.gain.value = 0;
		}
	}
}

var sound = new SoundSystem();
</script>

<script>
function GraphicsSystem() {
	var self = this;

	var canvas;
	var ctx;

	var scale;
	var textScale;
	var palette = [];
	var images = [];
	var imageFillColors = [];

	function makeFillStyle(color, isTransparent) {
		var i = color * 3;
		if (isTransparent) {
			return "rgba(" + palette[i + 0] + "," + palette[i + 1] + "," + palette[i + 2] + ", 0)";
		}
		else {
			return "rgb(" + palette[i + 0] + "," + palette[i + 1] + "," + palette[i + 2] + ")";
		}
	}

	this._images = images;
	this._getPalette = function() {
		return palette;
	};

	// todo : do I really need to pass in size here?
	this.attachCanvas = function(c, size) {
		canvas = c;
		canvas.width = size * scale;
		canvas.height = size * scale;
		ctx = canvas.getContext("2d");
	};

	this.getCanvas = function() {
		return canvas;
	};

	this.getContext = function() {
		return ctx;
	};

	this.setScale = function(s) {
		scale = s;
	};

	this.setTextScale = function(s) {
		textScale = s;
	};

	this.getTextScale = function() {
		return textScale;
	};

	this.setPalette = function(p) {
		palette = p;
	};

	// todo : rename this since it doesn't always create a totally new canvas?
	this.createImage = function(id, width, height, pixels, useTextScale) {
		var imageScale = useTextScale === true ? textScale : scale;
		var widthScaled = width * imageScale;
		var heightScaled = height * imageScale;

		// try to use an existing image canvas if it is the right size,
		// instead of expensively creating a new one
		var imageCanvas = images[id];
		if (imageCanvas === undefined || imageCanvas.width != widthScaled || imageCanvas.height != heightScaled) {
			imageCanvas = document.createElement("canvas");
			imageCanvas.width = widthScaled;
			imageCanvas.height = heightScaled;
		}

		var imageCtx = imageCanvas.getContext("2d");

		// if we know the fill color for this image, we can speed things up
		// by filling the whole image with that color
		var fillColor;
		if (imageFillColors[id] != undefined) {
			fillColor = imageFillColors[id];
			var isTransparent = (fillColor === 0);
			if (isTransparent) {
				imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
			}
			else {
				imageCtx.fillStyle = makeFillStyle(fillColor, isTransparent);
				imageCtx.fillRect(0, 0, imageCanvas.width, imageCanvas.height);
			}
		}

		for (var i = 0; i < pixels.length; i++) {
			var x = i % width;
			var y = Math.floor(i / width);
			var color = pixels[i];
			if (color != fillColor) {
				var isTransparent = (color === 0);
				imageCtx.fillStyle = makeFillStyle(color, isTransparent);
				imageCtx.fillRect(x * imageScale, y * imageScale, imageScale, imageScale);
			}
		}

		images[id] = imageCanvas;
	};

	this.setImageFill = function(id, color) {
		imageFillColors[id] = color;
	};

	this.drawImage = function(id, x, y, destId) {
		if (!images[id]) {
			bitsyLog("image doesn't exist: " + id, "graphics");
			return;
		}

		var destCtx = ctx;
		if (destId != undefined) {
			// if there's a destination ID, that means we're drawing this image *onto* another image canvas
			var destCanvas = images[destId];
			destCtx = destCanvas.getContext("2d");
		}

		destCtx.drawImage(images[id], x * scale, y * scale, images[id].width, images[id].height);
	};

	this.hasImage = function(id) {
		return images[id] != undefined;
	};

	this.getImage = function(id) {
		return images[id];
	};

	this.deleteImage = function(id) {
		delete images[id];
		delete imageFillColors[id];
	};

	this.getCanvas = function() {
		return canvas;
	};

	this.clearCanvas = function(color) {
		bitsyLog("pal? " + palette.length + " / " + color, "graphics");
		ctx.fillStyle = makeFillStyle(color);
		ctx.fillRect(0, 0, canvas.width, canvas.height);
	};
}
</script>

<script>
/* LOGGING */
var DebugLogCategory = {
	// system
	input: false,
	sound: false,
	graphics: false,
	system: false,

	// engine
	bitsy: false,

	// editor
	editor: false,

	// tools
	room: false,
	tune: false,
	blip: false,
};

var isLoggingVerbose = false;

function bitsyLog(message, category) {
	if (!category) {
		category = "bitsy";
	}

	var summary = category + "::" + message;

	if (DebugLogCategory[category] === true) {
		if (isLoggingVerbose) {
			console.group(summary);

			console.dir(message);

			console.group("stack")
			console.trace();
			console.groupEnd();

			console.groupEnd();
		}
		else {
			console.log(summary);
		}
	}
}

/* GLOBALS */
var tilesize = 8;
var mapsize = 16;
var width = mapsize * tilesize;
var height = mapsize * tilesize;
var scale = 4;
var textScale = 2;

/* SYSTEM */
var updateInterval = null;
var prevTime = 0;
var deltaTime = 0;

function initSystem() {
	prevTime = Date.now();
	updateInterval = setInterval(updateSystem, 16);
}

function updateSystem() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	// update all active processes
	for (var i = 0; i < processes.length; i++) {
		bitsy = processes[i].system;
		if (bitsy._active) {
			bitsyLog(bitsy._name + " img count: " + bitsy._graphics._images.length, "system");
			var shouldContinue = bitsy._update(deltaTime);
			if (!shouldContinue) {
				// todo : do I really care about this _exit thing?
				if (bitsy._name != "bitsy") {
					bitsy._exit();
				}
			}
		}
	}

	bitsy = mainProcess.system;
	prevTime = curTime;
}

function loadGame(canvas, gameData, defaultFontData) {
	bitsyLog("load!", "system");
	// initialize bitsy system
	bitsy._attachCanvas(canvas);
	bitsy._write(bitsy._gameDataBlock, gameData);
	bitsy._write(bitsy._fontDataBlock, defaultFontData);
	bitsy._start();
}

function quitGame() {
	// hack to press the menu button to force game over state
	bitsy._injectPreLoop = function() { bitsy._poke(bitsy._buttonBlock, bitsy.BTN_MENU, 1); };

	// one last update to clean up (a little hacky to do this here?)
	bitsy._update(0);
	bitsy._exit();

	// clean up this gross hack
	bitsy._injectPreLoop = null;
}

/* GRAPHICS */
var canvas; // can I get rid of these?
var ctx;

function attachCanvas(c) {
	// hack : tes tnew system
	bitsy._attachCanvas(c);
	// extra hacky
	canvas = bitsy._getCanvas();
	ctx = bitsy._getContext();
}

/* PROCESSES */
var processes = [];

function addProcess(name) {
	var proc = {};
	proc.system = new BitsySystem(name);

	processes.push(proc);

	return proc;
}

/* == SYSTEM v0.2 === */
function BitsySystem(name) {
	var self = this;

	if (!name) {
		name = "bitsy";
	}

	// memory
	var memory = {
		blocks: [],
		changed: []
	};

	// input
	var input = new InputSystem();

	// sound
	var sound = new SoundSystem();
	var soundDurationIndex = 0;
	var soundFrequencyIndex = 1;
	var soundVolumeIndex = 2;
	var soundPulseIndex = 3;
	var maxVolume = 15;

	// graphics
	var graphics = new GraphicsSystem();
	graphics.setScale(scale);
	graphics.setTextScale(textScale);
	var initialPaletteSize = 64;
	var tilePoolStart = null;
	var tilePoolSize = 512;
	// hack!!! (access for debugging)
	this._graphics = graphics;

	function updateTextScale() {
		// make sure the text scale matches the text mode
		var textMode = self._peek(modeBlock, 1);
		var textModeScale = (textMode === self.TXT_LOREZ) ? scale : textScale;
		if (graphics.getTextScale() != textModeScale) {
			graphics.setTextScale(textModeScale);
			memory.changed[self.TEXTBOX] = true;
		}
	}

	function updateInput() {
		// update input flags
		self._poke(self._buttonBlock, self.BTN_UP,
			(input.isKeyDown(input.Key.UP) || input.isKeyDown(input.Key.W) || input.swipeUp()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_DOWN,
			(input.isKeyDown(input.Key.DOWN) || input.isKeyDown(input.Key.S) || input.swipeDown()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_LEFT,
			(input.isKeyDown(input.Key.LEFT) || input.isKeyDown(input.Key.A) || input.swipeLeft()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_RIGHT,
			(input.isKeyDown(input.Key.RIGHT) || input.isKeyDown(input.Key.D) || input.swipeRight()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_OK,
			(input.anyKeyDown() || input.isTapReleased()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_MENU,
			(input.isRestartComboPressed()) ? 1 : 0);

		input.resetTapReleased();
	}

	function updateSound(dt) {
		var changed0 = memory.changed[self.SOUND1];
		var changed1 = memory.changed[self.SOUND2];

		// update sound channel timers
		var timer0 = self._peek(self.SOUND1, soundDurationIndex);
		timer0 -= dt;
		if (timer0 <= 0) {
			timer0 = 0;
			if (self._peek(self.SOUND1, soundVolumeIndex) > 0) {
				self._poke(self.SOUND1, soundVolumeIndex, 0);
				changed0 = true;
			}
		}
		self._poke(self.SOUND1, soundDurationIndex, timer0);

		var timer1 = self._peek(self.SOUND2, soundDurationIndex);
		timer1 -= dt;
		if (timer1 <= 0) {
			timer1 = 0;
			if (self._peek(self.SOUND2, soundVolumeIndex) > 0) {
				self._poke(self.SOUND2, soundVolumeIndex, 0);
				changed1 = true;
			}
		}
		self._poke(self.SOUND2, soundDurationIndex, timer1);

		// send updated channel attributes to the sound system
		if (changed0) {
			sound.setPulse(0, self._peek(self.SOUND1, soundPulseIndex));

			var freq = self._peek(self.SOUND1, soundFrequencyIndex);
			var freqHz = freq / 100;
			sound.setFrequency(0, freqHz);

			var volume = self._peek(self.SOUND1, soundVolumeIndex);
			volume = Math.max(0, Math.min(volume, maxVolume));
			volumeNorm = (volume / maxVolume);
			sound.setVolume(0, volumeNorm);
		}

		if (changed1) {
			sound.setPulse(1, self._peek(self.SOUND2, soundPulseIndex));

			var freq = self._peek(self.SOUND2, soundFrequencyIndex);
			var freqHz = freq / 100;
			sound.setFrequency(1, freqHz);

			var volume = self._peek(self.SOUND2, soundVolumeIndex);
			volume = Math.max(0, Math.min(volume, maxVolume));
			volumeNorm = (volume / maxVolume);
			sound.setVolume(1, volumeNorm);
		}
	}

	function updateGraphics() {
		if (self._enableGraphics === false) {
			return;
		}

		bitsyLog("update graphics", "system");

		if (memory.changed[paletteBlock]) {
			graphics.setPalette(self._dump()[paletteBlock]);
		}

		if (tilePoolStart != null) {
			for (var i = 0; i < tilePoolSize; i++) {
				var tile = tilePoolStart + i;
				if (memory.blocks[tile] != undefined && memory.changed[tile]) {
					bitsyLog("tile changed? " + tile, "system");
					// update tile image
					graphics.createImage(tile, self.TILE_SIZE, self.TILE_SIZE, self._dump()[tile]);
				}
			}
		}

		var textboxChanged = memory.changed[self.TEXTBOX] || memory.changed[textboxAttributeBlock];
		if (textboxChanged) {
			// todo : should this be optimized in some way?
			// update textbox image
			var w = self._peek(textboxAttributeBlock, 3); // todo : need a variable to store this index?
			var h = self._peek(textboxAttributeBlock, 4);
			if (w > 0 && h > 0) {
				bitsyLog("textbox changed! " + memory.changed[self.TEXTBOX] + " " + memory.changed[textboxAttributeBlock] + " " + w + " " + h, "system");
				var useTextBoxScale = true; // todo : check mode here?
				graphics.createImage(self.TEXTBOX, w, h, self._dump()[self.TEXTBOX], useTextBoxScale);
			}
		}

		var mode = self._peek(modeBlock, 0);
		if (mode === self.GFX_VIDEO) {
			if (memory.changed[self.VIDEO]) {
				graphics.clearCanvas(0);
				// update screen image
				graphics.createImage(self.VIDEO, self.VIDEO_SIZE, self.VIDEO_SIZE, self._dump()[self.VIDEO]);
				// render screen onto canvas
				graphics.drawImage(self.VIDEO, 0, 0);
			}
		}
		else if (mode === self.GFX_MAP) {
			// redraw any changed layers
			var layers = self._getTileMapLayers();
			var anyMapLayerChanged = false;
			for (var i = 0; i < layers.length; i++) {
				var layerId = layers[i];
				if (memory.changed[layerId]) {
					// need to redraw this map layer
					anyMapLayerChanged = true;
					// clear layer canvas
					graphics.setImageFill(layerId, 0); // fill transparent
					graphics.createImage(layerId, self.VIDEO_SIZE, self.VIDEO_SIZE, []);
					// render tiles onto layer canvas
					var layerData = self._dump()[layerId];
					for (var ty = 0; ty < self.MAP_SIZE; ty++) {
						for (var tx = 0; tx < self.MAP_SIZE; tx++) {
							var tileIndex = (ty * self.MAP_SIZE) + tx;
							var tile = layerData[tileIndex];
							if (tile > 0) {
								graphics.drawImage(tile, tx * self.TILE_SIZE, ty * self.TILE_SIZE, layerId);
							}
						}
					}
				}
			}

			// redraw the main canvas
			if (textboxChanged || anyMapLayerChanged) {
				bitsyLog("map changed? " + memory.changed[self.MAP1] + " " + memory.changed[self.MAP2], "system");
				graphics.clearCanvas(0);

				for (var i = 0; i < layers.length; i++) {
					var layerId = layers[i];
					// draw the layer's image canvas onto the main canvas
					graphics.drawImage(layerId, 0, 0);
				}

				// draw textbox onto canvas
				var visible = self._peek(textboxAttributeBlock, 0)
				var x = self._peek(textboxAttributeBlock, 1);
				var y = self._peek(textboxAttributeBlock, 2);
				var w = self._peek(textboxAttributeBlock, 3);
				var h = self._peek(textboxAttributeBlock, 4);
				if (visible > 0 && w > 0 && h > 0) {
					graphics.drawImage(self.TEXTBOX, x, y);
				}
			}
		}
	}

	/* == PRIVATE / DEBUG == */
	this._name = name;

	this._active = false;

	this._attachCanvas = function(c) {
		graphics.attachCanvas(c, self.VIDEO_SIZE);
	};

	this._getCanvas = graphics.getCanvas;
	this._getContext = graphics.getContext;

	this._start = function() {
		input.listen(graphics.getCanvas());
		updateTextScale();
		self._active = true;
	};

	// hacky...
	this._startNoInput = function() {
		updateTextScale();
		self._active = true;
	};

	this._exit = function() {
		// disable graphics
		var canvas = graphics.getCanvas();
		if (canvas) {
			input.unlisten(canvas);	
		}

		// disable sound
		sound.mute();

		self._active = false;
	};

	// hacky....
	this._injectPreLoop = null;
	this._injectPostDraw = null;

	this._update = function(dt) {
		var shouldContinue = false;

		updateInput();

		// too hacky???
		if (self._injectPreLoop) {
			self._injectPreLoop();
		}

		// run main loop
		if (onLoopFunction) {
			shouldContinue = onLoopFunction(dt);
		}

		if (memory.changed[modeBlock]) {
			updateTextScale();
		}

		// update output systems
		updateSound(dt);
		updateGraphics();

		if (self._injectPostDraw) {
			self._injectPostDraw();
		}

		// reset memory block changed flags
		for (var i = 0; i < memory.changed.length; i++) {
			memory.changed[i] = false;
		}

		// todo : should the _exit() call go in here?

		return shouldContinue;
	};

	this._updateGraphics = updateGraphics;

	this._allocate = function(args) {
		// find next available block in range
		var next = (args && args.start) ? args.start : 0;
		var count = (args && args.max) ? args.max : -1;
		while (memory.blocks[next] != undefined && count != 0) {
			next++;
			count--;
		}

		if (count == 0) {
			// couldn't find any available block
			return null;
		}

		if (args && args.str) {
			memory.blocks[next] = args.str;
		}
		else {
			var size = args && args.size ? args.size : 0;
			memory.blocks[next] = [];
			for (var i = 0; i < size; i++) {
				memory.blocks[next].push(0);
			}
		}

		memory.changed[next] = false;

		return next;
	};

	this._free = function(block) {
		delete memory.blocks[block];
		delete memory.changed[block];
	};

	this._peek = function(block, index) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			return memoryBlock.charCodeAt(index);
		}
		else {
			return memoryBlock[index];
		}
	};

	this._poke = function(block, index, value) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			memory.blocks[block] = memoryBlock.substring(0, index) + String.fromCharCode(value) + memoryBlock.substring(index + 1);
		}
		else {
			var value = parseInt(value);
			if (!isNaN(value)) {
				memoryBlock[index] = value;
			}
		}
		memory.changed[block] = true;
	};

	this._read = function(block) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			return memoryBlock;
		}
		else {
			var str = "";
			for (var i = 0; i < memoryBlock.length; i++) {
				str += String.fromCharCode(memoryBlock[i]);
			}
			return str;
		}
	};

	this._write = function(block, str) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			memory.blocks[block] = str;
		}
		else {
			memory.blocks[block] = [];
			for (var i = 0; i < str.length; i++) {
				memory.blocks[block][i] = str.charCodeAt(i);
			}
		}
		memory.changed[block] = true;
	};

	this._dump = function() {
		return memory.blocks;
	};

	// convenience methods for hacking around with map layers
	var tileMapLayers = [];
	this._getTileMapLayers = function() {
		return tileMapLayers;
	};
	this._addTileMapLayer = function() {
		var layer = self._allocate({
			start: (tilePoolStart + tilePoolSize),
			size: (self.MAP_SIZE * self.MAP_SIZE)
		});

		tileMapLayers.push(layer);

		return layer;
	};

	/* == CONSTANTS == */
	// memory blocks (these will be initialized below)
	this.VIDEO;
	this.TEXTBOX;
	this.MAP1;
	this.MAP2;
	this.SOUND1;
	this.SOUND2;

	// graphics modes
	this.GFX_VIDEO = 0;
	this.GFX_MAP = 1;

	// text modes
	this.TXT_HIREZ = 0; // 2x resolution
	this.TXT_LOREZ = 1; // 1x resolution

	// size
	this.TILE_SIZE = tilesize;
	this.MAP_SIZE = mapsize;
	this.VIDEO_SIZE = width;
	// todo : should text scale have a constant?

	// button codes
	this.BTN_UP = 0;
	this.BTN_DOWN = 1;
	this.BTN_LEFT = 2;
	this.BTN_RIGHT = 3;
	this.BTN_OK = 4;
	this.BTN_MENU = 5;

	// pulse waves
	this.PULSE_1_8 = 0;
	this.PULSE_1_4 = 1;
	this.PULSE_1_2 = 2;

	/* == IO == */
	this.log = function(message) {
		bitsyLog(message, name);
	};

	this.button = function(code) {
		return self._peek(buttonBlock, code) > 0;
	};

	this.getGameData = function() {
		return self._read(gameDataBlock);
	};

	this.getFontData = function() {
		return self._read(fontDataBlock);
	};

	/* == GRAPHICS == */
	this.graphicsMode = function(mode) {
		// todo : store the mode flag indices somewhere?
		if (mode != undefined) {
			self._poke(modeBlock, 0, mode);
		}

		return self._peek(modeBlock, 0);
	};

	this.textMode = function(mode) {
		// todo : test whether the requested mode is supported!
		if (mode != undefined) {
			self._poke(modeBlock, 1, mode);
		}

		return self._peek(modeBlock, 1);
	};

	this.color = function(color, r, g, b) {
		self._poke(paletteBlock, (color * 3) + 0, r);
		self._poke(paletteBlock, (color * 3) + 1, g);
		self._poke(paletteBlock, (color * 3) + 2, b);

		// mark all graphics as changed
		memory.changed[self.VIDEO] = true;
		memory.changed[self.TEXTBOX] = true;
		memory.changed[self.MAP1] = true;
		memory.changed[self.MAP2] = true;

		if (tilePoolStart != null) {
			for (var i = 0; i < tilePoolSize; i++) {
				if (memory.blocks[tilePoolStart + i] != undefined) {
					memory.changed[tilePoolStart + i] = true;
				}
			}
		}
	};

	this.tile = function() {
		return self._allocate({
			start: tilePoolStart,
			max: tilePoolSize,
			size: (self.TILE_SIZE * self.TILE_SIZE)
		});
	};

	this.delete = function(tile) {
		if (graphics.hasImage(tile)) {
			graphics.deleteImage(tile);
		}

		self._free(tile);
	};

	this.fill = function(block, value) {
		var len = memory.blocks[block].length;
		for (var i = 0; i < len; i++) {
			self._poke(block, i, value);
		}

		var isImage = (block === self.VIDEO) ||
			(block === self.TEXTBOX) ||
			(block >= tilePoolStart && block < (tilePoolStart + tilePoolSize));

		// optimize rendering by notifying the graphics system what the fill color is for this image
		if (isImage) {
			graphics.setImageFill(block, value);
		}
	};

	this.set = function(block, index, value) {
		self._poke(block, index, value);
	};

	this.textbox = function(visible, x, y, w, h) {
		if (visible != undefined) {
			self._poke(textboxAttributeBlock, 0, (visible === true) ? 1 : 0);
		}
		
		if (x != undefined) {
			self._poke(textboxAttributeBlock, 1, x);
		}
		
		if (y != undefined) {
			self._poke(textboxAttributeBlock, 2, y);
		}

		var prevWidth = self._peek(textboxAttributeBlock, 3);
		var prevHeight = self._peek(textboxAttributeBlock, 4);

		if (w != undefined) {
			self._poke(textboxAttributeBlock, 3, w);
		}
		
		if (h != undefined) {
			self._poke(textboxAttributeBlock, 4, h);
		}

		if (w != undefined && h != undefined && (prevWidth != w || prevHeight != h)) {
			// re-allocate the textbox block (should I have a helper function for this?)
			memory.blocks[self.TEXTBOX] = [];
			for (var i = 0; i < (w * h); i++) {
				memory.blocks[self.TEXTBOX].push(0);
			}
			memory.changed[self.TEXTBOX] = true;
		}
	};

	/* == SOUND == */
	// duration is in milliseconds (ms)
	this.sound = function(channel, duration, frequency, volume, pulse) {
		self._poke(channel, soundDurationIndex, duration);
		self._poke(channel, soundFrequencyIndex, frequency);
		self._poke(channel, soundVolumeIndex, volume);
		self._poke(channel, soundPulseIndex, pulse);
	};

	// frequency is in decihertz (dHz)
	this.frequency = function(channel, frequency) {
		self._poke(channel, soundFrequencyIndex, frequency);
	};

	// volume: min = 0, max = 15
	this.volume = function(channel, volume) {
		self._poke(channel, soundVolumeIndex, volume);
	};

	/* == EVENTS == */
	this.loop = function(fn) {
		onLoopFunction = fn;
	};

	/* == INTERNAL == */
	// initialize memory blocks
	var gameDataBlock = this._allocate({ str: "" });
	var fontDataBlock = this._allocate({ str: "" });
	this.VIDEO = this._allocate({ size: self.VIDEO_SIZE * self.VIDEO_SIZE });
	this.TEXTBOX = this._allocate();
	this.MAP1 = this._allocate({ size: self.MAP_SIZE * self.MAP_SIZE });
	tileMapLayers.push(this.MAP1);
	this.MAP2 = this._allocate({ size: self.MAP_SIZE * self.MAP_SIZE });
	tileMapLayers.push(this.MAP2);
	var paletteBlock = this._allocate({ size: initialPaletteSize * 3 });
	var buttonBlock = this._allocate({ size: 8 });
	this.SOUND1 = this._allocate({ size: 4 });
	this.SOUND2 = this._allocate({ size: 4 });
	var modeBlock = this._allocate({ size: 8 });
	var textboxAttributeBlock = this._allocate({ size: 8 });

	tilePoolStart = (textboxAttributeBlock + 1);

	// access for debugging
	this._gameDataBlock = gameDataBlock;
	this._fontDataBlock = fontDataBlock;
	this._buttonBlock = buttonBlock;

	// events
	var onLoopFunction = null;
}

var mainProcess = addProcess();
var bitsy = mainProcess.system;
</script>

<!-- engine -->
<script>
/* BITSY VERSION */
// is this the right place for this to live?
var version = {
	major: 8, // major changes
	minor: 12, // smaller changes
	devBuildPhase: "RELEASE",
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* TEXT CONSTANTS */
var titleDialogId = "title";

// todo : where should this be stored?
var tileColorStartIndex = 16;

var TextDirection = {
	LeftToRight : "LTR",
	RightToLeft : "RTL"
};

var defaultFontName = "ascii_small";

/* TUNE CONSTANTS */
var barLength = 16; // sixteenth notes
var minTuneLength = 1;
var maxTuneLength = 16;

// chromatic notes
var Note = {
	NONE 		: -1,
	C 			: 0,	// C
	C_SHARP 	: 1,	// C sharp / D flat
	D 			: 2,	// D
	D_SHARP 	: 3,	// D sharp / E flat
	E 			: 4,	// E
	F 			: 5,	// F
	F_SHARP 	: 6,	// F sharp / G flat
	G 			: 7,	// G
	G_SHARP 	: 8,	// G sharp / A flat
	A 			: 9,	// A
	A_SHARP 	: 10,	// A sharp / B flat
	B 			: 11,	// B
	COUNT 		: 12
};

// solfa notes
var Solfa = {
	NONE 	: -1,
	D 		: 0,	// Do
	R 		: 1,	// Re
	M 		: 2,	// Mi
	F 		: 3,	// Fa
	S 		: 4,	// Sol
	L 		: 5,	// La
	T 		: 6,	// Ti
	COUNT 	: 7
};

var Octave = {
	NONE: -1,
	2: 0,
	3: 1,
	4: 2, // octave 4: middle C octave
	5: 3,
	COUNT: 4
};

var Tempo = {
	SLW: 0, // slow
	MED: 1, // medium
	FST: 2, // fast
	XFST: 3 // extra fast (aka turbo)
};

var SquareWave = {
	P8: 0, // pulse 1 / 8
	P4: 1, // pulse 1 / 4
	P2: 2, // pulse 1 / 2
	COUNT: 3
};

var ArpeggioPattern = {
	OFF: 0,
	UP: 1, // ascending triad chord
	DWN: 2, // descending triad chord
	INT5: 3, // 5 step interval
	INT8: 4 // 8 setp interval
};

function createWorldData() {
	return {
		room : {},
		tile : {},
		sprite : {},
		item : {},
		dialog : {},
		end : {}, // pre-7.0 ending data for backwards compatibility
		palette : { // start off with a default palette
			"default" : {
				name : "default",
				colors : [[0,0,0],[255,255,255],[255,255,255]]
			}
		},
		variable : {},
		tune : {},
		blip : {},
		versionNumberFromComment : -1, // -1 indicates no version information found
		fontName : defaultFontName,
		textDirection : TextDirection.LeftToRight,
		flags : createDefaultFlags(),
		names : {},
		// source data for all drawings (todo: better name?)
		drawings : {},
	};
}

// creates a drawing data structure with default property values for the type
function createDrawingData(type, id) {
	// the avatar's drawing id still uses the sprite prefix (for back compat)
	var drwId = (type === "AVA" ? "SPR" : type) + "_" + id;

	var drawingData = {
		type : type,
		id : id,
		name : null,
		drw : drwId,
		col : (type === "TIL") ? 1 : 2, // foreground color
		bgc : 0, // background color
		animation : {
			isAnimated : false,
			frameIndex : 0,
			frameCount : 1,
		},
	};

	// add type specific properties
	if (type === "TIL") {
		// default null value indicates it can vary from room to room (original version)
		drawingData.isWall = null;
	}

	if (type === "AVA" || type === "SPR") {
		// default sprite location is "offstage"
		drawingData.room = null;
		drawingData.x = -1;
		drawingData.y = -1;
		drawingData.inventory = {};
	}

	if (type === "AVA" || type === "SPR" || type === "ITM") {
		drawingData.dlg = null;
		drawingData.blip = null;
	}

	return drawingData;
}

function createTuneData(id) {
	var tuneData = {
		id : id,
		name : null,
		melody : [],
		harmony : [],
		key: null, // a null key indicates a chromatic scale (all notes enabled)
		tempo: Tempo.MED,
		instrumentA : SquareWave.P2,
		instrumentB : SquareWave.P2,
		arpeggioPattern : ArpeggioPattern.OFF,
	};
	return tuneData;
}

function createTuneBarData() {
	var bar = [];
	for (var i = 0; i < barLength; i++) {
		bar.push({ beats: 0, note: Note.C, octave: Octave[4] });
	}
	return bar;
}

function createTuneKeyData() {
	var key = {
		notes: [], // mapping of the solfa scale degrees to chromatic notes
		scale: []  // list of solfa notes that are enabled for this key
	};

	// initialize notes
	for (var i = 0; i < Solfa.COUNT; i++) {
		key.notes.push(Note.NONE);
	}

	return key;
}

function createBlipData(id) {
	var blipData = {
		id: id,
		name: null,
		pitchA: { beats: 0, note: Note.C, octave: Octave[4] },
		pitchB: { beats: 0, note: Note.C, octave: Octave[4] },
		pitchC: { beats: 0, note: Note.C, octave: Octave[4] },
		envelope: {
			attack: 0, // attack time in ms
			decay: 0, // decay time in ms
			sustain: 0, // sustain volume
			length: 0, // sustain time in ms
			release: 0 // release time in ms
		},
		beat : {
			time: 0, // time in ms between pitch changes
			delay: 0 // time in ms *before* first pitch change
		},
		instrument: SquareWave.P2,
		doRepeat: false
		// TODO : consider for future update
		// doSlide: false,
	};

	return blipData;
}

function createDefaultFlags() {
	return {
		// version
		VER_MAJ: -1, // major version number (-1 = no version information found)
		VER_MIN: -1, // minor version number (-1 = no version information found)
		// compatibility
		ROOM_FORMAT: 0, // 0 = non-comma separated (original), 1 = comma separated (default)
		DLG_COMPAT: 0, // 0 = default dialog behavior, 1 = pre-7.0 dialog behavior
		// config
		TXT_MODE: 0 // 0 = HIREZ (2x - default), 1 = LOREZ (1x)
	};
}

function createDialogData(id) {
	return {
		src : "",
		name : null,
		id : id,
	};
}

function parseWorld(file) {
	bitsy.log("create world data");

	var world = createWorldData();

	bitsy.log("init parse state");

	var parseState = {
		lines : file.split("\n"),
		index : 0,
		spriteStartLocations : {}
	};

	bitsy.log("start reading lines");

	while (parseState.index < parseState.lines.length) {
		var i = parseState.index;
		var lines = parseState.lines;
		var curLine = lines[i];

		// bitsy.log("LN " + i + " xx " + curLine);

		if (i == 0) {
			i = parseTitle(parseState, world);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			// collect version number from a comment (hacky but required for pre-8.0 compatibility)
			if (curLine.indexOf("# BITSY VERSION ") != -1) {
				world.versionNumberFromComment = parseFloat(curLine.replace("# BITSY VERSION ", ""));
			}

			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) === "PAL") {
			i = parsePalette(parseState, world);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { // SET for back compat
			i = parseRoom(parseState, world);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(parseState, world);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(parseState, world);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(parseState, world);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(parseState, world);
		}
		else if (getType(curLine) === "END") {
			// parse endings for back compat
			i = parseEnding(parseState, world);
		}
		else if (getType(curLine) === "VAR") {
			i = parseVariable(parseState, world);
		}
		else if (getType(curLine) === "DEFAULT_FONT") {
			i = parseFontName(parseState, world);
		}
		else if (getType(curLine) === "TEXT_DIRECTION") {
			i = parseTextDirection(parseState, world);
		}
		else if (getType(curLine) === "FONT") {
			i = parseFontData(parseState, world);
		}
		else if (getType(curLine) === "TUNE") {
			i = parseTune(parseState, world);
		}
		else if (getType(curLine) === "BLIP") {
			i = parseBlip(parseState, world);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(parseState, world);
		}
		else {
			i++;
		}

		parseState.index = i;
	}

	world.names = createNameMapsForWorld(world);

	placeSprites(parseState, world);

	if ((world.flags.VER_MAJ <= -1 || world.flags.VER_MIN <= -1) && world.versionNumberFromComment > -1) {
		var versionNumberStr = "" + world.versionNumberFromComment;
		versionNumberStr = versionNumberStr.split(".");
		world.flags.VER_MAJ = parseFloat(versionNumberStr[0]);
		world.flags.VER_MIN = parseFloat(versionNumberStr[1]);
	}

	// starting in version v7.0, there were two major changes to dialog behavior:
	// 1) sprite dialog was no longer implicitly linked by the sprite and dialog IDs matching
	//    (see this commit: 5e1adb29faad4e50603c689d2dac143074117b4e)
	// 2) ending dialogs no longer had their own world data type ("END")
	// for the v7.x versions I tried to automatically convert old dialog to the new format,
	// however, that process can be unreliable and lead to weird bugs.
	// with v8.0 and above I will no longer attempt to convert old files, and instead will use
	// a flag to indicate files that need to use the backwards compatible behavior -
	// this is more reliable & configurable (at the cost of making pre-7.0 games a bit harder to edit)
	if (world.flags.VER_MAJ < 7) {
		world.flags.DLG_COMPAT = 1;
	}

	return world;
}

function parseTitle(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var results;
	if (scriptUtils) {
		results = scriptUtils.ReadDialogScript(lines,i);
	}
	else {
		results = { script: lines[i], index: (i + 1) };
	}

	world.dialog[titleDialogId] = createDialogData(titleDialogId);
	world.dialog[titleDialogId].src = results.script;

	i = results.index;
	i++;

	return i;
}

function parsePalette(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if (args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	world.palette[id] = {
		id : id,
		name : name,
		colors : colors
	};
	return i;
}

function createRoomData(id) {
	return {
		id: id,
		name: null,
		tilemap: [],
		walls: [],
		exits: [],
		endings: [],
		items: [],
		pal: null,
		ava: null,
		tune: "0"
	};
}

function createExitData(x, y, destRoom, destX, destY, transition, dlg) {
	return {
		x: x,
		y: y,
		dest: {
			room: destRoom,
			x: destX,
			y: destY
		},
		transition_effect: transition,
		dlg: dlg,
	};
}

function createEndingData(id, x, y) {
	return {
		id: id,
		x: x,
		y: y
	};
}

function parseRoom(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	var id = getId(lines[i]);

	var roomData = createRoomData(id);

	i++;

	// create tile map
	if (world.flags.ROOM_FORMAT === 0) {
		// old way: no commas, single char tile ids
		var end = i + bitsy.MAP_SIZE;
		var y = 0;
		for (; i < end; i++) {
			roomData.tilemap.push([]);
			for (x = 0; x < bitsy.MAP_SIZE; x++) {
				roomData.tilemap[y].push(lines[i].charAt(x));
			}
			y++;
		}
	}
	else if (world.flags.ROOM_FORMAT === 1) {
		// new way: comma separated, multiple char tile ids
		var end = i + bitsy.MAP_SIZE;
		var y = 0;
		for (; i < end; i++) {
			roomData.tilemap.push([]);
			var lineSep = lines[i].split(",");
			for (x = 0; x < bitsy.MAP_SIZE; x++) {
				roomData.tilemap[y].push(lineSep[x]);
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// bitsy.log(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				parseState.spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( world.flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/ 
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in roomData.tilemap) {
					for (s in sprList) {
						var col = roomData.tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							roomData.tilemap[row][col] = "0";
							parseState.spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			roomData.items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			roomData.walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = createExitData(
				/* x 			*/ parseInt(exitCoords[0]),
				/* y 			*/ parseInt(exitCoords[1]),
				/* destRoom 	*/ destName,
				/* destX 		*/ parseInt(destCoords[0]),
				/* destY 		*/ parseInt(destCoords[1]),
				/* transition 	*/ null,
				/* dlg 			*/ null);

			// optional arguments
			var exitArgIndex = 4;
			while (exitArgIndex < exitArgs.length) {
				if (exitArgs[exitArgIndex] == "FX") {
					ext.transition_effect = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else if (exitArgs[exitArgIndex] == "DLG") {
					ext.dlg = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else {
					exitArgIndex += 1;
				}
			}

			roomData.exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId(lines[i]);

			var endCoords = getCoord(lines[i], 2);
			var end = createEndingData(
				/* id */ endId,
				/* x */ parseInt(endCoords[0]),
				/* y */ parseInt(endCoords[1]));

			roomData.endings.push(end);
		}
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			roomData.pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "AVA") {
			// change avatar appearance per room
			roomData.ava = getId(lines[i]);
		}
		else if (getType(lines[i]) === "TUNE") {
			roomData.tune = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			roomData.name = getNameArg(lines[i]);
		}

		i++;
	}

	world.room[id] = roomData;

	return i;
}

function parseTile(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	var tileData = createDrawingData("TIL", id);

	i++;

	// read & store tile image source
	i = parseDrawingCore(lines, i, tileData.drw, world);

	// update animation info
	tileData.animation.frameCount = getDrawingFrameCount(world, tileData.drw);
	tileData.animation.isAnimated = tileData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			tileData.col = parseInt(getId(lines[i]));
		}
		else if (getType(lines[i]) === "BGC") {
			var bgcId = getId(lines[i]);
			if (bgcId === "*") {
				// transparent background
				tileData.bgc = (-1 * tileColorStartIndex);
			}
			else {
				tileData.bgc = parseInt(bgcId);
			}
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			tileData.name = getNameArg(lines[i]);
		}
		else if (getType(lines[i]) === "WAL") {
			var wallArg = getArg(lines[i], 1);
			if (wallArg === "true") {
				tileData.isWall = true;
			}
			else if (wallArg === "false") {
				tileData.isWall = false;
			}
		}

		i++;
	}

	// store tile data
	world.tile[id] = tileData;

	return i;
}

function parseSprite(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	var type = (id === "A") ? "AVA" : "SPR";
	var spriteData = createDrawingData(type, id);

	// bitsy.log(spriteData);

	i++;

	// read & store sprite image source
	i = parseDrawingCore(lines, i, spriteData.drw, world);

	// update animation info
	spriteData.animation.frameCount = getDrawingFrameCount(world, spriteData.drw);
	spriteData.animation.isAnimated = spriteData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			spriteData.col = parseInt(getId(lines[i]));
		}
		else if (getType(lines[i]) === "BGC") {
			/* BACKGROUND COLOR */
			var bgcId = getId(lines[i]);
			if (bgcId === "*") {
				// transparent background
				spriteData.bgc = (-1 * tileColorStartIndex);
			}
			else {
				spriteData.bgc = parseInt(bgcId);
			}
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			parseState.spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			spriteData.dlg = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			spriteData.name = getNameArg(lines[i]);
		}
		else if (getType(lines[i]) === "ITM") {
			/* ITEM STARTING INVENTORY */
			var itemId = getId(lines[i]);
			var itemCount = parseFloat(getArg(lines[i], 2));
			spriteData.inventory[itemId] = itemCount;
		}
		else if (getType(lines[i]) == "BLIP") {
			var blipId = getId(lines[i]);
			spriteData.blip = blipId;
		}

		i++;
	}

	// store sprite data
	world.sprite[id] = spriteData;

	return i;
}

function parseItem(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	var itemData = createDrawingData("ITM", id);

	i++;

	// read & store item image source
	i = parseDrawingCore(lines, i, itemData.drw, world);

	// update animation info
	itemData.animation.frameCount = getDrawingFrameCount(world, itemData.drw);
	itemData.animation.isAnimated = itemData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			itemData.col = parseInt(getArg(lines[i], 1));
		}
		else if (getType(lines[i]) === "BGC") {
			/* BACKGROUND COLOR */
			var bgcId = getId(lines[i]);
			if (bgcId === "*") {
				// transparent background
				itemData.bgc = (-1 * tileColorStartIndex);
			}
			else {
				itemData.bgc = parseInt(bgcId);
			}
		}
		else if (getType(lines[i]) === "DLG") {
			itemData.dlg = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			itemData.name = getNameArg(lines[i]);
		}
		else if (getType(lines[i]) == "BLIP") {
			var blipId = getId(lines[i]);
			itemData.blip = blipId;
		}

		i++;
	}

	// store item data
	world.item[id] = itemData;

	return i;
}

function parseDrawingCore(lines, i, drwId, world) {
	var frameList = []; //init list of frames
	frameList.push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while (y < bitsy.TILE_SIZE) {
		var line = lines[i + y];
		var row = [];

		for (x = 0; x < bitsy.TILE_SIZE; x++) {
			row.push(parseInt(line.charAt(x)));
		}

		frameList[frameIndex].push(row);
		y++;

		if (y === bitsy.TILE_SIZE) {
			i = i + y;
			if (lines[i] != undefined && lines[i].charAt(0) === ">") {
				// start next frame!
				frameList.push([]);
				frameIndex++;

				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	storeDrawingData(world, drwId, frameList);

	return i;
}

function parseDialog(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	// hacky but I need to store this so I can set the name below
	var id = getId(lines[i]);

	i = parseScript(lines, i, world.dialog);

	if (i < lines.length && lines[i].length > 0 && getType(lines[i]) === "NAME") {
		world.dialog[id].name = getNameArg(lines[i]);
		i++;
	}

	return i;
}

// keeping this around to parse old files where endings were separate from dialogs
function parseEnding(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	return parseScript(lines, i, world.end);
}

function parseScript(lines, i, data) {
	var id = getId(lines[i]);
	i++;

	var results;
	if (scriptUtils) {
		results = scriptUtils.ReadDialogScript(lines,i);
	}
	else {
		results = { script: lines[i], index: (i + 1)};
	}

	data[id] = createDialogData(id);
	data[id].src = results.script;

	i = results.index;

	return i;
}

function parseVariable(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	var id = getId(lines[i]);
	i++;
	var value = lines[i];
	i++;
	world.variable[id] = value;
	return i;
}

function parseFontName(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	world.fontName = getArg(lines[i], 1);
	i++;
	return i;
}

function parseTextDirection(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	world.textDirection = getArg(lines[i], 1);
	i++;
	return i;
}

function parseFontData(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	// NOTE : we're not doing the actual parsing here --
	// just grabbing the block of text that represents the font
	// and giving it to the font manager to use later

	var localFontName = getId(lines[i]);
	var localFontData = lines[i];
	i++;

	while (i < lines.length && lines[i] != "") {
		localFontData += "\n" + lines[i];
		i++;
	}

	var localFontFilename = localFontName + fontManager.GetExtension();
	fontManager.AddResource( localFontFilename, localFontData );

	return i;
}

function parseTune(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	i++;

	var tuneData = createTuneData(id);

	var barIndex = 0;
	while (barIndex < maxTuneLength) {
		// MELODY
		var melodyBar = createTuneBarData();
		var melodyNotes = lines[i].split(",");
		for (var j = 0; j < barLength; j++) {
			// default to a rest
			var pitch = { beats: 0, note: Note.C, octave: Octave[4], };

			if (j < melodyNotes.length) {
				var pitchSplit = melodyNotes[j].split("~");
				var pitchStr = pitchSplit[0];
				pitch = parsePitch(melodyNotes[j]);

				// look for effect added to the note
				if (pitchSplit.length > 1) {
					var blipId = pitchSplit[1];
					pitch.blip = blipId;
				}
			}

			melodyBar[j] = pitch;
		}
		tuneData.melody.push(melodyBar);
		i++;

		// HARMONY
		var harmonyBar = createTuneBarData();
		var harmonyNotes = lines[i].split(",");
		for (var j = 0; j < barLength; j++) {
			// default to a rest
			var pitch = { beats: 0, note: Note.C, octave: Octave[4], };

			if (j < harmonyNotes.length) {
				var pitchSplit = harmonyNotes[j].split("~");
				var pitchStr = pitchSplit[0];
				pitch = parsePitch(harmonyNotes[j]);

				// look for effect added to the note
				if (pitchSplit.length > 1) {
					var blipId = pitchSplit[1];
					pitch.blip = blipId;
				}
			}

			harmonyBar[j] = pitch;
		}
		tuneData.harmony.push(harmonyBar);
		i++;

		// check if there's another bar after this one
		if (lines[i] === ">") {
			// there is! increment the index
			barIndex++;
			i++;
		}
		else {
			// we've reached the end of the tune!
			barIndex = maxTuneLength;
		}
	}

	// parse other tune properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "KEY") {
			tuneData.key = createTuneKeyData();

			var keyNotes = getArg(lines[i], 1);
			if (keyNotes) {
				keyNotes = keyNotes.split(",");
				for (var j = 0; j < keyNotes.length && j < tuneData.key.notes.length; j++) {
					var pitch = parsePitch(keyNotes[j]);
					tuneData.key.notes[j] = pitch.note;
				}
			}

			var keyScale = getArg(lines[i], 2);
			if (keyScale) {
				keyScale = keyScale.split(",");
				for (var j = 0; j < keyScale.length; j++) {
					var pitch = parsePitch(keyScale[j]);
					if (pitch.note > Solfa.NONE && pitch.note < Solfa.COUNT) {
						tuneData.key.scale.push(pitch.note);
					}
				}
			}
		}
		else if (getType(lines[i]) === "TMP") {
			var tempoId = getId(lines[i]);
			if (Tempo[tempoId] != undefined) {
				tuneData.tempo = Tempo[tempoId];
			}
		}
		else if (getType(lines[i]) === "SQR") {
			// square wave instrument settings
			var squareWaveIdA = getArg(lines[i], 1);
			if (SquareWave[squareWaveIdA] != undefined) {
				tuneData.instrumentA = SquareWave[squareWaveIdA];
			}

			var squareWaveIdB = getArg(lines[i], 2);
			if (SquareWave[squareWaveIdB] != undefined) {
				tuneData.instrumentB = SquareWave[squareWaveIdB];
			}
		}
		else if (getType(lines[i]) === "ARP") {
			var arp = getId(lines[i]);
			if (ArpeggioPattern[arp] != undefined) {
				tuneData.arpeggioPattern = ArpeggioPattern[arp];
			}
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			tuneData.name = name;
			// todo : add to map?
		}

		i++;
	}

	world.tune[id] = tuneData;

	return i;
}

function parseBlip(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	i++;

	var blipData = createBlipData(id);

	// blip pitches
	var notes = lines[i].split(",");
	if (notes.length >= 1) {
		blipData.pitchA = parsePitch(notes[0]);
	}
	if (notes.length >= 2) {
		blipData.pitchB = parsePitch(notes[1]);
	}
	if (notes.length >= 3) {
		blipData.pitchC = parsePitch(notes[2]);
	}
	i++;

	// blip parameters
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "ENV") {
			// envelope
			blipData.envelope.attack = parseInt(getArg(lines[i], 1));
			blipData.envelope.decay = parseInt(getArg(lines[i], 2));
			blipData.envelope.sustain = parseInt(getArg(lines[i], 3));
			blipData.envelope.length = parseInt(getArg(lines[i], 4));
			blipData.envelope.release = parseInt(getArg(lines[i], 5));
		}
		else if (getType(lines[i]) === "BEAT") {
			// pitch beat length
			blipData.beat.time = parseInt(getArg(lines[i], 1));
			blipData.beat.delay = parseInt(getArg(lines[i], 2));
		}
		else if (getType(lines[i]) === "SQR") {
			// square wave
			var squareWaveId = getArg(lines[i], 1);
			if (SquareWave[squareWaveId] != undefined) {
				blipData.instrument = SquareWave[squareWaveId];
			}
		}
		// TODO : consider for future update
		// else if (getType(lines[i]) === "SLD") {
		// 	// slide mode
		// 	if (parseInt(getArg(lines[i], 1)) === 1) {
		// 		blipData.doSlide = true;
		// 	}
		// }
		else if (getType(lines[i]) === "RPT") {
			// repeat mode
			if (parseInt(getArg(lines[i], 1)) === 1) {
				blipData.doRepeat = true;
			}
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			blipData.name = name;
		}

		i++;
	}

	world.blip[id] = blipData;

	return i;
}

function parsePitch(pitchStr) {
	var pitch = { beats: 1, note: Note.C, octave: Octave[4], };
	var i;

	// beats
	var beatsToken = "";
	for (i = 0; i < pitchStr.length && ("0123456789".indexOf(pitchStr[i]) != -1); i++) {
		beatsToken += pitchStr[i];
	}
	if (beatsToken.length > 0) {
		pitch.beats = parseInt(beatsToken);
	}

	// note
	var noteType;
	var noteName = "";
	if (i < pitchStr.length) {
		if (pitchStr[i] === pitchStr[i].toUpperCase()) {
			// uppercase letters represent chromatic notes
			noteType = Note;
			noteName += pitchStr[i];
			i++;

			// check for sharp
			if (i < pitchStr.length && pitchStr[i] === "#") {
				noteName += "_SHARP";
				i++;
			}
		}
		else {
			// lowercase letters represent solfa notes
			noteType = Solfa;
			noteName += pitchStr[i].toUpperCase();
			i++;
		}
	}

	if (noteType != undefined && noteType[noteName] != undefined) {
		pitch.note = noteType[noteName];
	}

	// octave
	var octaveToken = "";
	if (i < pitchStr.length) {
		octaveToken += pitchStr[i];
	}

	if (Octave[octaveToken] != undefined) {
		pitch.octave = Octave[octaveToken];
	}

	return pitch;
}

function parseFlag(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	world.flags[id] = parseInt( valStr );
	i++;
	return i;
}

function getDrawingFrameCount(world, drwId) {
	return world.drawings[drwId].length;
}

function storeDrawingData(world, drwId, drawingData) {
	world.drawings[drwId] = drawingData;
}

function placeSprites(parseState, world) {
	for (id in parseState.spriteStartLocations) {
		world.sprite[id].room = parseState.spriteStartLocations[id].room;
		world.sprite[id].x = parseState.spriteStartLocations[id].x;
		world.sprite[id].y = parseState.spriteStartLocations[id].y;
	}
}

function createNameMapsForWorld(world) {
	var nameMaps = {};

	function createNameMap(objectStore) {
		var map = {};

		for (id in objectStore) {
			if (objectStore[id].name != undefined && objectStore[id].name != null) {
				map[objectStore[id].name] = id;
			}
		}

		return map;
	}

	nameMaps.room = createNameMap(world.room);
	nameMaps.tile = createNameMap(world.tile);
	nameMaps.sprite = createNameMap(world.sprite);
	nameMaps.item = createNameMap(world.item);
	nameMaps.dialog = createNameMap(world.dialog);
	nameMaps.palette = createNameMap(world.palette);
	nameMaps.tune = createNameMap(world.tune);
	nameMaps.blip = createNameMap(world.blip);

	return nameMaps;
}

function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getNameArg(line) {
	var name = line.split(/\s(.+)/)[1];
	return name;
}
</script>

<script>
/* PITCH HELPER FUNCTIONS */
function pitchToSteps(pitch) {
	return (pitch.octave * Note.COUNT) + pitch.note;
}

function stepsToPitch(steps) {
	var pitch = { beats: 1, note: Note.C, octave: Octave[2], };

	while (steps >= Note.COUNT) {
		pitch.octave = (pitch.octave + 1) % Octave.COUNT;
		steps -= Note.COUNT;
	}

	pitch.note += steps;

	// make sure pitch isn't outside a valid range
	if (pitch.note <= Note.NONE) {
		pitch.note = Note.C;
	}
	else if (pitch.note >= Note.COUNT) {
		pitch.note = Note.B;
	}

	if (pitch.octave <= Octave.NONE) {
		pitch.octave = Octave[2];
	}
	else if (pitch.octave >= Octave.COUNT) {
		pitch.octave = Octave[5];
	}

	return pitch;
}

function adjustPitch(pitch, stepDelta) {
	return stepsToPitch(pitchToSteps(pitch) + stepDelta);
}

function pitchDistance(pitchA, pitchB) {
	return pitchToSteps(pitchB) - pitchToSteps(pitchA);
}

function isMinPitch(pitch) {
	return pitchToSteps(pitch) <= pitchToSteps({ note: Note.C, octave: Octave[2] });
}

function isMaxPitch(pitch) {
	return pitchToSteps(pitch) >= pitchToSteps({ note: Note.B, octave: Octave[5] });
}

function SoundPlayer() {
	// frequencies (in hertz) for octave 0 (or is it octave 4?)
	var frequencies = [
		261.7, // middle C
		277.2,
		293.7,
		311.2,
		329.7,
		349.3,
		370.0,
		392.0,
		415.3,
		440.0,
		466.2,
		493.9,
	];

	// tempos are calculated as the duration of a 16th note, rounded to the nearest millisecond
	var tempos = {};
	tempos[Tempo.SLW] = 250; // 60bpm (adagio)
	tempos[Tempo.MED] = 188; // ~80bpm (andante) [exact would be 187.5 ms]
	tempos[Tempo.FST] = 125; // 120bpm (moderato)
	tempos[Tempo.XFST] = 94; // ~160bpm (allegro) [exact would be 93.75 ms]

	// arpeggio patterns expressed in scale degrees
	var arpeggioPattern = {};
	arpeggioPattern[ArpeggioPattern.UP] = [0, 2, 4, 7];
	arpeggioPattern[ArpeggioPattern.DWN] = [7, 4, 2, 0];
	arpeggioPattern[ArpeggioPattern.INT5] = [0, 4];
	arpeggioPattern[ArpeggioPattern.INT8] = [0, 7];

	this.getArpeggioSteps = function(tune) { return arpeggioPattern[tune.arpeggioPattern]; };

	function isPitchPlayable(pitch, key) {
		if (pitch.beats <= 0) {
			return false;
		}

		if (key === undefined || key === null) {
			return true;
		}

		// test if note is in the scale
		return (key.scale.indexOf(pitch.note) > -1)
			&& (key.notes[pitch.note] > Note.NONE)
			&& (key.notes[pitch.note] < Note.COUNT);
	}

	function pitchToChromatic(pitch, key) {
		if (pitch === undefined || pitch === null) {
			return null;
		}

		if (key === undefined || key === null) {
			return pitch;
		}

		// convert from solfa
		var octaveOffset = (pitch.note >= Solfa.COUNT) ? 1 : 0;

		return {
			beats: pitch.beats,
			octave: pitch.octave + octaveOffset,
			// todo : what about the scale limits?
			note: key.notes[(pitch.note % Solfa.COUNT)],
			blip: pitch.blip
		};
	}

	function makePitchFrequency(pitch) {
		// todo : this clamp shouldn't be required.. there's a bug in the pitch shifting somewhere
		var note = Math.max(0, pitch.note);
		var octave = (pitch.octave != undefined ? pitch.octave : Octave[4]);

		var octaveMin = Octave[2];
		var octaveMax = Octave[5];

		// make sure octave is in valid range
		octave = Math.max(octaveMin, Math.min(octave, octaveMax));
		var distFromMiddleC = octave - 2;

		var freq = frequencies[note] * Math.pow(2, distFromMiddleC);

		if (isNaN(freq)) {
			bitsy.log("invalid frequency " + pitch, "sound");
		}

		return freq;
	}

	var maxVolume = 15; // todo : should this be a system constant?
	var noteVolume = 5;

	var curTune = null;
	var isTunePaused = false;
	var barIndex = -1;
	var curArpeggio = [];

	var beat16 = 0;
	var beat16Timer = 0;
	var beat16Index = 0;

	// special settings
	var isLooping = false;
	var isMelodyMuted = false;
	var maxBeatCount = null;
	var muteTimer = 0; // allow temporary muting of all notes

	function arpeggiateBar(bar, key, pattern) {
		var arpeggio = [];

		if (key != undefined && key != null && isPitchPlayable(bar[0], key)) {
			for (var i = 0; i < arpeggioPattern[pattern].length; i++) {
				var pitch = { beats: 1, note: bar[0].note + arpeggioPattern[pattern][i], octave: bar[0].octave };
				arpeggio.push(pitchToChromatic(pitch, key));
			}
		}

		for (var i = 0; i < arpeggio.length; i++) {
			bitsy.log(i + ": " + serializeNote(arpeggio[i].note));
		}

		return arpeggio;
	};

	function playNote(pitch, instrument, options) {
		if (pitch.beats <= 0) {
			return;
		}

		var channel = bitsy.SOUND1;
		if (options != undefined && options.channel != undefined) {
			channel = options.channel;
		}

		var key = null;
		if (options != undefined && options.key != undefined) {
			key = options.key;
		}

		var beatLen = beat16;
		if (options != undefined && options.beatLen != undefined) {
			beatLen = options.beatLen;
		}

		if (isPitchPlayable(pitch, key)) {
			var freq = makePitchFrequency(pitchToChromatic(pitch, key));
			bitsy.sound(channel, (pitch.beats * beatLen), freq * 100, noteVolume, instrument);
		}
	}

	function sfxFrequencyAtTime(sfx, time) {
		var beatDelay = sfx.blip.beat.delay;
		var beatTime = sfx.blip.beat.time;
		var delta = Math.max(0, time - beatDelay) / beatTime;

		var pitchDelta = sfx.blip.doRepeat
			? (delta % sfx.frequencies.length)
			: Math.min(delta, sfx.frequencies.length - 1);

		sfx.pitchIndex = Math.floor(pitchDelta);
		var curFreq = sfx.frequencies[sfx.pitchIndex];

		// TODO : consider for future update
		// if (sfx.blip.doSlide) {
		// 	var nextPitchIndex = (sfx.pitchIndex + 1) % sfx.frequencies.length;
		// 	var nextFreq = sfx.frequencies[nextPitchIndex];
		// 	var d = pitchDelta - sfx.pitchIndex;
		// 	curFreq = curFreq + ((nextFreq - curFreq) * d);
		// }

		return curFreq;
	}

	function sfxVolumeAtTime(sfx, time) {
		var volume = 0;

		// use envelope settings to calculate volume
		var attack = sfx.blip.envelope.attack;
		var decay = sfx.blip.envelope.decay;
		var length = sfx.blip.envelope.length;
		var release = sfx.blip.envelope.release;
		if (time < attack) {
			// attack
			var t = time / attack;
			volume = Math.floor(sfxPeakVolume * t);
		}
		else if (time < attack + decay) {
			// decay
			var t = (time - attack) / decay;
			var d = sfx.blip.envelope.sustain - sfxPeakVolume;
			volume = Math.floor(sfxPeakVolume + (d * t));
		}
		else if (time < attack + decay + length) {
			// sustain
			volume = sfx.blip.envelope.sustain;
		}
		else if (time < attack + decay + length + release) {
			// release
			var t = (time - (attack + decay + length)) / release;
			volume = Math.floor(sfx.blip.envelope.sustain * (1 - t));
		}
		else {
			volume = 0;
		}

		return volume;
	}

	function updateSfx(dt) {
		// try limiting the max change per frame
		dt = Math.min(dt, 32);
		var isAnyBlipPlaying = false;

		if (activeSfx != null) {
			isAnyBlipPlaying = true;
			var sfx = activeSfx;

			sfx.timer += dt;
			if (sfx.timer >= sfx.duration) {
				sfx.timer = sfx.duration;
			}

			if (sfx.frequencies.length > 0) {
				// update pitch
				var prevPitchIndex = sfx.pitchIndex;
				var freq = sfxFrequencyAtTime(sfx, sfx.timer);
				if (prevPitchIndex != sfx.pitchIndex) {
					// pitch changed!
					bitsy.frequency(bitsy.SOUND1, freq * 100);
				}

				// update volume envelope
				bitsy.volume(bitsy.SOUND1, sfxVolumeAtTime(sfx, sfx.timer));
			}

			if (sfx.timer >= sfx.duration) {
				// turn off sound
				bitsy.volume(bitsy.SOUND1, 0);
				activeSfx = null;
			}
		}

		if (isMusicPausedForBlip && !isAnyBlipPlaying) {
			isMusicPausedForBlip = false;
		}
	}

	function updateTune(dt) {
		if (curTune === undefined || curTune === null) {
			return;
		}

		beat16Timer += dt;

		if (muteTimer > 0) {
			muteTimer -= dt;
		}

		if (beat16Timer >= beat16) {
			beat16Timer = 0;
			beat16Index++;

			if (beat16Index >= 16) {
				beat16Index = 0;

				if (!isLooping) {
					barIndex = (barIndex + 1) % curTune.melody.length;

					if (curTune.arpeggioPattern != ArpeggioPattern.OFF && curTune.key != null) {
						curArpeggio = arpeggiateBar(curTune.harmony[barIndex], curTune.key, curTune.arpeggioPattern);
					}
				}
			}

			if (muteTimer <= 0) {
				if (!isMelodyMuted) {
					// melody note
					var pitchA = curTune.melody[barIndex][beat16Index];
					if (pitchA.beats > 0) {
						// since they're played on the same channel, any melody note will cancel a blip
						activeSfx = null;
					}

					if (pitchA.blip != undefined && pitchA.beats > 0) {
						playBlip(blip[pitchA.blip], { interruptMusic: false, pitch: pitchA, key: curTune.key });
					}
					else {
						playNote(pitchA, curTune.instrumentA, { channel: bitsy.SOUND1, key: curTune.key });
					}
				}

				if (curTune.arpeggioPattern === ArpeggioPattern.OFF) {
					// harmony note
					var pitchB = curTune.harmony[barIndex][beat16Index];
					if (pitchB.blip != undefined && pitchB.beats > 0) {
						playBlip(blip[pitchB.blip], { interruptMusic: false, pitch: pitchB, key: curTune.key });
					}
					else {
						playNote(pitchB, curTune.instrumentB, { channel: bitsy.SOUND2, key: curTune.key });
					}
				}
				else {
					var arpPitch = curArpeggio[beat16Index % curArpeggio.length];
					if (arpPitch != undefined && arpPitch.beats > 0) {
						playNote(arpPitch, curTune.instrumentB, { channel: bitsy.SOUND2, beatLen: beat16 });
					}
				}
			}

			if (maxBeatCount != null && beat16Index >= (maxBeatCount - 1)) {
				// stop playback early
				curTune = null;
			}
		}
	}

	this.update = function(dt) {
		updateSfx(dt);
		if (!isTunePaused && !isMusicPausedForBlip) {
			updateTune(dt);
		}
	};

	this.playTune = function(tune, options) {
		curTune = tune;
		beat16Timer = 0;
		beat16Index = -1;
		barIndex = 0;

		isLooping = false;
		isMelodyMuted = false;
		maxBeatCount = null;

		// special options for the editor
		if (options != undefined) {
			if (options.barIndex != undefined) {
				barIndex = options.barIndex;
			}

			if (options.loop != undefined) {
				isLooping = options.loop;
			}

			if (options.melody != undefined) {
				isMelodyMuted = !options.melody;
			}

			if (options.beatCount != undefined) {
				maxBeatCount = options.beatCount;
			}
		}

		// update tempo
		beat16 = tempos[curTune.tempo];

		if (curTune.arpeggioPattern != ArpeggioPattern.OFF && curTune.key != null) {
			curArpeggio = arpeggiateBar(curTune.harmony[barIndex], curTune.key, curTune.arpeggioPattern);
		}
	};

	this.isTunePlaying = function() {
		return curTune != null;
	};

	this.getCurTuneId = function() {
		if (curTune) {
			return curTune.id;
		}

		return null;
	};

	this.stopTune = function() {
		curTune = null;
	};

	this.pauseTune = function() {
		isTunePaused = true;
	};

	this.resumeTune = function() {
		isTunePaused = false;
	};

	this.getBeat = function() {
		if (curTune == null) {
			return null;
		}

		return {
			bar : barIndex,
			beat : beat16Index,
		};
	};

	this.getBlipState = function() {
		return activeSfx;
	};

	this.playNote = function(pitch, instrument, channel, key) {
		beat16 = tempos[Tempo.SLW];
		muteTimer = beat16;
		playNote(pitch, instrument, { channel: channel, key: key });
	};

	this.setTempo = function(tempo) {
		beat16 = tempos[tempo];
	};

	this.setLooping = function(looping) {
		isLooping = looping;
	};

	/* SOUND EFFECTS */
	var sfxPeakVolume = 10; // todo : is this a good value?
	var activeSfx = null;
	var isMusicPausedForBlip = false;

	function createSfxState(blip, pitch, isPitchRandomized) {
		// bitsy.log("init sfx blip: " + blip.id);

		var sfxState = {
			blip : blip,
			pitchIndex : -1,
			frequencies : [],
			timer : 0,
			duration : 0,
		};

		// is it weird to track this both in the system *AND* the engine?
		sfxState.duration = (blip.envelope.attack + blip.envelope.decay + blip.envelope.length + blip.envelope.release);

		// adjust starting pitch
		var step = 0;
		if (pitch != null) {
			step = pitchDistance(blip.pitchA, pitch);
		}
		else if (isPitchRandomized > 0) {
			step = Math.floor(Math.random() * 6);
		}

		if (blip.pitchA.beats > 0) {
			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchA, step)));
		}
		if (blip.pitchB.beats > 0) {
			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchB, step)));
		}
		if (blip.pitchC.beats > 0) {
			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchC, step)));
		}

		return sfxState;
	}

	function playBlip(blip, options) {
		// default to pausing music while the blip plays (except when playing a blip as *part* of music)
		isMusicPausedForBlip = (options === undefined || options.interruptMusic === undefined) ? true : options.interruptMusic;

		// always play blips on channel 1
		var channel = bitsy.SOUND1;

		// other options
		var pitch = (options === undefined || options.pitch === undefined) ? null : options.pitch;
		var isPitchRandomized = (options === undefined || options.isPitchRandomized === undefined) ? false : options.isPitchRandomized;
		var key = (options != undefined && options.key != undefined) ? options.key : null;

		activeSfx = createSfxState(blip, pitchToChromatic(pitch, key), isPitchRandomized);
		bitsy.log("play blip: " + activeSfx.frequencies);

		bitsy.sound(
			channel,
			activeSfx.duration * 10, // HACK : mult by 10 is to avoid accidentally turning off early
			activeSfx.frequencies.length > 0 ? (activeSfx.frequencies[0] * 100) : 0,
			0, // volume
			activeSfx.blip.instrument);
	};

	this.playBlip = playBlip;

	this.isBlipPlaying = function() {
		return isMusicPausedForBlip; // todo : rename this variable?
	};

	// todo : should any of this stuff be moved into the tool code?
	this.sampleBlip = function(blip, sampleCount) {
		var sfx = createSfxState(blip, null, false);

		var minFreq = makePitchFrequency({ note: Note.C, octave: Octave[2] });
		var maxFreq = makePitchFrequency({ note: Note.B, octave: Octave[5] });

		// sample the frequency of the sound
		var frequencySamples = [];
		for (var i = 0; i < sampleCount; i++) {
			if (sfx.frequencies.length > 0) {
				var t = Math.floor((i / sampleCount) * sfx.duration);
				// get frequency at time
				var freq = sfxFrequencyAtTime(sfx, t);
				// normalize the sample
				freq = freq / (maxFreq - minFreq);

				frequencySamples.push(freq);
			}
			else {
				frequencySamples.push(0);
			}
		}

		// sample the volume envelope
		var amplitudeSamples = [];
		for (var i = 0; i < sampleCount; i++) {
			var t = Math.floor((i / sampleCount) * sfx.duration);
			amplitudeSamples.push(sfxVolumeAtTime(sfx, t) / maxVolume);
		}

		return {
			frequencies: frequencySamples,
			amplitudes: amplitudeSamples
		};
	};
}
</script>

<script>
/*
TODO:
- can I simplify this more now that I've removed the external resources stuff?
*/

function FontManager(packagedFontNames) {

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
	return fontExtension;
}

// place to store font data
var fontResources = {};

// load fonts from the editor
if (packagedFontNames != undefined && packagedFontNames != null && packagedFontNames.length > 0
		&& Resources != undefined && Resources != null) {

	for (var i = 0; i < packagedFontNames.length; i++) {
		var filename = packagedFontNames[i];
		fontResources[filename] = Resources[filename];
	}
}

// manually add resource
this.AddResource = function(filename, fontdata) {
	fontResources[filename] = fontdata;
}

this.ContainsResource = function(filename) {
	return fontResources[filename] != null;
}

function GetData(fontName) {
	return fontResources[fontName + fontExtension];
}
this.GetData = GetData;

function Create(fontData) {
	return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
	var fontData = self.GetData(fontName);
	return self.Create(fontData);
}

function Font(fontData) {
	bitsy.log("create font");

	var name = "unknown";
	var width = 6; // default size so if you have NO font or an invalid font it displays boxes
	var height = 8;
	var chardata = {};

	// create invalid char data at default size in case the font is missing
	var invalidCharData = {};
	updateInvalidCharData();

	this.getName = function() {
		return name;
	}

	this.getData = function() {
		return chardata;
	}

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.hasChar = function(char) {
		var codepoint = char.charCodeAt(0);
		return chardata[codepoint] != null;
	}

	this.getChar = function(char) {

		var codepoint = char.charCodeAt(0);

		if (chardata[codepoint] != null) {
			return chardata[codepoint];
		}
		else {
			return invalidCharData;
		}
	}

	this.allCharCodes = function() {
		var codeList = [];
		for (var code in chardata) {
			codeList.push(code);
		}
		return codeList;
	}

	function createCharData() {
		return { 
			width: width,
			height: height,
			offset: {
				x: 0,
				y: 0
			},
			spacing: width,
			data: [],
		};
	}

	function updateInvalidCharData() {
		invalidCharData = createCharData();
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				if (x < width-1 && y < height-1) {
					invalidCharData.data.push(1);
				}
				else {
					invalidCharData.data.push(0);
				}
			}
		}
	}

	function parseFont(fontData) {
		if (fontData == null) {
			return;
		}

		bitsy.log("split font lines");
		// NOTE: this is where we run out of memory - split creates a lot of memory issues
		// var lines = fontData.split("\n");
		bitsy.log("after split lines");

		var isReadingChar = false;
		var isReadingCharProperties = false;
		var curCharLineCount = 0;
		var curCharCode = 0;

		var lineStart = 0;
		var lineEnd = fontData.indexOf("\n", lineStart) != -1
			? fontData.indexOf("\n", lineStart)
			: fontData.length;

		// for (var i = 0; i < lines.length; i++) {
		// 	var line = lines[i];
		while (lineStart < fontData.length) {
			var line = fontData.substring(lineStart, lineEnd);
			// bitsy.log("parse font xx " + line);

			if (line[0] === "#") {
				// skip comment lines
			}
			else if (!isReadingChar) {
				// READING NON CHARACTER DATA LINE
				var args = line.split(" ");
				if (args[0] == "FONT") {
					name = args[1];
				}
				else if (args[0] == "SIZE") {
					width = parseInt(args[1]);
					height = parseInt(args[2]);
				}
				else if (args[0] == "CHAR") {
					isReadingChar = true;
					isReadingCharProperties = true;

					curCharLineCount = 0;
					curCharCode = parseInt(args[1]);
					chardata[curCharCode] = createCharData();
				}
			}
			else {
				// CHAR PROPERTIES
				if (isReadingCharProperties) {
					var args = line.split(" ");
					if (args[0].indexOf("CHAR_") == 0) { // Sub-properties start with "CHAR_"
						if (args[0] == "CHAR_SIZE") {
							// Custom character size - overrides the default character size for the font
							chardata[curCharCode].width = parseInt(args[1]);
							chardata[curCharCode].height = parseInt(args[2]);
							chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first
						}
						else if (args[0] == "CHAR_OFFSET") {
							// Character offset - shift the origin of the character on the X or Y axis
							chardata[curCharCode].offset.x = parseInt(args[1]);
							chardata[curCharCode].offset.y = parseInt(args[2]);
						}
						else if (args[0] == "CHAR_SPACING") {
							// Character spacing:
							// specify total horizontal space taken up by the character
							// lets chars take up more or less space on a line than its bitmap does
							chardata[curCharCode].spacing = parseInt(args[1]);
						}
					}
					else {
						isReadingCharProperties = false;
					}
				}

				// CHAR DATA
				if (!isReadingCharProperties) {
					// READING CHARACTER DATA LINE
					for (var j = 0; j < chardata[curCharCode].width; j++)
					{
						chardata[curCharCode].data.push( parseInt(line[j]) );
					}

					curCharLineCount++;
					if (curCharLineCount >= chardata[curCharCode].height) {
						isReadingChar = false;
					}
				}
			}

			lineStart = lineEnd + 1;
			lineEnd = fontData.indexOf("\n", lineStart) != -1
				? fontData.indexOf("\n", lineStart)
				: fontData.length;
		}

		// re-init invalid character box at the actual font size once it's loaded
		updateInvalidCharData();
	}

	bitsy.log("parse font");
	parseFont(fontData);

	bitsy.log("create font");
}

} // FontManager

</script>

<script>
var TransitionManager = function() {
	var transitionStart = null;
	var transitionEnd = null;

	var isTransitioning = false;
	var transitionTime = 0; // milliseconds
	var minStepTime = 125; // cap the frame rate
	var curStep = 0;

	this.BeginTransition = function(startRoom, startX, startY, endRoom, endX, endY, effectName) {
		bitsy.log("--- START ROOM TRANSITION ---");

		curEffect = effectName;

		var tmpRoom = player().room;
		var tmpX = player().x;
		var tmpY = player().y;

		if (transitionEffects[curEffect].showPlayerStart) {
			player().room = startRoom;
			player().x = startX;
			player().y = startY;
		}
		else {
			player().room = "_transition_none"; // kind of hacky!!
		}

		var startRoomPixels = createRoomPixelBuffer(room[startRoom]);
		var startPalette = getPal(room[startRoom].pal);
		var startImage = new PostProcessImage(startRoomPixels);
		transitionStart = new TransitionInfo(startImage, startPalette, startX, startY);

		if (transitionEffects[curEffect].showPlayerEnd) {
			player().room = endRoom;
			player().x = endX;
			player().y = endY;
		}
		else {
			player().room = "_transition_none";
		}

		var endRoomPixels = createRoomPixelBuffer(room[endRoom]);
		var endPalette = getPal(room[endRoom].pal);
		var endImage = new PostProcessImage(endRoomPixels);
		transitionEnd = new TransitionInfo(endImage, endPalette, endX, endY);

		isTransitioning = true;
		transitionTime = 0;
		curStep = 0;

		player().room = endRoom;
		player().x = endX;
		player().y = endY;

		bitsy.graphicsMode(bitsy.GFX_VIDEO);
	}

	this.UpdateTransition = function(dt) {
		if (!isTransitioning) {
			return;
		}

		transitionTime += dt;

		var maxStep = transitionEffects[curEffect].stepCount;

		if (transitionTime >= minStepTime) {
			curStep++;

			var step = curStep;
			bitsy.log("transition step " + step);

			if (transitionEffects[curEffect].paletteEffectFunc) {
				var colors = transitionEffects[curEffect].paletteEffectFunc(transitionStart, transitionEnd, (step / maxStep));
				updatePaletteWithTileColors(colors);
			}

			bitsy.fill(bitsy.VIDEO, tileColorStartIndex);

			for (var y = 0; y < bitsy.VIDEO_SIZE; y++) {
				for (var x = 0; x < bitsy.VIDEO_SIZE; x++) {
					var color = transitionEffects[curEffect].pixelEffectFunc(transitionStart, transitionEnd, x, y, (step / maxStep));
					bitsy.set(bitsy.VIDEO, (y * bitsy.VIDEO_SIZE) + x, color);
				}
			}

			transitionTime = 0;
		}

		if (curStep >= (maxStep - 1)) {
			isTransitioning = false;
			transitionTime = 0;
			transitionStart = null;
			transitionEnd = null;
			curStep = 0;

			if (transitionCompleteCallback != null) {
				transitionCompleteCallback();
			}
			transitionCompleteCallback = null;

			bitsy.graphicsMode(bitsy.GFX_MAP);
		}
	}

	this.IsTransitionActive = function() {
		return isTransitioning;
	}

	// todo : should this be part of the constructor?
	var transitionCompleteCallback = null;
	this.OnTransitionComplete = function(callback) {
		if (isTransitioning) { // TODO : safety check necessary?
			transitionCompleteCallback = callback;
		}
	}

	var transitionEffects = {};
	var curEffect = "none";
	this.RegisterTransitionEffect = function(name, effect) {
		transitionEffects[name] = effect;
	}

	this.RegisterTransitionEffect("none", {
		showPlayerStart : false,
		showPlayerEnd : false,
		paletteEffectFunc : function() {},
		pixelEffectFunc : function() {},
	});

	this.RegisterTransitionEffect("fade_w", { // TODO : have it linger on full white briefly?
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 6,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			var colors = [];

			if (delta < 0.5) {
				delta = delta / 0.5;

				for (var i = 0; i < start.Palette.length; i++) {
					colors.push(lerpColor(start.Palette[i], [255, 255, 255], delta));
				}
			}
			else {
				delta = ((delta - 0.5) / 0.5);

				for (var i = 0; i < end.Palette.length; i++) {
					colors.push(lerpColor([255, 255, 255], end.Palette[i], delta));
				}
			}

			return colors;
		},
	});

	this.RegisterTransitionEffect("fade_b", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 6,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			var colors = [];

			if (delta < 0.5) {
				delta = delta / 0.5;

				for (var i = 0; i < start.Palette.length; i++) {
					colors.push(lerpColor(start.Palette[i], [0, 0, 0], delta));
				}
			}
			else {
				delta = ((delta - 0.5) / 0.5);

				for (var i = 0; i < end.Palette.length; i++) {
					colors.push(lerpColor([0, 0, 0], end.Palette[i], delta));
				}
			}

			return colors;
		},
	});

	this.RegisterTransitionEffect("wave", {
		showPlayerStart : true,
		showPlayerEnd : true,
		stepCount : 12,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var waveDelta = delta < 0.5 ? delta / 0.5 : 1 - ((delta - 0.5) / 0.5);

			var offset = (pixelY + (waveDelta * waveDelta * 0.2 * start.Image.Height));
			var freq = 4;
			var size = 2 + (14 * waveDelta);
			pixelX += Math.floor(Math.sin(offset / freq) * size);

			if (pixelX < 0) {
				pixelX += start.Image.Width;
			}
			else if (pixelX >= start.Image.Width) {
				pixelX -= start.Image.Width;
			}

			var curImage = delta < 0.5 ? start.Image : end.Image;
			return curImage.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			return delta < 0.5 ? start.Palette : end.Palette;
		},
	});

	this.RegisterTransitionEffect("tunnel", {
		showPlayerStart : true,
		showPlayerEnd : true,
		stepCount : 12,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			if (delta <= 0.4) {
				var tunnelDelta = 1 - (delta / 0.4);

				var xDist = start.PlayerCenter.x - pixelX;
				var yDist = start.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > start.Image.Width * tunnelDelta) {
					return 0;
				}
				else {
					return start.Image.GetPixel(pixelX, pixelY);
				}
			}
			else if (delta <= 0.6) {
				return 0;
			}
			else {
				var tunnelDelta = (delta - 0.6) / 0.4;

				var xDist = end.PlayerCenter.x - pixelX;
				var yDist = end.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > end.Image.Width * tunnelDelta) {
					return 0;
				}
				else {
					return end.Image.GetPixel(pixelX, pixelY);
				}
			}
		},
		paletteEffectFunc : function(start, end, delta) {
			return delta < 0.5 ? start.Palette : end.Palette;
		},
	});

	function lerpPalettes(start, end, delta) {
		var colors = [];

		var maxLength = (start.Palette.length > end.Palette.length) ?
			start.Palette.length : end.Palette.length;

		for (var i = 0; i < maxLength; i++) {
			if (i < start.Palette.length && i < end.Palette.length) {
				colors.push(lerpColor(start.Palette[i], end.Palette[i], delta));
			}
			else if (i < start.Palette.length) {
				colors.push(lerpColor(
					start.Palette[i],
					end.Palette[end.Palette.length - 1],
					delta));
			}
			else if (i < end.Palette.length) {
				colors.push(lerpColor(
					start.Palette[start.Palette.length - 1],
					end.Palette[i],
					delta));
			}
		}

		return colors;
	}

	this.RegisterTransitionEffect("slide_u", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			if (slidePixelY >= 0) {
				return start.Image.GetPixel(pixelX, slidePixelY);
			}
			else {
				slidePixelY += start.Image.Height;
				return end.Image.GetPixel(pixelX, slidePixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_d", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			if (slidePixelY < start.Image.Height) {
				return start.Image.GetPixel(pixelX, slidePixelY);
			}
			else {
				slidePixelY -= start.Image.Height;
				return end.Image.GetPixel(pixelX, slidePixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_l", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			if (slidePixelX >= 0) {
				return start.Image.GetPixel(slidePixelX, pixelY);
			}
			else {
				slidePixelX += start.Image.Width;
				return end.Image.GetPixel(slidePixelX, pixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_r", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			if (slidePixelX < start.Image.Width) {
				return start.Image.GetPixel(slidePixelX, pixelY);
			}
			else {
				slidePixelX -= start.Image.Width;
				return end.Image.GetPixel(slidePixelX, pixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	// todo : move to Renderer()?
	function createRoomPixelBuffer(room) {
		var pixelBuffer = [];

		for (var i = 0; i < bitsy.VIDEO_SIZE * bitsy.VIDEO_SIZE; i++) {
			pixelBuffer.push(tileColorStartIndex);
		}

		var drawTileInPixelBuffer = function(sourceData, frameIndex, colorIndex, tx, ty, pixelBuffer) {
			var frameData = sourceData[frameIndex];

			for (var y = 0; y < bitsy.TILE_SIZE; y++) {
				for (var x = 0; x < bitsy.TILE_SIZE; x++) {
					var color = tileColorStartIndex + (frameData[y][x] === 1 ? colorIndex : 0);
					pixelBuffer[(((ty * bitsy.TILE_SIZE) + y) * bitsy.VIDEO_SIZE) + ((tx * bitsy.TILE_SIZE) + x)] = color;
				}
			}
		}

		//draw tiles
		for (i in room.tilemap) {
			for (j in room.tilemap[i]) {
				var id = room.tilemap[i][j];
				var x = parseInt(j);
				var y = parseInt(i);

				if (id != "0" && tile[id] != null) {
					drawTileInPixelBuffer(
						renderer.GetDrawingSource(tile[id].drw),
						tile[id].animation.frameIndex,
						tile[id].col,
						x,
						y,
						pixelBuffer);
				}
			}
		}

		//draw items
		for (var i = 0; i < room.items.length; i++) {
			var itm = room.items[i];
			drawTileInPixelBuffer(
				renderer.GetDrawingSource(item[itm.id].drw),
				item[itm.id].animation.frameIndex,
				item[itm.id].col,
				itm.x,
				itm.y,
				pixelBuffer);
		}

		//draw sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.room === room.id) {
				drawTileInPixelBuffer(
					renderer.GetDrawingSource(spr.drw),
					spr.animation.frameIndex,
					spr.col,
					spr.x,
					spr.y,
					pixelBuffer);
			}
		}

		return pixelBuffer;
	}

	function lerpColor(colorA, colorB, t) {
		return [
			colorA[0] + ((colorB[0] - colorA[0]) * t),
			colorA[1] + ((colorB[1] - colorA[1]) * t),
			colorA[2] + ((colorB[2] - colorA[2]) * t),
		];
	};
}; // TransitionManager()

// todo : is this wrapper still useful?
var PostProcessImage = function(imageData) {
	this.Width = bitsy.VIDEO_SIZE;
	this.Height = bitsy.VIDEO_SIZE;

	this.GetPixel = function(x, y) {
		return imageData[(y * bitsy.VIDEO_SIZE) + x];
	};

	this.GetData = function() {
		return imageData;
	};
};

var TransitionInfo = function(image, palette, playerX, playerY) {
	this.Image = image;

	this.Palette = palette;

	this.PlayerTilePos = {
		x: playerX,
		y: playerY
	};

	this.PlayerCenter = {
		x: Math.floor((playerX * bitsy.TILE_SIZE) + (bitsy.TILE_SIZE / 2)),
		y: Math.floor((playerY * bitsy.TILE_SIZE) + (bitsy.TILE_SIZE / 2))
	};
};
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
	return new Interpreter();
};

this.CreateUtils = function() {
	return new Utils();
};

var Interpreter = function() {
	var env = new Environment();
	var parser = new Parser( env );

	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

	// TODO -- maybe this should return a string instead othe actual script??
	this.Compile = function(scriptName, scriptStr) {
		var script = parser.Parse(scriptStr, scriptName);
		env.SetScript(scriptName, script);
	}
	this.Run = function(scriptName, exitHandler, objectContext) { // Runs pre-compiled script
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = env.GetScript(scriptName);

		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.Interpret = function(scriptStr, exitHandler, objectContext) { // Compiles and runs code immediately
		// bitsy.log("INTERPRET");
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = parser.Parse(scriptStr, "anonymous");
		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.HasScript = function(name) { return env.HasScript(name); };

	this.ResetEnvironment = function() {
		env = new Environment();
		parser = new Parser( env );
	}

	this.Parse = function(scriptStr, rootId) { // parses a script but doesn't save it
		return parser.Parse(scriptStr, rootId);
	}

	this.Eval = function(scriptTree, exitHandler) { // runs a script stored externally
		var localEnv = new LocalEnvironment(env); // TODO : does this need an object context?
		scriptTree.Eval(
			localEnv,
			function(result) {
				OnScriptReturn(result, exitHandler);
			});
	}

	function OnScriptReturn(result, exitHandler) {
		if (exitHandler != null) {
			exitHandler(result);
		}
	}

	this.CreateExpression = function(expStr) {
		return parser.CreateExpression(expStr);
	}

	this.SetVariable = function(name,value,useHandler) {
		env.SetVariable(name,value,useHandler);
	}

	this.DeleteVariable = function(name,useHandler) {
		env.DeleteVariable(name,useHandler);
	}
	this.HasVariable = function(name) {
		return env.HasVariable(name);
	}

	this.SetOnVariableChangeHandler = function(onVariableChange) {
		env.SetOnVariableChangeHandler(onVariableChange);
	}
	this.GetVariableNames = function() {
		return env.GetVariableNames();
	}
	this.GetVariable = function(name) {
		return env.GetVariable(name);
	}

	function DebugVisualizeScriptTree(scriptTree) {
		var printVisitor = {
			Visit : function(node,depth) {
				bitsy.log("-".repeat(depth) + "- " + node.ToString());
			},
		};

		scriptTree.VisitAll( printVisitor );
	}

	this.DebugVisualizeScriptTree = DebugVisualizeScriptTree;

	this.DebugVisualizeScript = function(scriptName) {
		DebugVisualizeScriptTree(env.GetScript(scriptName));
	}
}


var Utils = function() {
	// for editor ui
	this.CreateDialogBlock = function(children,doIndentFirstLine) {
		if (doIndentFirstLine === undefined) {
			doIndentFirstLine = true;
		}

		var block = new DialogBlockNode(doIndentFirstLine);

		for (var i = 0; i < children.length; i++) {
			block.AddChild(children[i]);
		}
		return block;
	}

	this.CreateOptionBlock = function() {
		var block = new DialogBlockNode(false);
		block.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		return block;
	}

	this.CreateItemConditionPair = function() {
		var itemFunc = this.CreateFunctionBlock("item", ["0"]);
		var condition = new ExpNode("==", itemFunc, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateVariableConditionPair = function() {
		var varNode = this.CreateVariableNode("a");
		var condition = new ExpNode("==", varNode, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateDefaultConditionPair = function() {
		var condition = this.CreateElseNode();
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateEmptySayFunc = function() {
		return new FuncNode("say", [new LiteralNode("...")]);
	}

	this.CreateFunctionBlock = function(name, initParamValues) {
		var parameters = [];
		for (var i = 0; i < initParamValues.length; i++) {
			parameters.push(new LiteralNode(initParamValues[i]));
		}

		var node = new FuncNode(name, parameters);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	// TODO : rename ParseStringToLiteralNode?
	this.CreateLiteralNode = function(str) {
		if (str === "true") {
			return new LiteralNode(true);
		}
		else if (str === "false") {
			return new LiteralNode(false);
		}
		else if (!isNaN(parseFloat(str))) {
			return new LiteralNode(parseFloat(str));
		}
		else {
			return new LiteralNode(str);
		}
	}

	this.CreateVariableNode = function(variableName) {
		return new VarNode(variableName);
	}

	this.CreatePropertyNode = function(propertyName, literalValue) {
		var varNode = new VarNode(propertyName);
		var valNode = new LiteralNode(literalValue);
		var node = new FuncNode("property", [varNode, valNode]);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	this.CreateElseNode = function() {
		return new ElseNode();
	}

	this.CreateStringLiteralNode = function(str) {
		return new LiteralNode(str);
	}

	// TODO : need to split up code & dialog blocks :|
	this.CreateCodeBlock = function() {
		return new CodeBlockNode();
	}

	this.ChangeSequenceType = function(oldSequence, type) {
		if(type === "sequence") {
			return new SequenceNode(oldSequence.children);
		}
		else if(type === "cycle") {
			return new CycleNode(oldSequence.children);
		}
		else if(type === "shuffle") {
			return new ShuffleNode(oldSequence.children);
		}
		return oldSequence;
	}

	this.CreateSequenceBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var sequence = new SequenceNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateCycleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var sequence = new CycleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateShuffleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var sequence = new ShuffleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateIfBlock = function() {
		var leftNode = new CodeBlockNode();
		leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
		var rightNode = new LiteralNode( 1 );
		var condition1 = new ExpNode("==", leftNode, rightNode );

		var condition2 = new ElseNode();

		var result1 = new DialogBlockNode();
		result1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var result2 = new DialogBlockNode();
		result2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
		var block = new CodeBlockNode();
		block.AddChild( ifNode );
		return block;
	}

	this.ReadDialogScript = function(lines, i) {
		var scriptStr = "";
		if (lines[i] === Sym.DialogOpen) {
			scriptStr += lines[i] + "\n";
			i++;
			while(lines[i] != Sym.DialogClose) {
				scriptStr += lines[i] + "\n";
				i++;
			}
			scriptStr += lines[i];
			i++;
		}
		else {
			scriptStr += lines[i];
			i++;
		}
		return { script:scriptStr, index:i };
	}

	// TODO this.ReadCodeScript (reads through code open and close symbols), and this.ReadScript

	this.EnsureDialogBlockFormat = function(dialogStr) {
		// TODO -- what if it's already enclosed in dialog symbols??
		if(dialogStr.indexOf('\n') > -1) {
			dialogStr = Sym.DialogOpen + "\n" + dialogStr + "\n" + Sym.DialogClose;
		}
		return dialogStr;
	}

	this.RemoveDialogBlockFormat = function(source) {
		var sourceLines = source.split("\n");
		var dialogStr = "";
		if(sourceLines[0] === Sym.DialogOpen) {
			// multi line
			var i = 1;
			while (i < sourceLines.length && sourceLines[i] != Sym.DialogClose) {
				dialogStr += sourceLines[i] + (sourceLines[i+1] != Sym.DialogClose ? '\n' : '');
				i++;
			}
		}
		else {
			// single line
			dialogStr = source;
		}
		return dialogStr;
	}

	this.SerializeDialogNodeList = function(nodeList) {
		var tempBlock = new DialogBlockNode(false);
		 // set children directly to avoid breaking the parenting chain for this temp operation
		tempBlock.children = nodeList;
		return tempBlock.Serialize();
	}

	this.GetOperatorList = function() {
		return [Sym.Set].concat(Sym.Operators);
	}

	this.IsInlineCode = function(node) {
		return isInlineCode(node);
	}
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function deprecatedFunc(environment,parameters,onReturn) {
	bitsy.log("BITSY SCRIPT WARNING: Tried to use deprecated function");
	onReturn(null);
}

function sayFunc(environment, parameters, onReturn) {
	if (parameters[0] != undefined && parameters[0] != null) {
		var textStr = "" + parameters[0];
		environment.GetDialogBuffer().AddText(textStr);
		environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
	}
	else {
		onReturn(null);
	}
}

function linebreakFunc(environment, parameters, onReturn) {
	// bitsy.log("LINEBREAK FUNC");
	environment.GetDialogBuffer().AddLinebreak();
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function pagebreakFunc(environment, parameters, onReturn) {
	environment.GetDialogBuffer().AddPagebreak(function() { onReturn(null); });
}

function drawFunc(environment, parameters, onReturn) {
	var drawingId = parameters[0];
	environment.GetDialogBuffer().AddDrawing(drawingId);
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function drawSpriteFunc(environment, parameters, onReturn) {
	var spriteId = parameters[0];

	// check if id parameter is actually a name
	if (names.sprite[spriteId] != undefined) {
		spriteId = names.sprite[spriteId];
	}

	var drawingId = sprite[spriteId].drw;
	drawFunc(environment, [drawingId], onReturn);
}

function drawTileFunc(environment, parameters, onReturn) {
	var tileId = parameters[0];

	// check if id parameter is actually a name
	if (names.tile[tileId] != undefined) {
		tileId = names.tile[tileId];
	}

	var drawingId = tile[tileId].drw;
	drawFunc(environment, [drawingId], onReturn);
}

function drawItemFunc(environment, parameters, onReturn) {
	var itemId = parameters[0];

	// check if id parameter is actually a name
	if (names.item[itemId] != undefined) {
		itemId = names.item[itemId];
	}

	var drawingId = item[itemId].drw;
	drawFunc(environment, [drawingId], onReturn);
}

function printFontFunc(environment, parameters, onReturn) {
	var allCharacters = "";
	var font = fontManager.Get(fontName);
	var codeList = font.allCharCodes();
	for (var i = 0; i < codeList.length; i++) {
		allCharacters += String.fromCharCode(codeList[i]) + " ";
	}
	sayFunc(environment, [allCharacters], onReturn);
}

function itemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];

	if (names.item[itemId] != undefined) {
		// id is actually a name
		itemId = names.item[itemId];
	}

	var curItemCount = player().inventory[itemId] ? player().inventory[itemId] : 0;

	if (parameters.length > 1) {
		// TODO : is it a good idea to force inventory to be >= 0?
		player().inventory[itemId] = Math.max(0, parseInt(parameters[1]));
		curItemCount = player().inventory[itemId];

		if (onInventoryChanged != null) {
			onInventoryChanged(itemId);
		}
	}

	onReturn(curItemCount);
}

function toggleTextEffect(environment, name) {
	if (environment.GetDialogBuffer().hasTextEffect(name)) {
		environment.GetDialogBuffer().popTextEffect(name);
	}
	else {
		environment.GetDialogBuffer().pushTextEffect(name, []);
	}
}

function color1Func(environment, parameters, onReturn) {
	toggleTextEffect(environment, "clr1");
	onReturn(null);
}

function color2Func(environment, parameters, onReturn) {
	toggleTextEffect(environment, "clr2");
	onReturn(null);
}

function color3Func(environment, parameters, onReturn) {
	toggleTextEffect(environment, "clr3");
	onReturn(null);
}

function colorFunc(environment, parameters, onReturn) {
	environment.GetDialogBuffer().pushTextEffect("clr", parameters);
	onReturn(null);
}

function colorPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("clr")) {
		environment.GetDialogBuffer().popTextEffect("clr");
	}
	onReturn(null);
}

function rainbowFunc(environment, parameters, onReturn) {
	toggleTextEffect(environment, "rbw");
	onReturn(null);
}

function rainbowPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("rbw")) {
		environment.GetDialogBuffer().popTextEffect("rbw");
	}
	onReturn(null);
}

function wavyFunc(environment, parameters, onReturn) {
	toggleTextEffect(environment, "wvy");
	onReturn(null);
}

function wavyPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("wvy")) {
		environment.GetDialogBuffer().popTextEffect("wvy");
	}
	onReturn(null);
}

function shakyFunc(environment, parameters, onReturn) {
	toggleTextEffect(environment, "shk");
	onReturn(null);
}

function shakyPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("shk")) {
		environment.GetDialogBuffer().popTextEffect("shk");
	}
	onReturn(null);
}

function propertyFunc(environment, parameters, onReturn) {
	var outValue = null;

	if (parameters.length > 0 && parameters[0]) {
		var propertyName = parameters[0];

		if (environment.HasProperty(propertyName)) {
			// TODO : in a future update I can handle the case of initializing a new property
			// after which we can move this block outside the HasProperty check
			if (parameters.length > 1) {
				var inValue = parameters[1];
				environment.SetProperty(propertyName, inValue);
			}

			outValue = environment.GetProperty(propertyName);
		}
	}

	bitsy.log("PROPERTY! " + propertyName + " " + outValue);

	onReturn(outValue);
}

function endFunc(environment,parameters,onReturn) {
	isEnding = true;
	isNarrating = true;
	dialogRenderer.SetCentered(true);
	dialogRenderer.DrawTextbox();
	onReturn(null);
}

function exitFunc(environment, parameters, onReturn) {
	var destRoom;
	var destX;
	var destY;

	if (parameters.length >= 1) {
		destRoom = parameters[0];

		// is it a name?
		if (names.room[destRoom] != undefined) {
			destRoom = names.room[destRoom];
		}
	}

	if (parameters.length >= 3) {
		destX = parseInt(parameters[1]);
		destY = parseInt(parameters[2]);
	}

	if (parameters.length >= 4) {
		var transitionEffect = parameters[3];

		transition.BeginTransition(
			player().room,
			player().x,
			player().y,
			destRoom,
			destX,
			destY,
			transitionEffect);
		transition.UpdateTransition(0);
	}

	var movePlayerAndResumeScript = function() {
		if (destRoom != undefined && destX != undefined && destY != undefined) {
			// update world state
			player().room = destRoom;
			player().x = destX;
			player().y = destY;
			state.room = destRoom;

			// update game state
			initRoom(state.room);
		}

		if (dialogRenderer) {
			dialogRenderer.updateTextboxPosition();
		}

		// resume dialog script
		onReturn(state.room);
	};

	// TODO : this doesn't play nice with pagebreak because it thinks the dialog is finished!
	if (transition.IsTransitionActive()) {
		transition.OnTransitionComplete(movePlayerAndResumeScript);
	}
	else {
		movePlayerAndResumeScript();
	}
}

function tuneFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var tuneId = parameters[0];

		// check if id parameter is actually a name
		if (names.tune[tuneId] != undefined) {
			tuneId = names.tune[tuneId];
		}

		if (soundPlayer) {
			if (tuneId === "0") {
				soundPlayer.stopTune();
			}
			else if (state.tune != tuneId) {
				soundPlayer.playTune(tune[tuneId]);
			}
		}

		state.tune = tuneId;
	}

	onReturn(state.tune);
}

function blipFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var blipId = parameters[0];

		// check if id parameter is actually a name
		if (names.blip[blipId] != undefined) {
			blipId = names.blip[blipId];
		}

		soundPlayer.playBlip(blip[blipId]);
	}

	// if a dialog skip is happening, stop it and force a redraw of the textbox
	if (dialogBuffer) {
		if (dialogBuffer.tryInterruptSkip()) {
			dialogRenderer.Draw(dialogBuffer, 0, true /* disableOnPrint */);
		}
	}

	onReturn(null);
}

/*
// TODO : use later?
function yakFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var blipId = parameters[0];

		// check if id parameter is actually a name
		if (names.blip[blipId] != undefined) {
			blipId = names.blip[blipId];
		}

		environment.GetDialogBuffer().pushTextEffect("yak", [blipId]);
	}

	onReturn(null);
}

function yakPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("yak")) {
		environment.GetDialogBuffer().popTextEffect("yak");
	}

	onReturn(null);
}
*/

function paletteFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var palId = parameters[0];

		// check if id parameter is actually a name
		if (names.palette[palId] != undefined) {
			palId = names.palette[palId];
		}

		updatePalette(palId);
	}

	onReturn(state.pal);
}

function avatarFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var sprId = parameters[0];

		// check if id parameter is actually a name
		if (names.sprite[sprId] != undefined) {
			sprId = names.sprite[sprId];
		}

		// override the avatar's current appearance
		state.ava = sprId;

		// redraw the avatar with its new appearance
		drawRoom(room[state.room], { redrawAvatar: true });
	}

	onReturn(state.ava);
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
	// bitsy.log("SET " + left.name);

	if(left.type != "variable") {
		// not a variable! return null and hope for the best D:
		onReturn( null );
		return;
	}

	right.Eval(environment,function(rVal) {
		environment.SetVariable( left.name, rVal );
		// bitsy.log("VAL " + environment.GetVariable( left.name ) );
		left.Eval(environment,function(lVal) {
			onReturn( lVal );
		});
	});
}
function equalExp(environment,left,right,onReturn) {
	// bitsy.log("EVAL EQUAL");
	// bitsy.log(left);
	// bitsy.log(right);
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal === rVal );
		});
	});
}
function greaterExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal > rVal );
		});
	});
}
function lessExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal < rVal );
		});
	});
}
function greaterEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal >= rVal );
		});
	});
}
function lessEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal <= rVal );
		});
	});
}
function multExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal * rVal );
		});
	});
}
function divExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal / rVal );
		});
	});
}
function addExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal + rVal );
		});
	});
}
function subExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal - rVal );
		});
	});
}

/* ENVIRONMENT */
var Environment = function() {
	var dialogBuffer = null;
	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
	this.GetDialogBuffer = function() { return dialogBuffer; };

	var functionMap = {};

	// dialog
	functionMap["say"] = sayFunc;
	functionMap["br"] = linebreakFunc;
	functionMap["pg"] = pagebreakFunc;

	// text effects
	functionMap["wvy"] = wavyFunc;
	functionMap["/wvy"] = wavyPopFunc;
	functionMap["shk"] = shakyFunc;
	functionMap["/shk"] = shakyPopFunc;
	functionMap["rbw"] = rainbowFunc;
	functionMap["/rbw"] = rainbowPopFunc;
	functionMap["clr"] = colorFunc;
	functionMap["/clr"] = colorPopFunc;
	// drawing text effects
	functionMap["drwt"] = drawTileFunc;
	functionMap["drws"] = drawSpriteFunc;
	functionMap["drwi"] = drawItemFunc;

	// room
	functionMap["end"] = endFunc;
	functionMap["exit"] = exitFunc;
	functionMap["pal"] = paletteFunc;
	functionMap["ava"] = avatarFunc;

	// inventory & variables
	functionMap["item"] = itemFunc;
	functionMap["property"] = propertyFunc;

	// sound
	functionMap["tune"] = tuneFunc;
	functionMap["blip"] = blipFunc;

	// legacy
	functionMap["clr1"] = color1Func;
	functionMap["clr2"] = color2Func;
	functionMap["clr3"] = color3Func;
	functionMap["print"] = sayFunc;
	functionMap["printTile"] = drawTileFunc;
	functionMap["printSprite"] = drawSpriteFunc;
	functionMap["printItem"] = drawItemFunc;

	// DEBUG
	functionMap["_debugOnlyPrintFont"] = printFontFunc;

	// EXPERIMENTAL
	// functionMap["yak"] = yakFunc;
	// functionMap["/yak"] = yakPopFunc;

	this.HasFunction = function(name) { return functionMap[name] != undefined; };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		functionMap[name](env, parameters, onReturn);
	}

	var variableMap = {};

	this.HasVariable = function(name) { return variableMap[name] != undefined; };
	this.GetVariable = function(name) { return variableMap[name]; };
	this.SetVariable = function(name,value,useHandler) {
		// bitsy.log("SET VARIABLE " + name + " = " + value);
		if(useHandler === undefined) useHandler = true;
		variableMap[name] = value;
		if(onVariableChangeHandler != null && useHandler){
			onVariableChangeHandler(name);
		}
	};
	this.DeleteVariable = function(name,useHandler) {
		if(useHandler === undefined) useHandler = true;
		if(variableMap[name] != undefined) {
			variableMap.delete(name);
			if(onVariableChangeHandler != null && useHandler) {
				onVariableChangeHandler(name);
			}
		}
	};

	var operatorMap = {};
	operatorMap["="] = setExp;
	operatorMap["=="] = equalExp;
	operatorMap[">"] = greaterExp;
	operatorMap["<"] = lessExp;
	operatorMap[">="] = greaterEqExp;
	operatorMap["<="] = lessEqExp;
	operatorMap["*"] = multExp;
	operatorMap["/"] = divExp;
	operatorMap["+"] = addExp;
	operatorMap["-"] = subExp;

	this.HasOperator = function(sym) { return operatorMap[sym] != undefined; };
	this.EvalOperator = function(sym,left,right,onReturn) {
		operatorMap[ sym ]( this, left, right, onReturn );
	}

	var scriptMap = {};
	this.HasScript = function(name) { return scriptMap[name] != undefined; };
	this.GetScript = function(name) { return scriptMap[name]; };
	this.SetScript = function(name,script) { scriptMap[name] = script; };

	var onVariableChangeHandler = null;
	this.SetOnVariableChangeHandler = function(onVariableChange) {
		onVariableChangeHandler = onVariableChange;
	}
	this.GetVariableNames = function() {
		var variableNames = [];

		for (var key in variableMap) {
			variableNames.push(key);
		}

		return variableNames;
	}
}

// Local environment for a single run of a script: knows local context
var LocalEnvironment = function(parentEnvironment) {
	// this.SetDialogBuffer // not allowed in local environment?
	this.GetDialogBuffer = function() { return parentEnvironment.GetDialogBuffer(); };

	this.HasFunction = function(name) { return parentEnvironment.HasFunction(name); };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalFunction(name,parameters,onReturn,env);
	}

	this.HasVariable = function(name) { return parentEnvironment.HasVariable(name); };
	this.GetVariable = function(name) { return parentEnvironment.GetVariable(name); };
	this.SetVariable = function(name,value,useHandler) { parentEnvironment.SetVariable(name,value,useHandler); };
	// this.DeleteVariable // not needed in local environment?

	this.HasOperator = function(sym) { return parentEnvironment.HasOperator(sym); };
	this.EvalOperator = function(sym,left,right,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalOperator(sym,left,right,onReturn,env);
	};

	// TODO : I don't *think* any of this is required by the local environment
	// this.HasScript
	// this.GetScript
	// this.SetScript

	// TODO : pretty sure these debug methods aren't required by the local environment either
	// this.SetOnVariableChangeHandler
	// this.GetVariableNames

	/* Here's where specific local context data goes:
	 * this includes access to the object running the script
	 * and any properties it may have (so far only "locked")
	 */

	// The local environment knows what object called it -- currently only used to access properties
	var curObject = null;
	this.HasObject = function() { return curObject != undefined && curObject != null; }
	this.SetObject = function(object) { curObject = object; }
	this.GetObject = function() { return curObject; }

	// accessors for properties of the object that's running the script
	this.HasProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return true;
		}
		else {
			return false;
		}
	};
	this.GetProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return curObject.property[name]; // TODO : should these be getters and setters instead?
		}
		else {
			return null;
		}
	};
	this.SetProperty = function(name, value) {
		// NOTE : for now, we need to gaurd against creating new properties
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			curObject.property[name] = value;
		}
	};
}

function leadingWhitespace(depth) {
	var str = "";
	for(var i = 0; i < depth; i++) {
		str += "  "; // two spaces per indent
	}
	// bitsy.log("WHITESPACE " + depth + " ::" + str + "::");
	return str;
}

/* NODES */
var TreeRelationship = function() {
	this.parent = null;
	this.children = [];

	this.AddChild = function(node) {
		this.children.push(node);
		node.parent = this;
	};

	this.AddChildren = function(nodeList) {
		for (var i = 0; i < nodeList.length; i++) {
			this.AddChild(nodeList[i]);
		}
	};

	this.SetChildren = function(nodeList) {
		this.children = [];
		this.AddChildren(nodeList);
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.rootId = null; // for debugging
	this.GetId = function() {
		// bitsy.log(this);
		if (this.rootId != null) {
			return this.rootId;
		}
		else if (this.parent != null) {
			var parentId = this.parent.GetId();
			if (parentId != null) {
				return parentId + "_" + this.parent.children.indexOf(this);
			}
		}
		else {
			return null;
		}
	}
}

function DialogBlockNode(doIndentFirstLine) {
	TreeRelationship.call(this);

	this.type = "dialog_block";

	this.Eval = function(environment, onReturn) {
		// bitsy.log("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// bitsy.log(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// bitsy.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	if (doIndentFirstLine === undefined) {
		doIndentFirstLine = true; // This is just for serialization
	}

	this.Serialize = function(depth) {
		if (depth === undefined) {
			depth = 0;
		}

		var str = "";
		var lastNode = null;

		for (var i = 0; i < this.children.length; i++) {

			var curNode = this.children[i];

			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");

			if (shouldIndentFirstLine || shouldIndentAfterLinebreak) {
				str += leadingWhitespace(depth);
			}

			str += curNode.Serialize(depth);

			lastNode = curNode;
		}

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function CodeBlockNode() {
	TreeRelationship.call(this);

	this.type = "code_block";

	this.Eval = function(environment, onReturn) {
		// bitsy.log("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// bitsy.log(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// bitsy.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	this.Serialize = function(depth) {
		if(depth === undefined) {
			depth = 0;
		}

		// bitsy.log("SERIALIZE BLOCK!!!");
		// bitsy.log(depth);
		// bitsy.log(doIndentFirstLine);

		var str = "{"; // todo: increase scope of Sym?

		// TODO : do code blocks ever have more than one child anymore????
		for (var i = 0; i < this.children.length; i++) {
			var curNode = this.children[i];
			str += curNode.Serialize(depth);
		}

		str += "}";

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function isInlineCode(node) {
	return isTextEffectBlock(node) || isUndefinedBlock(node) || isMultilineListBlock(node);
}

function isUndefinedBlock(node) {
	return node.type === "code_block" && node.children.length > 0 && node.children[0].type === "undefined";
}

var textEffectBlockNames = ["clr1", "clr2", "clr3", "wvy", "shk", "rbw", "printSprite", "printItem", "printTile", "print", "say", "br"];
function isTextEffectBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0 && node.children[0].type === "function") {
			var func = node.children[0];
			return textEffectBlockNames.indexOf(func.name) != -1;
		}
	}
	return false;
}

var listBlockTypes = ["sequence", "cycle", "shuffle", "if"];
function isMultilineListBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0) {
			var child = node.children[0];
			return listBlockTypes.indexOf(child.type) != -1;
		}
	}
	return false;
}

// for round-tripping undefined code through the parser (useful for hacks!)
function UndefinedNode(sourceStr) {
	TreeRelationship.call(this);

	this.type = "undefined";
	this.source = sourceStr;

	this.Eval = function(environment,onReturn) {
		toggleTextEffect(environment, "_debug_highlight");
		sayFunc(environment, ["{" + sourceStr + "}"], function() {
			onReturn(null);
		});
		toggleTextEffect(environment, "_debug_highlight");
	}

	this.Serialize = function(depth) {
		return this.source;
	}

	this.ToString = function() {
		return "undefined" + " " + this.GetId();
	}
}

function FuncNode(name, args) {
	TreeRelationship.call(this);

	this.type = "function";
	this.name = name;
	this.args = args;

	this.Eval = function(environment,onReturn) {
		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var self = this; // hack to deal with scope (TODO : move up higher?)

		var argumentValues = [];
		var i = 0;

		function evalArgs(args, done) {
			// TODO : really hacky way to make we get the first
			// symbol's NAME instead of its variable value
			// if we are trying to do something with a property
			if (self.name === "property" && i === 0 && i < args.length) {
				if (args[i].type === "variable") {
					argumentValues.push(args[i].name);
					i++;
				}
				else {
					// first argument for a property MUST be a variable symbol
					// -- so skip everything if it's not!
					i = args.length;
				}
			}

			if (i < args.length) {
				// Evaluate each argument
				args[i].Eval(
					environment,
					function(val) {
						argumentValues.push(val);
						i++;
						evalArgs(args, done);
					});
			}
			else {
				done();
			}
		};

		evalArgs(
			this.args,
			function() {
				if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
					events.Raise("script_node_exit", { id: self.GetId() });
				}

				environment.EvalFunction(self.name, argumentValues, onReturn);
			});
	}

	this.Serialize = function(depth) {
		var isDialogBlock = this.parent.type === "dialog_block";
		if (isDialogBlock && this.name === "say") {
			// TODO this could cause problems with "real" print functions
			return this.args[0].value; // first argument should be the text of the {print} func
		}
		else if (isDialogBlock && this.name === "br") {
			return "\n";
		}
		else {
			var str = "";
			str += this.name;
			for(var i = 0; i < this.args.length; i++) {
				str += " ";
				str += this.args[i].Serialize(depth);
			}
			return str;
		}
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

function LiteralNode(value) {
	TreeRelationship.call(this);

	this.type = "literal";
	this.value = value;

	this.Eval = function(environment,onReturn) {
		onReturn(this.value);
	};

	this.Serialize = function(depth) {
		var str = "";

		if (this.value === null) {
			return str;
		}

		if (typeof this.value === "string") {
			str += '"';
		}

		str += this.value;

		if (typeof this.value === "string") {
			str += '"';
		}

		return str;
	};

	this.ToString = function() {
		return this.type + " " + this.value + " " + this.GetId();
	};
}

function VarNode(name) {
	TreeRelationship.call(this);

	this.type = "variable";
	this.name = name;

	this.Eval = function(environment,onReturn) {
		// bitsy.log("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
		if( environment.HasVariable(this.name) )
			onReturn( environment.GetVariable( this.name ) );
		else
			onReturn(null); // not a valid variable -- return null and hope that's ok
	} // TODO: might want to store nodes in the variableMap instead of values???

	this.Serialize = function(depth) {
		var str = "" + this.name;
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

function ExpNode(operator, left, right) {
	TreeRelationship.call(this);

	this.type = "operator";
	this.operator = operator;
	this.left = left;
	this.right = right;

	this.Eval = function(environment,onReturn) {
		// bitsy.log("EVAL " + this.operator);
		var self = this; // hack to deal with scope
		environment.EvalOperator( this.operator, this.left, this.right, 
			function(val){
				// bitsy.log("EVAL EXP " + self.operator + " " + val);
				onReturn(val);
			} );
		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
	};

	this.Serialize = function(depth) {
		var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

		if (!isNegativeNumber) {
			var str = "";

			if (this.left != undefined && this.left != null) {
				str += this.left.Serialize(depth) + " ";
			}

			str += this.operator;

			if (this.right != undefined && this.right != null) {
				str += " " + this.right.Serialize(depth);
			}

			return str;
		}
		else {
			return this.operator + this.right.Serialize(depth); // hacky but seems to work
		}
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		if(this.left != null)
			this.left.VisitAll( visitor, depth + 1 );
		if(this.right != null)
			this.right.VisitAll( visitor, depth + 1 );
	};

	this.ToString = function() {
		return this.type + " " + this.operator + " " + this.GetId();
	};
}

function SequenceBase() {
	TreeRelationship.call(this);

	this.Serialize = function(depth) {
		var str = "";
		str += this.type + "\n";
		for (var i = 0; i < this.children.length; i++) {
			str += leadingWhitespace(depth + 1) + Sym.List + " ";
			str += this.children[i].Serialize(depth + 2);
			str += "\n";
		}
		str += leadingWhitespace(depth);
		return str;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function SequenceNode(options) {
	SequenceBase.call(this);

	this.type = "sequence";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// bitsy.log("SEQUENCE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
	}
}

function CycleNode(options) {
	SequenceBase.call(this);

	this.type = "cycle";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// bitsy.log("CYCLE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
		else {
			index = 0;
		}
	}
}

function ShuffleNode(options) {
	SequenceBase.call(this);

	this.type = "shuffle";
	this.AddChildren(options);

	var optionsShuffled = [];
	function shuffle(options) {
		optionsShuffled = [];
		var optionsUnshuffled = options.slice();
		while (optionsUnshuffled.length > 0) {
			var i = Math.floor(Math.random() * optionsUnshuffled.length);
			optionsShuffled.push(optionsUnshuffled.splice(i,1)[0]);
		}
	}
	shuffle(this.children);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		optionsShuffled[index].Eval(environment, onReturn);
		
		index++;
		if (index >= this.children.length) {
			shuffle(this.children);
			index = 0;
		}
	}
}

// TODO : rename? ConditionalNode?
function IfNode(conditions, results, isSingleLine) {
	TreeRelationship.call(this);

	this.type = "if";

	for (var i = 0; i < conditions.length; i++) {
		this.AddChild(new ConditionPairNode(conditions[i], results[i]));
	}

	var self = this;
	this.Eval = function(environment, onReturn) {
		// bitsy.log("EVAL IF");
		var i = 0;
		function TestCondition() {
			self.children[i].Eval(environment, function(result) {
				if (result.conditionValue == true) {
					onReturn(result.resultValue);
				}
				else if (i+1 < self.children.length) {
					i++;
					TestCondition();
				}
				else {
					onReturn(null);
				}
			});
		};
		TestCondition();
	};

	if (isSingleLine === undefined) {
		isSingleLine = false; // This is just for serialization
	}

	this.Serialize = function(depth) {
		var str = "";
		if(isSingleLine) {
			// HACKY - should I even keep this mode???
			str += this.children[0].children[0].Serialize() + " ? " + this.children[0].children[1].Serialize();
			if (this.children.length > 1 && this.children[1].children[0].type === Sym.Else) {
				str += " " + Sym.ElseExp + " " + this.children[1].children[1].Serialize();
			}
		}
		else {
			str += "\n";
			for (var i = 0; i < this.children.length; i++) {
				str += this.children[i].Serialize(depth);
			}
			str += leadingWhitespace(depth);
		}
		return str;
	};

	this.IsSingleLine = function() {
		return isSingleLine;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	};

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

function ConditionPairNode(condition, result) {
	TreeRelationship.call(this);

	this.type = "condition_pair";

	this.AddChild(condition);
	this.AddChild(result);

	var self = this;

	this.Eval = function(environment, onReturn) {
		self.children[0].Eval(environment, function(conditionSuccess) {
			if (conditionSuccess) {
				self.children[1].Eval(environment, function(resultValue) {
					onReturn({ conditionValue:true, resultValue:resultValue });
				});
			}
			else {
				onReturn({ conditionValue:false });
			}
		});
	};

	this.Serialize = function(depth) {
		var str = "";
		str += leadingWhitespace(depth + 1);
		str += Sym.List + " " + this.children[0].Serialize(depth) + " " + Sym.ConditionEnd + Sym.Linebreak;
		str += this.children[1].Serialize(depth + 2) + Sym.Linebreak;
		return str;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	};

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function ElseNode() {
	TreeRelationship.call(this);

	this.type = Sym.Else;

	this.Eval = function(environment, onReturn) {
		onReturn(true);
	};

	this.Serialize = function() {
		return Sym.Else;
	};

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

var Sym = {
	DialogOpen : '"""',
	DialogClose : '"""',
	CodeOpen : "{",
	CodeClose : "}",
	Linebreak : "\n", // just call it "break" ?
	Separator : ":",
	List : "-",
	String : '"',
	ConditionEnd : "?",
	Else : "else",
	ElseExp : ":", // special shorthand for expressions (deprecate?)
	Set : "=",
	Operators : ["==", ">=", "<=", ">", "<", "-", "+", "/", "*"], // operators need to be in reverse order of precedence
};

var Parser = function(env) {
	var environment = env;

	this.Parse = function(scriptStr, rootId) {
		var rootNode = new DialogBlockNode();
		rootNode.rootId = rootId;
		var state = new ParserState(rootNode, scriptStr);

		if (state.MatchAhead(Sym.DialogOpen)) {
			// multi-line dialog block
			var dialogStr = state.ConsumeBlock(Sym.DialogOpen + Sym.Linebreak, Sym.Linebreak + Sym.DialogClose);
			rootNode = new DialogBlockNode();
			rootNode.rootId = rootId; // hacky!!
			state = new ParserState(rootNode, dialogStr);
			state = ParseDialog(state);
		}
		else {
			// single-line dialog block
			state = ParseDialog(state);
		}

		return state.rootNode;
	};

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// bitsy.log(str);
			str = "" + str; // hack to turn single chars into strings
			// bitsy.log(str);
			// bitsy.log(str.length);
			for (var j = 0; j < str.length; j++) {
				if (i + j >= sourceStr.length) {
					return false;
				}
				else if (str[j] != sourceStr[i+j]) {
					return false;
				}
			}
			return true;
		}
		this.Peak = function(end) {
			var str = "";
			var j = i;
			// bitsy.log(j);
			while (j < sourceStr.length && end.indexOf(sourceStr[j]) == -1) {
				str += sourceStr[j];
				j++;
			}
			// bitsy.log("PEAK ::" + str + "::");
			return str;
		}
		this.ConsumeBlock = function(open, close, includeSymbols) {
			if (includeSymbols === undefined || includeSymbols === null) {
				includeSymbols = false;
			}

			var startIndex = i;

			var matchCount = 0;
			if (this.MatchAhead(open)) {
				matchCount++;
				this.Step(open.length);
			}

			while (matchCount > 0 && !this.Done()) {
				if (this.MatchAhead(close)) {
					matchCount--;
					this.Step( close.length );
				}
				else if (this.MatchAhead(open)) {
					matchCount++;
					this.Step(open.length);
				}
				else {
					this.Step();
				}
			}

			if (includeSymbols) {
				return sourceStr.slice(startIndex, i);
			}
			else {
				return sourceStr.slice(startIndex + open.length, i - close.length);
			}
		}

		this.Print = function() { bitsy.log(sourceStr); };
		this.Source = function() { return sourceStr; };
	};

	/*
		ParseDialog():
		This function adds {print} nodes and linebreak {br} nodes to display text,
		interleaved with bracketed code nodes for functions and flow control,
		such as text effects {shk} {wvy} or sequences like {cycle} and {shuffle}.
		The parsing of those code blocks is handled by ParseCode.

		Note on parsing newline characters:
		- there should be an implicit linebreak {br} after each dialog line
		- a "dialog line" is defined as any line that either:
			- 1) contains dialog text (any text outside of a code block)
			- 2) is entirely empty (no text, no code)
			- *or* 3) contains a list block (sequence, cycle, shuffle, or conditional)
		- lines *only* containing {code} blocks are not dialog lines

		NOTE TO SELF: all the state I'm storing in here feels like
		evidence that the parsing system kind of broke down at this point :(
		Maybe it would feel better if I move into the "state" object
	*/
	function ParseDialog(state) {
		var curLineNodeList = [];
		var curText = "";
		var curLineIsEmpty = true;
		var curLineContainsDialogText = false;
		var prevLineIsDialogLine = false;

		var curLineIsDialogLine = function() {
			return curLineContainsDialogText || curLineIsEmpty;
		}

		var resetLineStateForNewLine = function() {
			prevLineIsDialogLine = curLineIsDialogLine();
			curLineContainsDialogText = false;
			curLineIsEmpty = true;
			curText = "";
			curLineNodeList = [];
		}

		var tryAddTextNodeToList = function() {
			if (curText.length > 0) {
				var sayNode = new FuncNode("say", [new LiteralNode(curText)]);
				curLineNodeList.push(sayNode);

				curText = "";
				curLineIsEmpty = false;
				curLineContainsDialogText = true;
			}
		}

		var addCodeNodeToList = function() {
			var codeSource = state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			var codeState = new ParserState(new CodeBlockNode(), codeSource);
			codeState = ParseCode(codeState);
			var codeBlockNode = codeState.rootNode;
			curLineNodeList.push(codeBlockNode);

			curLineIsEmpty = false;

			// lists count as dialog text, because they can contain it
			if (isMultilineListBlock(codeBlockNode)) {
				curLineContainsDialogText = true;
			}
		}

		var tryAddLinebreakNodeToList = function() {
			if (prevLineIsDialogLine) {
				var linebreakNode = new FuncNode("br", []);
				curLineNodeList.unshift(linebreakNode);
			}
		}

		var addLineNodesToParent = function() {
			for (var i = 0; i < curLineNodeList.length; i++) {
				state.curNode.AddChild(curLineNodeList[i]);
			}
		}

		while (!state.Done()) {
			if (state.MatchAhead(Sym.CodeOpen)) { // process code block
				// add any buffered text to a print node, and parse the code
				tryAddTextNodeToList();
				addCodeNodeToList();
			}
			else if (state.MatchAhead(Sym.Linebreak)) { // process new line
				// add any buffered text to a print node, 
				// and add a linebreak if we are between two dialog lines
				tryAddTextNodeToList();
				tryAddLinebreakNodeToList();

				// since we've reached the end of a line
				// add stored nodes for this line to the parent node we are building,
				// and reset state for the next line
				addLineNodesToParent();
				resetLineStateForNewLine();

				state.Step();
			}
			else {
				// continue adding text to the current text buffer
				curText += state.Char();
				state.Step();
			}
		}

		// to make sure we don't leave anything behind:
		// add buffered text to a print node and add all nodes
		// to the current parent node
		tryAddTextNodeToList();
		tryAddLinebreakNodeToList();
		addLineNodesToParent();

		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

		var dialogState = new ParserState(new DialogBlockNode(), dialogStr);
		dialogState = ParseDialog( dialogState );

		state.curNode.AddChild( dialogState.rootNode );

		return state;
	}

	/*
		ParseConditional():
		A conditional contains a list of conditions that can be
		evaluated to true or false, followed by more dialog
		that will be evaluated if the condition is true. The first
		true condition is the one that gets evaluated.
	*/
	function ParseConditional(state) {
		var conditionStrings = [];
		var resultStrings = [];
		var curIndex = -1;
		var requiredLeadingWhitespace = -1;

		// TODO : very similar to sequence parsing - can we share anything?
		function parseConditionalItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewCondition = false;
			var encounteredNonWhitespace = false;
			var encounteredConditionEnd = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewCondition = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// if this is the condition, we need to track whether we've
				// reached the end of the condition
				if (isNewCondition && !encounteredConditionEnd) {
					if (state.Char() === Sym.ConditionEnd) {
						encounteredConditionEnd = true;
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					if (!encounteredConditionEnd) { // skip all characters including & after the condition end
						lineText += state.Char();
					}
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewCondition:isNewCondition };
		}

		// TODO : this is copied from sequence parsing; share?
		function trimLeadingWhitespace(text, trimLength) {
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseConditionalItemLine(state);

			if (lineResults.isNewCondition) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curIndex++;
				conditionStrings[curIndex] = "";
				resultStrings[curIndex] = "";
			}

			// to avoid extra newlines in nested conditionals, only count lines
			// that at least match the whitespace count of the initial line
			// NOTE: see the comment in sequence parsing for more details
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);

				if (lineResults.isNewCondition) {
					conditionStrings[curIndex] += trimmedText;
				}
				else {
					resultStrings[curIndex] += trimmedText + Sym.Linebreak;
				}
			}
		}

		// hack: cut off the trailing newlines from all the result strings
		resultStrings = resultStrings.map(function(result) { return result.slice(0,-1); });

		var conditions = [];
		for (var i = 0; i < conditionStrings.length; i++) {
			var str = conditionStrings[i].trim();
			if (str === Sym.Else) {
				conditions.push(new ElseNode());
			}
			else {
				var exp = CreateExpression(str);
				conditions.push(exp);
			}
		}

		var results = [];
		for (var i = 0; i < resultStrings.length; i++) {
			var str = resultStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			results.push(dialogBlock);
		}

		state.curNode.AddChild(new IfNode(conditions, results));

		return state;
	}

	function IsSequence(str) {
		// bitsy.log("IsSequence? " + str);
		return str === "sequence" || str === "cycle" || str === "shuffle";
	}

	/*
		ParseSequence():
		Sequence nodes contain a list of dialog block nodes. The order those
		nodes are evaluated is determined by the type of sequence:
		- sequence: each child node evaluated once in order
		- cycle: repeats from the beginning after all nodes evaluate
		- shuffle: evaluate in a random order

		Each item in a sequence is sepearated by a "-" character.
		The seperator must come at the beginning of the line,
		but may be preceded by whitespace (in any amount).

		About whitespace: Whitespace at the start of a line
		is ignored if it less than or equal to the count of
		whitespace that preceded the list separator ("-") at
		the start of that item. (The count also includes the
		seperator and the extra space after the seperator.)
	 */
	function ParseSequence(state, sequenceType) {
		var itemStrings = [];
		var curItemIndex = -1; // -1 indicates not reading an item yet
		var requiredLeadingWhitespace = -1;

		function parseSequenceItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewListItem = false;
			var encounteredNonWhitespace = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewListItem = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					lineText += state.Char();
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewListItem:isNewListItem };
		}

		function trimLeadingWhitespace(text, trimLength) {
			// the split and join is necessary because a single "line"
			// can contain sequences that may contain newlines of their own
			// (we treat them all as one "line" for sequence parsing purposes)
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseSequenceItemLine(state);

			if (lineResults.isNewListItem) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curItemIndex++;
				itemStrings[curItemIndex] = "";
			}

			// to avoid double counting closing lines (empty ones ending in a curly brace)
			// we only allow lines that have at least as much whitespace as the start of the list item
			// TODO : I think right now this leads to a bug if the list item's indentation is less than
			// its parent code block... hopefully that won't be a big deal for now
			// (NOTE: I think the bug could be fixed by only applying this to the FINAL line of an item, but
			// that would require more consideration and testing)
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);
				itemStrings[curItemIndex] += trimmedText + Sym.Linebreak;
			}
		}

		// a bit hacky: cut off the trailing newlines from all the items
		itemStrings = itemStrings.map(function(item) { return item.slice(0,-1); });

		var options = [];
		for (var i = 0; i < itemStrings.length; i++) {
			var str = itemStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(false /* doIndentFirstLine */), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			options.push(dialogBlock);
		}

		if (sequenceType === "sequence") {
			state.curNode.AddChild(new SequenceNode(options));
		}
		else if (sequenceType === "cycle") {
			state.curNode.AddChild(new CycleNode(options));
		}
		else if (sequenceType === "shuffle") {
			state.curNode.AddChild(new ShuffleNode(options));
		}

		return state;
	}

	function ParseFunction(state, funcName) {
		bitsy.log("~~~ PARSE FUNCTION " + funcName);

		var args = [];

		var curSymbol = "";
		function OnSymbolEnd() {
			curSymbol = curSymbol.trim();
			// bitsy.log("PARAMTER " + curSymbol);
			args.push( StringToValue(curSymbol) );
			// bitsy.log(args);
			curSymbol = "";
		}

		while( !( state.Char() === "\n" || state.Done() ) ) {
			if( state.MatchAhead(Sym.CodeOpen) ) {
				var codeBlockState = new ParserState(new CodeBlockNode(), state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose));
				codeBlockState = ParseCode( codeBlockState );
				var codeBlock = codeBlockState.rootNode;
				args.push( codeBlock );
				curSymbol = "";
			}
			else if( state.MatchAhead(Sym.String) ) {
				/* STRING LITERAL */
				var str = state.ConsumeBlock(Sym.String, Sym.String);
				// bitsy.log("STRING " + str);
				args.push( new LiteralNode(str) );
				curSymbol = "";
			}
			else if(state.Char() === " " && curSymbol.length > 0) {
				OnSymbolEnd();
			}
			else {
				curSymbol += state.Char();
			}
			state.Step();
		}

		if(curSymbol.length > 0) {
			OnSymbolEnd();
		}

		state.curNode.AddChild( new FuncNode( funcName, args ) );

		return state;
	}

	function IsValidVariableName(str) {
		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		var isValid = reg.test(str);
		// bitsy.log("VALID variable??? " + isValid);
		return isValid;
	}

	function StringToValue(valStr) {
		if(valStr[0] === Sym.CodeOpen) {
			// CODE BLOCK!!!
			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
			var codeBlockState = new ParserState(new CodeBlockNode(), codeStr);
			codeBlockState = ParseCode( codeBlockState );
			return codeBlockState.rootNode;
		}
		else if(valStr[0] === Sym.String) {
			// STRING!!
			// bitsy.log("STRING");
			var str = "";
			var i = 1;
			while (i < valStr.length && valStr[i] != Sym.String) {
				str += valStr[i];
				i++;
			}
			// bitsy.log(str);
			return new LiteralNode( str );
		}
		else if(valStr === "true") {
			// BOOL
			return new LiteralNode( true );
		}
		else if(valStr === "false") {
			// BOOL
			return new LiteralNode( false );
		}
		else if( !isNaN(parseFloat(valStr)) ) {
			// NUMBER!!
			// bitsy.log("NUMBER!!! " + valStr);
			return new LiteralNode( parseFloat(valStr) );
		}
		else if(IsValidVariableName(valStr)) {
			// VARIABLE!!
			// bitsy.log("VARIABLE");
			return new VarNode(valStr); // TODO : check for valid potential variables
		}
		else {
			// uh oh
			return new LiteralNode(null);
		}
	}

	function CreateExpression(expStr) {
		expStr = expStr.trim();

		function IsInsideString(index) {
			var inString = false;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.String)
					inString = !inString;

				if(index === i)
					return inString;
			}
			return false;
		}

		function IsInsideCode(index) {
			var count = 0;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.CodeOpen)
					count++;
				else if(expStr[i] === Sym.CodeClose)
					count--;

				if(index === i)
					return count > 0;
			}
			return false;
		}

		var operator = null;

		// set is special because other operator can look like it, and it has to go first in the order of operations
		var setIndex = expStr.indexOf(Sym.Set);
		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
			if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
				// ok it actually IS a set operator and not ==, >=, or <=
				operator = Sym.Set;
				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
				var right = CreateExpression( expStr.substring(setIndex+Sym.Set.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		// special if "expression" for single-line if statements
		var ifIndex = expStr.indexOf(Sym.ConditionEnd);
		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
			operator = Sym.ConditionEnd;
			var conditionStr = expStr.substring(0,ifIndex).trim();
			var conditions = [ CreateExpression(conditionStr) ];

			var resultStr = expStr.substring(ifIndex+Sym.ConditionEnd.length);
			var results = [];
			function AddResult(str) {
				var dialogBlockState = new ParserState(new DialogBlockNode(), str);
				dialogBlockState = ParseDialog( dialogBlockState );
				var dialogBlock = dialogBlockState.rootNode;
				results.push( dialogBlock );
			}

			var elseIndex = resultStr.indexOf(Sym.ElseExp); // does this need to test for strings?
			if(elseIndex > -1) {
				conditions.push( new ElseNode() );

				var elseStr = resultStr.substring(elseIndex+Sym.ElseExp.length);
				var resultStr = resultStr.substring(0,elseIndex);

				AddResult( resultStr.trim() );
				AddResult( elseStr.trim() );
			}
			else {
				AddResult( resultStr.trim() );
			}

			return new IfNode( conditions, results, true /*isSingleLine*/ );
		}

		for( var i = 0; (operator == null) && (i < Sym.Operators.length); i++ ) {
			var opSym = Sym.Operators[i];
			var opIndex = expStr.indexOf( opSym );
			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
				operator = opSym;
				var left = CreateExpression( expStr.substring(0,opIndex) );
				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		if( operator == null ) {
			return StringToValue(expStr);
		}
	}
	this.CreateExpression = CreateExpression;

	function IsWhitespace(str) {
		return ( str === " " || str === "\t" || str === "\n" );
	}

	function IsExpression(str) {
		var tempState = new ParserState(null, str); // hacky
		var textOutsideCodeBlocks = "";

		while (!tempState.Done()) {
			if (tempState.MatchAhead(Sym.CodeOpen)) {
				tempState.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			}
			else {
				textOutsideCodeBlocks += tempState.Char();
				tempState.Step();
			}
		}

		var containsAnyExpressionOperators = (textOutsideCodeBlocks.indexOf(Sym.ConditionEnd) != -1) ||
				(textOutsideCodeBlocks.indexOf(Sym.Set) != -1) ||
				(Sym.Operators.some(function(opSym) { return textOutsideCodeBlocks.indexOf(opSym) != -1; }));

		return containsAnyExpressionOperators;
	}

	function IsLiteral(str) {
		var isBool = str === "true" || str === "false";
		var isNum = !isNaN(parseFloat(str));
		var isStr = str[0] === '"' && str[str.length-1] === '"';
		var isVar = IsValidVariableName(str);
		var isEmpty = str.length === 0;
		return isBool || isNum || isStr || isVar || isEmpty;
	}

	function ParseExpression(state) {
		var line = state.Source(); // state.Peak( [Sym.Linebreak] ); // TODO : remove the linebreak thing
		// bitsy.log("EXPRESSION " + line);
		var exp = CreateExpression(line);
		// bitsy.log(exp);
		state.curNode.AddChild(exp);
		state.Step(line.length);
		return state;
	}

	function IsConditionalBlock(state) {
		var peakToFirstListSymbol = state.Peak([Sym.List]);

		var foundListSymbol = peakToFirstListSymbol < state.Source().length;

		var areAllCharsBeforeListWhitespace = true;
		for (var i = 0; i < peakToFirstListSymbol.length; i++) {
			if (!IsWhitespace(peakToFirstListSymbol[i])) {
				areAllCharsBeforeListWhitespace = false;
			}
		}

		var peakToFirstConditionSymbol = state.Peak([Sym.ConditionEnd]);
		peakToFirstConditionSymbol = peakToFirstConditionSymbol.slice(peakToFirstListSymbol.length);
		var hasNoLinebreakBetweenListAndConditionEnd = peakToFirstConditionSymbol.indexOf(Sym.Linebreak) == -1;

		return foundListSymbol && 
			areAllCharsBeforeListWhitespace && 
			hasNoLinebreakBetweenListAndConditionEnd;
	}

	function ParseCode(state) {
		if (IsConditionalBlock(state)) {
			state = ParseConditional(state);
		}
		else if (environment.HasFunction(state.Peak([" "]))) { // TODO --- what about newlines???
			var funcName = state.Peak([" "]);
			state.Step(funcName.length);
			state = ParseFunction(state, funcName);
		}
		else if (IsSequence(state.Peak([" ", Sym.Linebreak]))) {
			var sequenceType = state.Peak([" ", Sym.Linebreak]);
			state.Step(sequenceType.length);
			state = ParseSequence(state, sequenceType);
		}
		else if (IsLiteral(state.Source()) || IsExpression(state.Source())) {
			state = ParseExpression(state);
		}
		else {
			var undefinedSrc = state.Peak([]);
			var undefinedNode = new UndefinedNode(undefinedSrc);
			state.curNode.AddChild(undefinedNode);
		}

		// just go to the end now
		while (!state.Done()) {
			state.Step();
		}

		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );
		var codeState = new ParserState(new CodeBlockNode(), codeStr);
		codeState = ParseCode( codeState );
		state.curNode.AddChild( codeState.rootNode );
		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {
	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
	var textboxInfo = {
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
		padding_vert : 2,
		padding_horz : 4,
		arrow_height : 5,
	};

	var font = null;
	this.SetFont = function(f) {
		font = f;
		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;

		// todo : clean up all the scale stuff
		var textboxScaleW = textboxInfo.width * getTextScale();
		var textboxScaleH = textboxInfo.height * getTextScale();
		bitsy.textbox(false, 0, 0, textboxScaleW, textboxScaleH);
	}

	this.GetPixelsPerRow = function() {
		return (textboxInfo.width - (textboxInfo.padding_horz * 2)) * getTextScale();
	}

	// todo : cache this value? it shouldn't really change in the middle of a game
	function getTextScale() {
		return bitsy.textMode() === bitsy.TXT_LOREZ ? 1 : 2;
	}

	function relativeFontWidth() {
		return Math.ceil(font.getWidth() / getTextScale());
	}

	function relativeFontHeight() {
		return Math.ceil(font.getHeight() / getTextScale());
	}

	this.ClearTextbox = function() {
		bitsy.fill(bitsy.TEXTBOX, textBackgroundIndex);
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	// todo : I can stop doing this every frame right?
	this.DrawTextbox = function() {
		if (isCentered) {
			// todo : will the height calculations always work?
			bitsy.textbox(true, textboxInfo.left, ((bitsy.VIDEO_SIZE / 2) - (textboxInfo.height / 2)));
		}
		else if (player().y < (bitsy.MAP_SIZE / 2)) {
			// bottom
			bitsy.textbox(true, textboxInfo.left, (bitsy.VIDEO_SIZE - textboxInfo.bottom - textboxInfo.height));
		}
		else {
			// top
			bitsy.textbox(true, textboxInfo.left, textboxInfo.top);
		}
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];

	this.DrawNextArrow = function() {
		// bitsy.log("draw arrow!");
		var text_scale = getTextScale();
		var textboxScaleW = textboxInfo.width * text_scale;
		var textboxScaleH = textboxInfo.height * text_scale;

		var top = (textboxInfo.height - 5) * text_scale;
		var left = (textboxInfo.width - (5 + 4)) * text_scale;
		if (textDirection === TextDirection.RightToLeft) { // RTL hack
			left = 4 * text_scale;
		}

		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							var px = left + (x * text_scale) + sx;
							var py = top + (y * text_scale) + sy;
							bitsy.set(bitsy.TEXTBOX, (py * textboxScaleW) + px, textArrowIndex);
						}
					}
				}
			}
		}
	};

	function drawCharData(charData, textScale, top, left, width, height, color) {
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				var i = (y * width) + x;
				if (charData[i] == 1) {
					bitsy.set(bitsy.TEXTBOX, ((top + y) * (textboxInfo.width * textScale)) + (left + x), color);
				}
			}
		}
	}

	this.DrawChar = function(char, row, col, leftPos) {
		// characters with effects need to be redrawn every frame
		if (char.effectList.length > 0) {
			char.redraw = true;
		}

		// skip characters that are already drawn and don't need to be updated
		if (!char.redraw) {
			return;
		}
		char.redraw = false;

		var text_scale = getTextScale();
		var charData = char.bitmap;
		var top;
		var left;

		if (char.effectList.length > 0) {
			// clear the pixels from the previous frame
			top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);
			left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);
			drawCharData(charData, text_scale, top, left, char.width, char.height, textBackgroundIndex);
		}

		// compute render offset *every* frame
		char.offset = {
			x: char.base_offset.x,
			y: char.base_offset.y
		};
		char.SetPosition(row, col);
		char.ApplyEffects(effectTime);

		top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);
		left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);

		drawCharData(charData, text_scale, top, left, char.width, char.height, char.color);

		// TODO : consider for a future update?
		/*
		if (soundPlayer && char.blip && char.hasPlayedBlip != true) {
			soundPlayer.playBlip(blip[char.blip], { isPitchRandomized: true });
			char.hasPlayedBlip = true;
		}
		*/

		// call printHandler for character
		if (!disableOnPrintHandlers) {
			char.OnPrint();
		}
	};

	var effectTime = 0; // TODO this variable should live somewhere better

	var shouldUpdateTextboxSettings = true;
	var shouldClearTextbox = true;
	var shouldDrawArrow = true;

	var disableOnPrintHandlers = false;

	this.Draw = function(buffer, dt, disableOnPrint) {
		disableOnPrintHandlers = (disableOnPrint === true);

		// bitsy.log("draw dialog");
		if (buffer.DidFlipPageThisFrame()) {
			shouldClearTextbox = true;
			shouldDrawArrow = true;
		}

		effectTime += dt;

		if (shouldUpdateTextboxSettings) {
			bitsy.log("draw textbox");
			this.DrawTextbox(); // todo : rename to something more accurate
			shouldUpdateTextboxSettings = false;
		}

		if (shouldClearTextbox) {
			// bitsy.log("clear textbox");
			this.ClearTextbox();
			shouldClearTextbox = false;
		}

		// bitsy.log("draw chars");
		buffer.ForEachActiveChar(this.DrawChar);

		if (buffer.CanContinue() && shouldDrawArrow) {
			// bitsy.log("draw next arrow");
			this.DrawNextArrow();
			shouldDrawArrow = false;
		}

		if (buffer.DidPageFinishThisFrame() && onPageFinish != null) {
			bitsy.log("page finished");
			onPageFinish();
		}

		// bitsy.log("draw dialog end");
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?

		shouldUpdateTextboxSettings = true;
		shouldClearTextbox = true;
		shouldDrawArrow = true;
	}

	this.updateTextboxPosition = function() {
		shouldUpdateTextboxSettings = true;
	};

	// this.CharsPerRow = function() {
	// 	return textboxInfo.charsPerRow;
	// }
}

var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var activeTextEffects = [];
	var activeTextEffectParameters = [];
	var font = null;
	var arabicHandler = new ArabicHandler();
	var onDialogEndCallbacks = [];

	this.SetFont = function(f) {
		font = f;
	};

	this.SetPixelsPerRow = function(n) {
		pixelsPerRow = n;
	};

	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			// bitsy.log(charCount);

			var leftPos = 0;
			if (textDirection === TextDirection.RightToLeft) {
				leftPos = 24 * 8; // hack -- I think this is correct?
			}

			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char) {
					if (textDirection === TextDirection.RightToLeft) {
						leftPos -= char.spacing;
					}
					// bitsy.log(j + " " + leftPos);

					// handler( char, i /*rowIndex*/, j /*colIndex*/ );
					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)

					if (textDirection === TextDirection.LeftToRight) {
						leftPos += char.spacing;
					}
				}
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;

		afterManualPagebreak = false;

		activeTextEffects = [];

		onDialogEndCallbacks = [];

		isActive = false;
	};

	this.DoNextChar = function() {
		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;
		}

		if (this.CurChar() != null) {
			if (this.CurChar().isPageBreak) {
				// special case for page break marker character!
				isDialogReadyToContinue = true;
				didPageFinishThisFrame = true;
			}
			
			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
		}
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	var isSkipping = false;

	this.Skip = function() {
		bitsy.log("SKIPPP");
		isSkipping = true;

		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;

		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount() && isSkipping) {
			this.DoNextChar();

			if (isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}

		if (isSkipping) {
			rowIndex = this.CurRowCount() - 1;
			charIndex = this.CurCharCount() - 1;
		}

		isSkipping = false;
	};

	this.tryInterruptSkip = function() {
		if (isSkipping) {
			isSkipping = false;
			return true;
		}

		return false;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		isActive = false; // no more text to show... this should be a sign to stop rendering dialog

		for (var i = 0; i < onDialogEndCallbacks.length; i++) {
			onDialogEndCallbacks[i]();
		}
	}

	var afterManualPagebreak = false; // is it bad to track this state like this?

	this.Continue = function() {
		bitsy.log("CONTINUE");

		// if we used a page break character to continue we need
		// to run whatever is in the script afterwards! // TODO : make this comment better
		if (this.CurChar().isPageBreak) {
			// hacky: always treat a page break as the end of dialog
			// if there's more dialog later we re-activate the dialog buffer
			this.EndDialog();
			afterManualPagebreak = true;
			this.CurChar().OnContinue();
			return false;
		}
		if (pageIndex + 1 < this.CurPageCount()) {
			bitsy.log("FLIP PAGE!");
			//start next page
			this.FlipPage();
			return true; /* hasMoreDialog */
		}
		else {
			bitsy.log("END DIALOG!");
			bitsy.textbox(false);
			//end dialog mode
			this.EndDialog();
			return false; /* hasMoreDialog */
		}
	};

	var isActive = false;
	this.IsActive = function() { return isActive; };

	this.OnDialogEnd = function(callback) {
		if (!isActive) {
			callback();
		}
		else {
			onDialogEndCallbacks.push(callback);
		}
	}

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar() {
		this.redraw = true;

		this.effectList = [];
		this.effectParameterList = [];

		this.color = textColorIndex; // white
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

		this.col = 0;
		this.row = 0;

		this.SetPosition = function(row,col) {
			// bitsy.log("SET POS");
			// bitsy.log(this);
			this.row = row;
			this.col = col;
		};

		this.ApplyEffects = function(time) {
			// bitsy.log("APPLY EFFECTS! " + time);
			for (var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i];
				// bitsy.log("FX " + effectName);
				TextEffects[effectName].doEffect(this, time, this.effectParameterList[i]);
			}
		};

		var printHandler = null; // optional function to be called once on printing character
		this.SetPrintHandler = function(handler) {
			printHandler = handler;
		};
		this.OnPrint = function() {
			if (printHandler != null) {
				// bitsy.log("PRINT HANDLER ---- DIALOG BUFFER");
				printHandler();
				printHandler = null; // only call handler once (hacky)
			}
		};

		this.bitmap = [];
		this.width = 0;
		this.height = 0;
		this.base_offset = { // hacky name
 			x: 0,
			y: 0
		};
		this.spacing = 0;
	}

	function DialogFontChar(font, char, effectList, effectParameterList) {
		DialogChar.call(this);

		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)
		this.effectParameterList = effectParameterList.slice();

		var charData = font.getChar(char);
		this.char = char;
		this.bitmap = charData.data;
		this.width = charData.width;
		this.height = charData.height;
		this.base_offset.x = charData.offset.x;
		this.base_offset.y = charData.offset.y;
		this.spacing = charData.spacing;
		this.blip = null;
		this.hasPlayedBlip = false;
	}

	function DialogDrawingChar(drawingId, effectList, effectParameterList) {
		DialogChar.call(this);

		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)
		this.effectParameterList = effectParameterList.slice();

		// get the first frame of the drawing and flatten it
		var drawingData = renderer.GetDrawingSource(drawingId)[0];
		var drawingDataFlat = [];
		for (var i = 0; i < drawingData.length; i++) {
			drawingDataFlat = drawingDataFlat.concat(drawingData[i]);
		}

		this.bitmap = drawingDataFlat;
		this.width = 8;
		this.height = 8;
		this.spacing = 8;
	}

	function DialogScriptControlChar() {
		DialogChar.call(this);

		this.width = 0;
		this.height = 0;
		this.spacing = 0;
	}

	// is a control character really the best way to handle page breaks?
	function DialogPageBreakChar() {
		DialogChar.call(this);

		this.width = 0;
		this.height = 0;
		this.spacing = 0;

		this.isPageBreak = true;

		var continueHandler = null;

		this.SetContinueHandler = function(handler) {
			continueHandler = handler;
		};

		this.OnContinue = function() {
			if (continueHandler) {
				continueHandler();
			}
		};
	}

	function AddWordToCharArray(charArray, word, effectList, effectParameterList) {
		// bitsy.log("add char array");
		for (var i = 0; i < word.length; i++) {
			charArray.push(new DialogFontChar(font, word[i], effectList, effectParameterList));
		}
		// bitsy.log("add char array end");
		return charArray;
	}

	function GetCharArrayWidth(charArray) {
		var width = 0;
		for(var i = 0; i < charArray.length; i++) {
			width += charArray[i].spacing;
		}
		return width;
	}

	function GetStringWidth(str) {
		var width = 0;
		for (var i = 0; i < str.length; i++) {
			var charData = font.getChar(str[i]);
			width += charData.spacing;
		}
		return width;
	}

	var pixelsPerRow = 192; // hard-coded fun times!!!

	this.AddScriptReturn = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var controlChar = new DialogScriptControlChar();
		controlChar.SetPrintHandler(onReturnHandler);

		curRowArr.push(controlChar);

		isActive = true;
	}

	this.AddDrawing = function(drawingId) {
		// bitsy.log("DRAWING ID " + drawingId);

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects, activeTextEffectParameters);

		var rowLength = GetCharArrayWidth(curRowArr);

		// TODO : clean up copy-pasted code here :/
		if (afterManualPagebreak) {
			this.FlipPage(); // hacky

			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);

			afterManualPagebreak = false;
		}
		else if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0) {
			//stay on same row
			curRowArr.push(drawingChar);
		}
		else if (curRowIndex == 0) {
			//start next row
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer[curPageIndex].push([]);
			curRowIndex++;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}
		else {
			//start next page
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}

		isActive = true; // this feels like a bad way to do this???
	}

	// TODO : convert this into something that takes DialogChar arrays
	this.AddText = function(textStr) {
		bitsy.log("ADD TEXT >>" + textStr + "<<");

		//process dialog so it's easier to display
		var words = textStr.split(" ");

		// var curPageIndex = this.CurPageCount() - 1;
		// var curRowIndex = this.CurRowCount() - 1;
		// var curRowArr = this.CurRow();

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			if (arabicHandler.ContainsArabicCharacters(word)) {
				word = arabicHandler.ShapeArabicCharacters(word);
			}

			var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
			var wordLength = GetStringWidth(wordWithPrecedingSpace);

			var rowLength = GetCharArrayWidth(curRowArr);

			if (afterManualPagebreak) {
				this.FlipPage();

				// hacky copied bit for page breaks
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);

				afterManualPagebreak = false;
			}
			else if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {
				//stay on same row
				curRowArr = AddWordToCharArray(curRowArr, wordWithPrecedingSpace, activeTextEffects, activeTextEffectParameters);
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer[curPageIndex].push([]);
				curRowIndex++;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);
			}
			else {
				//start next page
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);
			}
		}

		//destroy any empty stuff
		var lastPage = buffer[buffer.length-1];
		var lastRow = lastPage[lastPage.length-1];
		if (lastRow.length == 0) {
			lastPage.splice(lastPage.length-1, 1);
		}
		if (lastPage.length == 0) {
			buffer.splice(buffer.length-1, 1);
		}

		//finish up 
		lastPage = buffer[buffer.length-1];
		lastRow = lastPage[lastPage.length-1];
		if (lastRow.length > 0) {
			var lastChar = lastRow[lastRow.length-1];
		}

		// bitsy.log(buffer);

		bitsy.log("add text finished");

		isActive = true;
	};

	this.AddLinebreak = function() {
		var lastPage = buffer[buffer.length-1];
		if (lastPage.length <= 1) {
			// bitsy.log("LINEBREAK - NEW ROW ");
			// add new row
			lastPage.push([]);
		}
		else {
			// add new page
			buffer.push([[]]);
		}
		// bitsy.log(buffer);

		isActive = true;
	}

	this.AddPagebreak = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		// need to actually create a whole new page if following another pagebreak character
		if (afterManualPagebreak) {
			this.FlipPage(); // hacky

			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];

			afterManualPagebreak = false;
		}

		var pagebreakChar = new DialogPageBreakChar();
		pagebreakChar.SetContinueHandler(onReturnHandler);

		curRowArr.push(pagebreakChar);

		isActive = true;
	}

	this.hasTextEffect = function(name) {
		return activeTextEffects.indexOf(name) != -1;
	};

	this.pushTextEffect = function(name, parameters) {
		activeTextEffects.push(name);
		activeTextEffectParameters.push(parameters);
	};

	this.popTextEffect = function(name) {
		var i = activeTextEffects.lastIndexOf(name);
		activeTextEffects.splice(i, 1);
		activeTextEffectParameters.splice(i, 1);
	};

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };

	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky
};

/* ARABIC */
var ArabicHandler = function() {

	var arabicCharStart = 0x0621;
	var arabicCharEnd = 0x064E;

	var CharacterForm = {
		Isolated : 0,
		Final : 1,
		Initial : 2,
		Middle : 3
	};

	// map glyphs to their character forms
	var glyphForms = {
		/*		 Isolated, Final, Initial, Middle Forms	*/
		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ 
		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ 
		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ 
		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ 
		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ 
		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ 
		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ 
		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ 
		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ 
		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ 
		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ 
		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ 
		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ 
		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ 
		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ 
		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ 
		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ 
		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ 
		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ 
		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ 
		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ 
		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ 
		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ 
		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ 
		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ 
		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ 
		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ 
		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ 
		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ 
		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ 
		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ 
		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ 
		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ 
		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ 
		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ 
		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ 
		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ 
		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/
		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/
		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/
		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */
	};

	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];

	function IsArabicCharacter(char) {
		var code = char.charCodeAt(0);
		return (code >= arabicCharStart && code <= arabicCharEnd);
	}

	function ContainsArabicCharacters(word) {
		for (var i = 0; i < word.length; i++) {
			if (IsArabicCharacter(word[i])) {
				return true;
			}
		}
		return false;
	}

	function IsDisconnectedCharacter(char) {
		var code = char.charCodeAt(0);
		return disconnectedCharacters.indexOf(code) != -1;
	}

	function ShapeArabicCharacters(word) {
		var shapedWord = "";

		for (var i = 0; i < word.length; i++) {
			if (!IsArabicCharacter(word[i])) {
				shapedWord += word[i];
				continue;
			}

			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);

			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);

			var form;
			if (!connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Isolated;
			}
			else if (connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Final;
			}
			else if (!connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Initial;
			}
			else if (connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Middle;
			}

			var code = word[i].charCodeAt(0);

			// handle lam alef special case
			if (code == 0x0644 && connectedToNextChar) {
				var nextCode = word[i+1].charCodeAt(0);
				var specialCode = null;
				if (nextCode == 0x0622) {
					// alef madd
					specialCode = glyphForms[0x064b][form];
				}
				else if (nextCode == 0x0623) {
					// hamza above
					specialCode = glyphForms[0x064c][form];
				}
				else if (nextCode == 0x0625) {
					// hamza below
					specialCode = glyphForms[0x064d][form];
				}
				else if (nextCode == 0x0627) {
					// alef
					specialCode = glyphForms[0x064e][form];
				}

				if (specialCode != null) {
					shapedWord += String.fromCharCode(specialCode);
					i++; // skip a step
					continue;
				}
			}

			// hacky?
			if (form === CharacterForm.Isolated) {
				shapedWord += word[i];
				continue;
			}

			var shapedCode = glyphForms[code][form];
			shapedWord += String.fromCharCode(shapedCode);
		}

		return shapedWord;
	}

	this.ContainsArabicCharacters = ContainsArabicCharacters;
	this.ShapeArabicCharacters = ShapeArabicCharacters;
}

/* TEXT EFFECTS */
var TextEffects = {};

function RainbowEffect() {
	function positiveModulo(number, divisor) {
		return ((number % divisor) + divisor) % divisor;
	}

	this.doEffect = function(char, time, parameters) {
		char.color = rainbowColorStartIndex + Math.floor(positiveModulo((time / 100) - char.col * 0.5, rainbowColorCount));
	};
}

TextEffects["rbw"] = new RainbowEffect();

function ColorEffect(index) {
	this.doEffect = function(char, time, parameters) {
		if (parameters && parameters.length > 0) {
			char.color = tileColorStartIndex + parameters[0];
		}
		else {
			char.color = tileColorStartIndex + index;
		}
	};
}

TextEffects["clr"] = new ColorEffect();
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1);
TextEffects["clr3"] = new ColorEffect(2);

function WavyEffect() {
	this.doEffect = function(char, time, parameters) {
		char.offset.y += Math.sin((time / 250) - (char.col / 2)) * 2;
	};
}

TextEffects["wvy"] = new WavyEffect();

function ShakyEffect() {
	function disturb(func, time, offset, mult1, mult2) {
		return func((time * mult1) - (offset * mult2));
	}

	this.doEffect = function(char, time, parameters) {
		char.offset.y += 1.5
						* disturb(Math.sin, time, char.col, 0.1, 0.5)
						* disturb(Math.cos, time, char.col, 0.3, 0.2)
						* disturb(Math.sin, time, char.row, 2.0, 1.0);
		char.offset.x += 1.5
						* disturb(Math.cos, time, char.row, 0.1, 1.0)
						* disturb(Math.sin, time, char.col, 3.0, 0.7)
						* disturb(Math.cos, time, char.col, 0.2, 0.3);
	};
}

TextEffects["shk"] = new ShakyEffect();

/*
// TODO : maybe use this in a future update?
function YakEffect() {
	this.doEffect = function(char, time, parameters) {
		if (char.char != " ") {
			char.blip = parameters[0];
		}
	};
}

TextEffects["yak"] = new YakEffect();
*/

var DebugHighlightEffect = function() {
	this.doEffect = function(char, time, parameters) {
		char.color = tileColorStartIndex;
	};
}

TextEffects["_debug_highlight"] = new DebugHighlightEffect();

} // Dialog()
</script>

<script>
function TileRenderer(debugName) {
bitsy.log("!!!!! NEW TILE RENDERER: " + debugName);

var drawingCache = {
	source: {},
	render: {},
};

// var debugRenderCount = 0;

function createRenderCacheId(drawingId, colorIndex) {
	return drawingId + "_" + colorIndex;
}

function renderDrawing(drawing) {
	// debugRenderCount++;
	// bitsy.log("RENDER COUNT " + debugRenderCount);

	var col = drawing.col;
	var bgc = drawing.bgc;
	var drwId = drawing.drw;
	var drawingFrames = drawingCache.source[drwId];

	// initialize render cache entry
	var cacheId = createRenderCacheId(drwId, col);
	if (drawingCache.render[cacheId] === undefined) {
		// initialize array of frames for drawing
		drawingCache.render[cacheId] = [];
	}

	for (var i = 0; i < drawingFrames.length; i++) {
		var frameData = drawingFrames[i];
		var frameTileId = renderTileFromDrawingData(frameData, col, bgc);
		drawingCache.render[cacheId].push(frameTileId);
	}
}

function renderTileFromDrawingData(drawingData, col, bgc) {
	var tileId = bitsy.tile();

	var backgroundColor = tileColorStartIndex + bgc;
	var foregroundColor = tileColorStartIndex + col;

	bitsy.fill(tileId, backgroundColor);

	for (var y = 0; y < bitsy.TILE_SIZE; y++) {
		for (var x = 0; x < bitsy.TILE_SIZE; x++) {
			var px = drawingData[y][x];
			if (px === 1) {
				bitsy.set(tileId, (y * bitsy.TILE_SIZE) + x, foregroundColor);
			}
		}
	}

	return tileId;
}

// TODO : move into core
function undefinedOrNull(x) {
	return x === undefined || x === null;
}

function isDrawingRendered(drawing) {
	var cacheId = createRenderCacheId(drawing.drw, drawing.col);
	return drawingCache.render[cacheId] != undefined;
}

function getRenderedDrawingFrames(drawing) {
	var cacheId = createRenderCacheId(drawing.drw, drawing.col);
	return drawingCache.render[cacheId];
}

function getDrawingFrameTileId(drawing, frameOverride) {
	var frameIndex = 0;

	if (drawing != null && drawing.animation.isAnimated) {
		if (frameOverride != undefined && frameOverride != null) {
			frameIndex = frameOverride;
		}
		else {
			frameIndex = drawing.animation.frameIndex;
		}
	}

	return getRenderedDrawingFrames(drawing)[frameIndex];
}

function getOrRenderDrawingFrame(drawing, frameOverride) {
	// bitsy.log("frame render: " + drawing.type + " " + drawing.id + " f:" + frameOverride);

	if (!isDrawingRendered(drawing)) {
		bitsy.log("frame render: doesn't exist " + drawing.id);
		renderDrawing(drawing);
	}

	return getDrawingFrameTileId(drawing, frameOverride);
}

function deleteRenders(drawingId) {
	for (var cacheId in drawingCache.render) {
		if (cacheId.indexOf(drawingId) === 0) {
			var tiles = drawingCache.render[cacheId];
			for (var i = 0; i < tiles.length; i++) {
				bitsy.delete(tiles[i]);
			}
			delete drawingCache.render[cacheId];
		}
	}
}

/* PUBLIC INTERFACE */
this.GetDrawingFrame = getOrRenderDrawingFrame;

// todo : leave individual get and set stuff for now - should I remove later?
// todo : better name for function?
this.SetDrawings = function(drawingSource) {
	drawingCache.source = drawingSource;
	// need to reset entire render cache when all the drawings are changed
	drawingCache.render = {};
};

this.SetDrawingSource = function(drawingId, drawingData) {
	deleteRenders(drawingId);
	drawingCache.source[drawingId] = drawingData;
};

this.GetDrawingSource = function(drawingId) {
	return drawingCache.source[drawingId];
};

this.GetFrameCount = function(drawingId) {
	return drawingCache.source[drawingId].length;
};

// todo : forceReset option is hacky?
this.ClearCache = function(forceReset) {
	if (forceReset === undefined || forceReset === true) {
		// delete all tiles from system memory before clearing the cache
		for (var cacheId in drawingCache.render) {
			var tiles = drawingCache.render[cacheId];
			for (var i = 0; i < tiles.length; i++) {
				bitsy.delete(tiles[i]);
			}
		}
	}

	drawingCache.render = {};
};

this.deleteDrawing = deleteRenders;

} // Renderer()
</script>

<script>
/* WORLD DATA */
var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var end = {}; // for backwards compatibility
var palette = { // start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var tune = {};
var blip = {};
var playerId = "A";
var fontName = defaultFontName;
var textDirection = TextDirection.LeftToRight;

/* NAME-TO-ID MAPS */
var names = {
	room : {},
	tile : {},
	sprite : {},
	item : {},
	dialog : {},
	palette : {},
	tune : {},
	blip : {},
};

// todo : this is basically a copy of the one in world.js - can I remove it?
function updateNamesFromCurData() {

	function createNameMap(objectStore) {
		var map = {};

		for (id in objectStore) {
			if (objectStore[id].name != undefined && objectStore[id].name != null) {
				map[objectStore[id].name] = id;
			}
		}

		return map;
	}

	names.room = createNameMap(room);
	names.tile = createNameMap(tile);
	names.sprite = createNameMap(sprite);
	names.item = createNameMap(item);
	names.dialog = createNameMap(dialog);
	names.palette = createNameMap(palette);
	names.tune = createNameMap(tune);
	names.blip = createNameMap(blip);
}

/* GAME STATE */
var state = {}
function resetGameState() {
	state.room = "0";
	state.ava = playerId; // avatar appearance override
	state.pal = "0"; // current palette id
	state.tune = "0"; // current tune id ("0" === off)
	state.exits = []; // exits in current room
	state.endings = []; // endings in current room
}

// title helper functions
function getTitle() {
	return dialog[titleDialogId].src;
}
function setTitle(titleSrc) {
	dialog[titleDialogId] = { src:titleSrc, name:null };
}

/* FLAGS */
var flags = createDefaultFlags();

// feature flags for testing purposes
var engineFeatureFlags = {
	isSoundEnabled : true,
	isFontEnabled : true,
	isTransitionEnabled : true,
	isScriptEnabled : true,
	isDialogEnabled : true,
	isRendererEnabled : true,
};

function clearGameData() {
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
	isEnding = false; //todo - correct place for this?
	variable = {};

	updateNamesFromCurData();

	fontName = defaultFontName; // TODO : reset font manager too?
	textDirection = TextDirection.LeftToRight;

	resetGameState();

	isGameLoaded = false;
	isGameOver = false;
}

// engine event hooks for the editor
var onInventoryChanged = null;
var onVariableChanged = null;
var onGameReset = null;
var onInitRoom = null;

var isPlayerEmbeddedInEditor = false;

var renderer;
if (engineFeatureFlags.isRendererEnabled) {
	renderer = new TileRenderer("bitsy");
}

var curGameData = null;
var curDefaultFontData = null;

var isGameLoaded = false;
var isGameOver = false;

function load_game(gameData, defaultFontData, startWithTitle) {
	// bitsy.log("game data in: \n" + gameData);

	curGameData = gameData; //remember the current game (used to reset the game)

	if (dialogBuffer) {
		dialogBuffer.Reset();
	}

	if (scriptInterpreter) {
		scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?
	}

	loadWorldFromGameData(gameData);

	bitsy.log("world loaded");

	if (fontManager && !isPlayerEmbeddedInEditor && defaultFontData) {
		bitsy.log("load font");

		curDefaultFontData = defaultFontData; // store for resetting game

		// todo : consider replacing this with a more general system for requesting resources from the system?
		// hack to ensure default font is available
		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), defaultFontData);

		bitsy.log("load font end");
	}

	// request text mode
	if (flags.TXT_MODE === 1) {
		bitsy.textMode(bitsy.TXT_LOREZ);
	}
	else {
		// default to 2x scale for text rendering
		bitsy.textMode(bitsy.TXT_HIREZ);
	}

	if (fontManager && dialogBuffer) {
		bitsy.log("get font");

		var font = fontManager.Get( fontName );
		dialogBuffer.SetFont(font);
		dialogRenderer.SetFont(font);

		bitsy.log("get font end");
	}

	if (dialogBuffer) {
		// this feels a little silly to me - oh well??
		dialogBuffer.SetPixelsPerRow(dialogRenderer.GetPixelsPerRow());
	}

	setInitialVariables();

	bitsy.log("ready");

	onready(startWithTitle);

	isGameLoaded = true;
}

function loadWorldFromGameData(gameData) {
	bitsy.log("load world from game data");

	var world = parseWorld(gameData);

	bitsy.log("parse world done");

	// move world data into global scope
	palette = world.palette;
	room = world.room;
	tile = world.tile;
	sprite = world.sprite;
	item = world.item;
	dialog = world.dialog;
	end = world.end; // back compat endings
	variable = world.variable;
	fontName = world.fontName;
	textDirection = world.textDirection;
	tune = world.tune;
	blip = world.blip;
	flags = world.flags;
	names = world.names;

	if (renderer) {
		renderer.SetDrawings(world.drawings);
	}

	// find starting room and initialize it
	var roomIds = Object.keys(room);

	if (player() != undefined && player().room != null && roomIds.indexOf(player().room) != -1) {
		// player has valid room
		state.room = player().room;
	}
	else if (roomIds.length > 0) {
		// player not in any room! what the heck
		state.room = roomIds[0];
	}
	else {
		// uh oh there are no rooms I guess???
		state.room = null;
	}

	if (state.room != null) {
		bitsy.log("INIT ROOM " + state.room);
		initRoom(state.room);
	}
}

function reset_cur_game() {
	if (curGameData == null) {
		return; //can't reset if we don't have the game data
	}

	stopGame();
	clearGameData();

	if (isPlayerEmbeddedInEditor && onGameReset != null) {
		onGameReset();
	}
}

function onready(startWithTitle) {
	bitsy.log("game ready!");

	if (startWithTitle === undefined || startWithTitle === null) {
		startWithTitle = true;
	}

	if (startWithTitle) { // used by editor 
		startNarrating(getTitle());
	}
}

function setInitialVariables() {
	if (!scriptInterpreter) {
		return;
	}

	for(id in variable) {
		var value = variable[id]; // default to string
		if(value === "true") {
			value = true;
		}
		else if(value === "false") {
			value = false;
		}
		else if(!isNaN(parseFloat(value))) {
			value = parseFloat(value);
		}
		scriptInterpreter.SetVariable(id,value);
	}
	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	if (soundPlayer) {
		soundPlayer.stopTune();
	}
	bitsy.log("stop GAME!");
}

function update(dt) {
	if (!isGameLoaded) {
		load_game(bitsy.getGameData(), bitsy.getFontData());
	}

	if (state.room == null) {
		// in the special case where there is no valid room, end the game
		startNarrating( "", true /*isEnding*/ );
	}

	if (!transition || !transition.IsTransitionActive()) {
		updateInput();
	}

	if (transition && transition.IsTransitionActive()) {
		// transition animation takes over everything!
		transition.UpdateTransition(dt);
	}
	else {
		if (bitsy.graphicsMode() != bitsy.GFX_MAP) {
			bitsy.graphicsMode(bitsy.GFX_MAP);
		}

		if (soundPlayer) {
			soundPlayer.update(dt);
		}

		if (!isNarrating && !isEnding) {
			// draw world if game has begun
			var didAnimate = updateAnimation(dt);

			// test whether player moved so we can redraw just the avatar
			playerCurX = player().x;
			playerCurY = player().y;
			var didPlayerMove = (playerPrevX != playerCurX) || (playerPrevY != playerCurY);

			drawRoom(room[state.room], { redrawAnimated: didAnimate, redrawAvatar: didPlayerMove });

			// store player's position for next frame
			playerPrevX = playerCurX;
			playerPrevY = playerCurY;
		}
		else {
			clearRoom();
		}

		if (dialogBuffer && dialogBuffer.IsActive() && !(soundPlayer && soundPlayer.isBlipPlaying())) {
			// bitsy.log("update dialog");
			// bitsy.log("renderer");
			dialogRenderer.Draw(dialogBuffer, dt);
			// bitsy.log("buffer");
			dialogBuffer.Update(dt);
			// bitsy.log("update dialog end");
		}

		// keep moving avatar if player holds down button
		if ((!dialogBuffer || !dialogBuffer.IsActive()) && !isEnding) {
			if (curPlayerDirection != Direction.None) {
				playerHoldToMoveTimer -= dt;

				if (playerHoldToMoveTimer <= 0) {
					movePlayer(curPlayerDirection, false /* isFirstMove */);
					playerHoldToMoveTimer = 150;
					// playerHoldToMoveTimer = 16; // PERF TEST
				}
			}
		}
	}

	// clean up state if the game is ending
	if (isGameOver) {
		bitsy.log("game over");
		reset_cur_game();
	}

	return true;
}

var isAnyButtonHeld = false;
var isMenuButtonHeld = false;
var isIgnoringInput = false;

function isAnyButtonDown() {
	return bitsy.button(bitsy.BTN_UP) ||
		bitsy.button(bitsy.BTN_DOWN) ||
		bitsy.button(bitsy.BTN_LEFT) ||
		bitsy.button(bitsy.BTN_RIGHT) ||
		bitsy.button(bitsy.BTN_OK);
}

function updateInput() {
	if (dialogBuffer && dialogBuffer.IsActive()) {
		if (!(soundPlayer && soundPlayer.isBlipPlaying())) {
			if (!isAnyButtonHeld && isAnyButtonDown()) {
				/* CONTINUE DIALOG */
				if (dialogBuffer.CanContinue()) {
					var hasMoreDialog = dialogBuffer.Continue();
					if (!hasMoreDialog) {
						// ignore currently held keys UNTIL they are released (stops player from insta-moving)
						isIgnoringInput = true;
						curPlayerDirection = Direction.None;
					}
				}
				else {
					dialogBuffer.Skip();
				}
			}
		}
	}
	else if (isEnding) {
		if (!isAnyButtonHeld && isAnyButtonDown()) {
			// tell game to restart
			isGameOver = true;
		}
	}
	else if (!isIgnoringInput) {
		/* WALK */
		var prevPlayerDirection = curPlayerDirection;

		if (bitsy.button(bitsy.BTN_UP)) {
			curPlayerDirection = Direction.Up;
		}
		else if (bitsy.button(bitsy.BTN_DOWN)) {
			curPlayerDirection = Direction.Down;
		}
		else if (bitsy.button(bitsy.BTN_LEFT)) {
			curPlayerDirection = Direction.Left;
		}
		else if (bitsy.button(bitsy.BTN_RIGHT)) {
			curPlayerDirection = Direction.Right;
		}
		else {
			curPlayerDirection = Direction.None;
		}

		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {
			movePlayer(curPlayerDirection, true /* isFirstMove */);
			playerHoldToMoveTimer = 500;
			// playerHoldToMoveTimer = 32; // PERF TEST
		}
	}

	if (!isAnyButtonDown()) {
		isIgnoringInput = false;
	}

	// quit when the user releases the restart button
	// todo : should I rename it bitsy.BTN_RESTART or bitsy.BTN_QUIT or bitsy.BTN_OFF?
	if (isMenuButtonHeld && !bitsy.button(bitsy.BTN_MENU)) {
		isGameOver = true;
	}

	isAnyButtonHeld = isAnyButtonDown();
	isMenuButtonHeld = bitsy.button(bitsy.BTN_MENU);
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation(dt) {
	animationCounter += dt;
	// bitsy.log("anim " + animationCounter);
	if (animationCounter >= animationTime) {
		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = (spr.animation.frameIndex + 1) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = (til.animation.frameIndex + 1) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = (itm.animation.frameIndex + 1) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

		// updated animations this frame
		return true;
	}

	// did *not* update animations this frame
	return false;
}

function resetAllAnimations() {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.animation.isAnimated) {
			spr.animation.frameIndex = 0;
		}
	}

	for (id in tile) {
		var til = tile[id];
		if (til.animation.isAnimated) {
			til.animation.frameIndex = 0;
		}
	}

	for (id in item) {
		var itm = item[id];
		if (itm.animation.isAnimated) {
			itm.animation.frameIndex = 0;
		}
	}
}

function getSpriteAt(x, y, roomId) {
	if (roomId === undefined) {
		roomId = state.room;
	}

	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === roomId) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}

	return null;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;
var playerPrevX = 0;
var playerPrevY = 0;

function movePlayer(direction, isFirstMove) {
	didPlayerMove = false;
	var roomIds = Object.keys(room);

	if (player().room == null || roomIds.indexOf(player().room) < 0) {
		return; // player room is missing or invalid.. can't move them!
	}

	var spr = null;

	if (direction == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
		player().x -= 1;
	}
	else if (direction == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
		player().x += 1;
	}
	else if (direction == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
		player().y -= 1;
	}
	else if (direction == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
		player().y += 1;
	}

	var ext = getExit( player().room, player().x, player().y );
	var end = getEnding( player().room, player().x, player().y );
	var itmIndex = getItemIndex( player().room, player().x, player().y );

	// only play one sound effect per "turn"
	var blipId = null;

	// do items first, because you can pick up an item AND go through a door
	if (itmIndex > -1) {
		var itm = room[player().room].items[itmIndex];
		var itemRoom = player().room;

		// play sound on pitck up item
		if (item[itm.id].blip != null) {
			blipId = item[itm.id].blip;
		}

		startItemDialog(itm.id, function() {
			// remove item from room
			room[itemRoom].items.splice(itmIndex, 1);

			// update player inventory
			if (player().inventory[itm.id]) {
				player().inventory[itm.id] += 1;
			}
			else {
				player().inventory[itm.id] = 1;
			}

			// show inventory change in UI
			if (onInventoryChanged != null) {
				onInventoryChanged(itm.id);
			}
		});
	}

	if (end) {
		startEndingDialog(end);
	}
	else if (ext) {
		movePlayerThroughExit(ext);
	}
	else if (spr) {
		// play sound on greet sprite
		if (sprite[spr].blip != null) {
			blipId = sprite[spr].blip;
		}

		startSpriteDialog(spr /*spriteId*/);
	}

	// TODO : maybe add in a future update?
	/*
	// play sound when player moves (if no other sound selected)
	if (isFirstMove && blipId === null && sprite[state.ava].blip != null) {
		blipId = sprite[state.ava].blip;
		randomizeBlip = true;
		blipChannel = bitsy.SOUND2; // play walking sfx *under* the tune melody
	}
	*/

	if (soundPlayer && blipId != null && blip[blipId]) {
		soundPlayer.playBlip(blip[blipId]);
	}
}

var transition;
if (engineFeatureFlags.isTransitionEnabled) {
	transition = new TransitionManager();
}

function movePlayerThroughExit(ext) {
	var GoToDest = function() {
		if (transition && ext.transition_effect != null) {
			transition.BeginTransition(
				player().room,
				player().x,
				player().y,
				ext.dest.room,
				ext.dest.x,
				ext.dest.y,
				ext.transition_effect);

			transition.UpdateTransition(0);

			transition.OnTransitionComplete(function() {
				player().room = ext.dest.room;
				player().x = ext.dest.x;
				player().y = ext.dest.y;
				state.room = ext.dest.room;
				initRoom(state.room);
			});
		}
		else {
			player().room = ext.dest.room;
			player().x = ext.dest.x;
			player().y = ext.dest.y;
			state.room = ext.dest.room;

			initRoom(state.room);
		}
	};

	if (ext.dlg != undefined && ext.dlg != null) {
		// TODO : I need to simplify dialog code,
		// so I don't have to get the ID and the source str
		// every time!
		startDialog(
			dialog[ext.dlg].src,
			ext.dlg,
			function(result) {
				var isLocked = ext.property && ext.property.locked === true;
				if (!isLocked) {
					GoToDest();
				}
			},
			ext);
	}
	else {
		GoToDest();
	}
}

/* PALETTE INDICES */
var backgroundIndex = 0;
var textBackgroundIndex = 1;
var textArrowIndex = 2;
var textColorIndex = 3;

// precalculated rainbow colors
var rainbowColorStartIndex = 4;
var rainbowColorCount = 10;
var rainbowColors = [
	[255,0,0],
	[255,217,0],
	[78,255,0],
	[0,255,125],
	[0,192,255],
	[0,18,255],
	[136,0,255],
	[255,0,242],
	[255,0,138],
	[255,0,61],
];

function updatePaletteWithTileColors(tileColors) {
	// the screen background color should match the first tile color
	if (tileColors.length > 0) {
		var color = tileColors[0];
		bitsy.color(backgroundIndex, color[0], color[1], color[2]);
	}
	else {
		// as a fallback, use black as the background
		bitsy.log("no tile colors!");
		bitsy.color(backgroundIndex, 0, 0, 0);
	}

	// textbox colors
	bitsy.color(textBackgroundIndex, 0, 0, 0); // black
	bitsy.color(textArrowIndex, 255, 255, 255); // white
	bitsy.color(textColorIndex, 255, 255, 255); // white

	// rainbow colors
	for (var i = 0; i < rainbowColorCount; i++) {
		var color = rainbowColors[i];
		bitsy.color(rainbowColorStartIndex + i, color[0], color[1], color[2]);
	}

	// tile colors
	for (var i = 0; i < tileColors.length; i++) {
		var color = tileColors[i];
		bitsy.color(tileColorStartIndex + i, color[0], color[1], color[2]);
	}
}

function updatePalette(palId) {
	state.pal = palId;
	var pal = palette[state.pal];
	updatePaletteWithTileColors(pal.colors);
}

function initRoom(roomId) {
	bitsy.log("init room " + roomId);

	updatePalette(getRoomPal(roomId));

	// update avatar appearance
	state.ava = (room[roomId].ava != null) ? room[roomId].ava : playerId;

	if (renderer) {
		renderer.ClearCache();
	}

	// init exit properties
	state.exits = [];
	for (var i = 0; i < room[roomId].exits.length; i++) {
		var exit = createExitData(
			/* x 			*/ room[roomId].exits[i].x,
			/* y 			*/ room[roomId].exits[i].y,
			/* destRoom 	*/ room[roomId].exits[i].dest.room,
			/* destX 		*/ room[roomId].exits[i].dest.x,
			/* destY 		*/ room[roomId].exits[i].dest.y,
			/* transition 	*/ room[roomId].exits[i].transition_effect,
			/* dlg 			*/ room[roomId].exits[i].dlg);
		exit.property = { locked: false };

		state.exits.push(exit);
	}

	// init ending properties
	state.endings = [];
	for (var i = 0; i < room[roomId].endings.length; i++) {
		var end = createEndingData(
			/* id */ room[roomId].endings[i].id,
			/* x  */ room[roomId].endings[i].x,
			/* y  */ room[roomId].endings[i].y);
		end.property = { locked: false };

		state.endings.push(end);
	}

	if (soundPlayer) {
		if (!room[roomId].tune || room[roomId].tune === "0" || !tune[room[roomId].tune]) {
			// stop music
			state.tune = "0";
			soundPlayer.stopTune();
		}
		else if (room[roomId].tune != state.tune) {
			// start music
			state.tune = room[roomId].tune;
			soundPlayer.playTune(tune[state.tune]);
		}
	}

	var drawArgs = { redrawAll: true };
	drawRoom(room[roomId], drawArgs);

	if (onInitRoom) {
		onInitRoom(roomId);
	}
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );
}

function isWallRight() {
	return (player().x + 1 >= bitsy.MAP_SIZE) || isWall(player().x + 1, player().y);
}

function isWallUp() {
	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );
}

function isWallDown() {
	return (player().y + 1 >= bitsy.MAP_SIZE) || isWall(player().x, player().y + 1);
}

function isWall(x, y, roomId) {
	if (roomId == undefined || roomId == null) {
		roomId = state.room;
	}

	var tileId = getTile(x, y, roomId);
	if (tileId === '0') {
		return false; // Blank spaces aren't walls, ya doofus
	}

	if (tile[tileId].isWall === undefined || tile[tileId].isWall === null) {
		// No wall-state defined: check room-specific walls
		var i = room[roomId].walls.indexOf(getTile(x, y, roomId));
		return (i > -1);
	}

	// Otherwise, use the tile's own wall-state
	return tile[tileId].isWall;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

// todo : roomId isn't useful in these functions anymore! safe to remove?
function getExit(roomId, x, y) {
	for (i in state.exits) {
		var e = state.exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId, x, y) {
	for (i in state.endings) {
		var e = state.endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getTile(x, y, roomId) {
	// bitsy.log(x + " " + y);
	var t = getRoom(roomId).tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	if (palette[id] === undefined) {
		id = "default";
	}

	return palette[ id ].colors;
}

function getRoom(id) {
	return room[id === undefined ? state.room : id];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function serializeNote(note, key, useFriendlyName) {
	var isSolfa = (key != undefined && key != null);
	var noteType = (isSolfa === true) ? Solfa : Note;

	if (isSolfa && key.scale.indexOf(note) === -1) {
		// no matching note in key
		return null;
	}

	if (isSolfa && useFriendlyName != true) {
		for (var name in Solfa) {
			if (Solfa[name] === note) {
				return name.toLowerCase();
			}
		}

		// no solfa note found
		return null;
	}

	// for a solfa note's "friendly name" convert to the chromatic equivalent
	if (isSolfa && useFriendlyName === true) {
		note = key.notes[note];
	}

	// from this point on, we know the note we're looking for is chromatic
	for (var name in Note) {
		if (Note[name] === note) {
			name = name.replace("_SHARP", "#");
			if (useFriendlyName === true && name === "H") {
				name = "C";
			}
			return name;
		}
	}

	// no note found
	return symbol;
}

function serializeOctave(octave) {
	for (var symbol in Octave) {
		if (Octave[symbol] === octave) {
			return symbol;
		}
	}

	// default to middle octave
	return "4";
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
	if (skipFonts === undefined || skipFonts === null) {
		skipFonts = false;
	}

	// update version flags
	flags.VER_MAJ = version.major;
	flags.VER_MIN = version.minor;

	var worldStr = "";
	/* TITLE */
	worldStr += getTitle() + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	if (version.devBuildPhase != "RELEASE") {
		worldStr += "# DEVELOPMENT BUILD -- " + version.devBuildPhase;
	}
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* FONT */
	if (fontName != defaultFontName) {
		worldStr += "DEFAULT_FONT " + fontName + "\n";
		worldStr += "\n"
	}
	if (textDirection != TextDirection.LeftToRight) {
		worldStr += "TEXT_DIRECTION " + textDirection + "\n";
		worldStr += "\n"
	}
	/* PALETTE */
	for (id in palette) {
		if (id != "default") {
			worldStr += "PAL " + id + "\n";
			for (i in getPal(id)) {
				for (j in getPal(id)[i]) {
					worldStr += getPal(id)[i][j];
					if (j < 2) worldStr += ",";
				}
				worldStr += "\n";
			}
			if (palette[id].name != null) {
				worldStr += "NAME " + palette[id].name + "\n";
			}
			worldStr += "\n";
		}
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];	
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					if (e.transition_effect != undefined && e.transition_effect != null) {
						worldStr += " FX " + e.transition_effect;
					}
					if (e.dlg != undefined && e.dlg != null) {
						worldStr += " DLG " + e.dlg;
					}
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		if (room[id].pal != null && room[id].pal != "default") {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		if (room[id].ava != null) {
			/* AVATAR SPRITE */
			worldStr += "AVA " + room[id].ava + "\n";
		}
		if (room[id].tune != null && room[id].tune != "0") {
			/* TUNE */
			worldStr += "TUNE " + room[id].tune + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		if (tile[id].name != null && tile[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + tile[id].name + "\n";
		}
		if (tile[id].isWall != null && tile[id].isWall != undefined) {
			/* WALL */
			worldStr += "WAL " + tile[id].isWall + "\n";
		}
		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + tile[id].col + "\n";
		}
		if (tile[id].bgc != null && tile[id].bgc != undefined && tile[id].bgc != 0) {
			/* BACKGROUND COLOR OVERRIDE */
			if (tile[id].bgc < 0) {
				// transparent background
				worldStr += "BGC *\n";
			}
			else {
				worldStr += "BGC " + tile[id].bgc + "\n";
			}
		}
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null && sprite[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		if (sprite[id].inventory != null) {
			for(itemId in sprite[id].inventory) {
				worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
			}
		}
		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + sprite[id].col + "\n";
		}
		if (sprite[id].bgc != null && sprite[id].bgc != undefined && sprite[id].bgc != 0) {
			/* BACKGROUND COLOR OVERRIDE */
			if (sprite[id].bgc < 0) {
				// transparent background
				worldStr += "BGC *\n";
			}
			else {
				worldStr += "BGC " + sprite[id].bgc + "\n";
			}
		}
		if (sprite[id].blip != null && sprite[id].blip != undefined) {
			/* BLIP */
			worldStr += "BLIP " + sprite[id].blip + "\n";
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null && item[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + item[id].col + "\n";
		}
		if (item[id].bgc != null && item[id].bgc != undefined && item[id].bgc != 0) {
			/* BACKGROUND COLOR OVERRIDE */
			if (item[id].bgc < 0) {
				// transparent background
				worldStr += "BGC *\n";
			}
			else {
				worldStr += "BGC " + item[id].bgc + "\n";
			}
		}
		if (item[id].blip != null && item[id].blip != undefined) {
			/* BLIP */
			worldStr += "BLIP " + item[id].blip + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		if (id != titleDialogId) {
			worldStr += "DLG " + id + "\n";
			worldStr += dialog[id].src + "\n";
			if (dialog[id].name != null) {
				worldStr += "NAME " + dialog[id].name + "\n";
			}
			worldStr += "\n";
		}
	}
	/* ENDINGS (for backwards compability only) */
	for (id in end) {
		worldStr += "END " + id + "\n";
		worldStr += end[id].src + "\n";
		worldStr += "\n";
	}
	/* VARIABLES */
	for (id in variable) {
		worldStr += "VAR " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}
	/* TUNES */
	for (id in tune) {
		if (id === "0") {
			continue;
		}

		worldStr += "TUNE " + id + "\n";
		for (var i = 0; i < maxTuneLength && i < tune[id].melody.length; i++) {
			// MELODY
			for (var j = 0; j < barLength; j++) {
				var noteStr = serializeNote(tune[id].melody[i][j].note, tune[id].key);
				if (noteStr === null) {
					tune[id].melody[i][j].beats = 0;
				}
				if (tune[id].melody[i][j].beats != 1) {
					worldStr += tune[id].melody[i][j].beats;
				}
				if (tune[id].melody[i][j].beats > 0) {
					worldStr += noteStr;
				}
				if (tune[id].melody[i][j].beats > 0 && tune[id].melody[i][j].octave != Octave[4]) {
					worldStr += serializeOctave(tune[id].melody[i][j].octave);
				}
				if (tune[id].melody[i][j].beats > 0 && tune[id].melody[i][j].blip != undefined) {
					// todo : create constant for the blip separator?
					worldStr += "~" + tune[id].melody[i][j].blip;
				}
				if (j < 15) {
					worldStr += ",";
				}
			}
			worldStr += "\n";

			// HARMONY
			// todo : lots of copy-pasting - I could probably make some helper functions to simplify this
			for (var j = 0; j < barLength; j++) {
				var noteStr = serializeNote(tune[id].harmony[i][j].note, tune[id].key);
				if (noteStr === null) {
					tune[id].harmony[i][j].beats = 0;
				}
				if (tune[id].harmony[i][j].beats != 1) {
					worldStr += tune[id].harmony[i][j].beats;
				}
				if (tune[id].harmony[i][j].beats > 0) {
					worldStr += noteStr;
				}
				if (tune[id].harmony[i][j].beats > 0 && tune[id].harmony[i][j].octave != Octave[4]) {
					worldStr += serializeOctave(tune[id].harmony[i][j].octave);
				}
				if (tune[id].harmony[i][j].beats > 0 && tune[id].harmony[i][j].blip != undefined) {
					worldStr += "~" + tune[id].harmony[i][j].blip;
				}
				if (j < 15) {
					worldStr += ",";
				}
			}
			worldStr += "\n";

			if (i < (tune[id].melody.length - 1)) {
				worldStr += ">";
				worldStr += "\n";
			}
		}
		if (tune[id].name != null) {
			/* NAME */
			worldStr += "NAME " + tune[id].name + "\n";
		}
		if (tune[id].key != undefined && tune[id].key != null) {
			worldStr += "KEY ";
			for (var i = 0; i < Solfa.COUNT; i++) {
				worldStr += serializeNote(tune[id].key.notes[i]);
				if (i < Solfa.COUNT - 1) {
					worldStr += ",";
				}
			}
			worldStr += " ";
			for (var i = 0; i < tune[id].key.scale.length; i++) {
				worldStr += serializeNote(tune[id].key.scale[i], tune[id].key);
				if (i < tune[id].key.scale.length - 1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		worldStr += "TMP ";
		switch (tune[id].tempo) {
			case Tempo.SLW:
				worldStr += "SLW";
				break;
			case Tempo.MED:
				worldStr += "MED";
				break;
			case Tempo.FST:
				worldStr += "FST";
				break;
			case Tempo.XFST:
				worldStr += "XFST";
				break;
		}
		worldStr += "\n";
		worldStr += "SQR ";
		switch (tune[id].instrumentA) {
			case SquareWave.P8:
				worldStr += "P8";
				break;
			case SquareWave.P4:
				worldStr += "P4";
				break;
			case SquareWave.P2:
				worldStr += "P2";
				break;
		}
		worldStr += " ";
		switch (tune[id].instrumentB) {
			case SquareWave.P8:
				worldStr += "P8";
				break;
			case SquareWave.P4:
				worldStr += "P4";
				break;
			case SquareWave.P2:
				worldStr += "P2";
				break;
		}
		worldStr += "\n";
		if (tune[id].key != undefined && tune[id].key != null && tune[id].arpeggioPattern != ArpeggioPattern.OFF) {
			switch (tune[id].arpeggioPattern) {
				case ArpeggioPattern.UP:
					worldStr += "ARP UP\n";
					break;
				case ArpeggioPattern.DWN:
					worldStr += "ARP DWN\n";
					break;
				case ArpeggioPattern.INT5:
					worldStr += "ARP INT5\n";
					break;
				case ArpeggioPattern.INT8:
					worldStr += "ARP INT8\n";
					break;
			}
		}
		worldStr += "\n";
	}
	/* BLIP */
	for (id in blip) {
		if (id === "0") {
			continue;
		}

		worldStr += "BLIP " + id + "\n";
		// pitches
		if (blip[id].pitchA.beats > 0) {
			worldStr += serializeNote(blip[id].pitchA.note);
			if (blip[id].pitchA.octave != Octave[4]) {
				worldStr += serializeOctave(blip[id].pitchA.octave);
			}
		}
		else {
			worldStr += blip[id].pitchA.beats;
		}
		worldStr += ",";
		if (blip[id].pitchB.beats > 0) {
			worldStr += serializeNote(blip[id].pitchB.note);
			if (blip[id].pitchB.octave != Octave[4]) {
				worldStr += serializeOctave(blip[id].pitchB.octave);
			}
		}
		else {
			worldStr += blip[id].pitchB.beats;
		}
		worldStr += ",";
		if (blip[id].pitchC.beats > 0) {
			worldStr += serializeNote(blip[id].pitchC.note);
			if (blip[id].pitchC.octave != Octave[4]) {
				worldStr += serializeOctave(blip[id].pitchC.octave);
			}
		}
		else {
			worldStr += blip[id].pitchC.beats;
		}
		worldStr += "\n";
		if (blip[id].name != null) {
			/* NAME */
			worldStr += "NAME " + blip[id].name + "\n";
		}
		// envelope
		worldStr += "ENV " + blip[id].envelope.attack
			+ " " + blip[id].envelope.decay
			+ " " + blip[id].envelope.sustain
			+ " " + blip[id].envelope.length
			+ " " + blip[id].envelope.release + "\n";
		// beat
		worldStr += "BEAT " + blip[id].beat.time
			+ " " + blip[id].beat.delay + "\n";
		// instrument (square wave type)
		worldStr += "SQR ";
		switch (blip[id].instrument) {
			case SquareWave.P8:
				worldStr += "P8";
				break;
			case SquareWave.P4:
				worldStr += "P4";
				break;
			case SquareWave.P2:
				worldStr += "P2";
				break;
		}
		worldStr += "\n";
		// other parameters
		if (blip[id].doRepeat === true) {
			worldStr += "RPT 1\n";
		}
		// TODO : consider for future update
		// if (blip[id].doSlide === true) {
		// 	worldStr += "SLD 1\n";
		// }
		worldStr += "\n";
	}
	/* FONT */
	// TODO : support multiple fonts
	if (fontManager && fontName != defaultFontName && !skipFonts) {
		worldStr += fontManager.GetData(fontName);
	}

	return worldStr;
}

function serializeDrawing(drwId) {
	if (!renderer) {
		return "";
	}

	var drawingData = renderer.GetDrawingSource(drwId);
	var drwStr = "";
	for (f in drawingData) {
		for (y in drawingData[f]) {
			var rowStr = "";
			for (x in drawingData[f][y]) {
				rowStr += drawingData[f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (drawingData.length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < bitsy.MAP_SIZE && e.y >= 0 && e.y < bitsy.MAP_SIZE;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < bitsy.MAP_SIZE && e.dest.y >= 0 && e.dest.y < bitsy.MAP_SIZE);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function setTile(mapId, x, y, tileId) {
	bitsy.set(mapId, (y * bitsy.MAP_SIZE) + x, tileId);
}

function drawTile(tileId, x, y) {
	setTile(bitsy.MAP1, x, y, tileId);
}

function drawSprite(tileId, x, y) {
	setTile(bitsy.MAP2, x, y, tileId);
}

function drawItem(tileId, x, y) {
	setTile(bitsy.MAP2, x, y, tileId);
}

// var debugLastRoomDrawn = "0";

function clearRoom() {
	var paletteId = "default";

	if (room === undefined) {
		// protect against invalid rooms
		return;
	}

	if (room.pal != null && palette[paletteId] != undefined) {
		paletteId = room.pal;
	}

	// clear background & foreground
	bitsy.fill(bitsy.MAP1, 0);
	bitsy.fill(bitsy.MAP2, 0);
}

function drawRoomBackground(room, frameIndex, redrawAnimatedOnly) {
	if (!redrawAnimatedOnly) {
		// clear background map
		bitsy.fill(bitsy.MAP1, 0);
	}

	// NOTE: interestingly the slowest part of this is iterating over all the tiles, not actually drawing them
	for (var y = 0; y < bitsy.MAP_SIZE; y++) {
		for (var x = 0; x < bitsy.MAP_SIZE; x++) {
			var id = room.tilemap[y][x];

			if (id != "0" && tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
				id = "0";
				room.tilemap[y][x] = id;
			}

			if (id != "0" && (!redrawAnimatedOnly || tile[id].animation.isAnimated)) {
				drawTile(getTileFrame(tile[id], frameIndex), x, y);
			}
		}
	}
}

function drawRoomForeground(room, frameIndex, redrawAnimatedOnly) {
	if (!redrawAnimatedOnly) {
		// clear foreground map
		bitsy.fill(bitsy.MAP2, 0);
	}

	// draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		if (!redrawAnimatedOnly || item[itm.id].animation.isAnimated) {
			drawItem(getItemFrame(item[itm.id], frameIndex), itm.x, itm.y);
		}
	}

	// draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (id != playerId && spr.room === room.id && (!redrawAnimatedOnly || spr.animation.isAnimated)) {
			drawSprite(getSpriteFrame(spr, frameIndex), spr.x, spr.y);
		}
	}
}

function drawRoomForegroundTile(room, frameIndex, x, y) {
	// draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		if (itm.x === x && itm.y === y) {
			drawItem(getItemFrame(item[itm.id], frameIndex), itm.x, itm.y);
		}
	}

	// draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (id != playerId && spr.room === room.id && spr.x === x && spr.y === y) {
			drawSprite(getSpriteFrame(spr, frameIndex), spr.x, spr.y);
		}
	}
}

function drawRoom(room, args) {
	if (room === undefined || isNarrating) {
		// protect against invalid rooms
		return;
	}

	var redrawAll = args && (args.redrawAll === true);
	var redrawAnimated = args && (args.redrawAnimated === true);
	var redrawAvatar = args && (args.redrawAvatar === true);
	var frameIndex = args ? args.frameIndex : undefined;

	// if *only* redrawing the avatar, first clear its previous position
	if (redrawAvatar) {
		setTile(bitsy.MAP2, playerPrevX, playerPrevY, 0);
		// also redraw any sprite or item that might be "under" the player (todo: possible perf issue?)
		drawRoomForegroundTile(room, frameIndex, playerPrevX, playerPrevY);
	}

	// draw background & foreground tiles
	if (redrawAll || redrawAnimated) {
		// draw tiles
		drawRoomBackground(room, frameIndex, redrawAnimated);
		// draw sprites & items
		drawRoomForeground(room, frameIndex, redrawAnimated);
	}

	// draw the player's avatar at its current position
	if ((redrawAll || redrawAnimated || redrawAvatar) && sprite[playerId] && sprite[playerId].room === room.id) {
		var spr = sprite[playerId];
		var x = spr.x;
		var y = spr.y;

		// get the avatar override sprite (if there is one)
		if (state.ava && state.ava != playerId && sprite[state.ava]) {
			spr = sprite[state.ava];
		}

		drawSprite(getSpriteFrame(spr, frameIndex), x, y);
	}
}

// TODO : remove these get*Image methods
function getTileFrame(t, frameIndex) {
	if (!renderer) {
		return null;
	}
	return renderer.GetDrawingFrame(t, frameIndex);
}

function getSpriteFrame(s, frameIndex) {
	if (!renderer) {
		return null;
	}
	return renderer.GetDrawingFrame(s, frameIndex);
}

function getItemFrame(itm, frameIndex) {
	if (!renderer) {
		return null;
	}
	return renderer.GetDrawingFrame(itm, frameIndex);
}

function curDefaultPal() {
	return getRoomPal(state.room);
}

function getRoomPal(roomId) {
	var defaultId = "default";

	if (roomId == null) {
		return defaultId;
	}
	else if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return defaultId;
		}
	}
	return defaultId;
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;

var dialogModule;
var dialogRenderer;
var dialogBuffer;
if (engineFeatureFlags.isDialogEnabled) {
	dialogModule = new Dialog();
	dialogRenderer = dialogModule.CreateRenderer();
	dialogBuffer = dialogModule.CreateBuffer();
}

var fontManager;
if (engineFeatureFlags.isFontEnabled) {
	fontManager = new FontManager();
}

// TODO : is this scriptResult thing being used anywhere???
function onExitDialog(scriptResult, dialogCallback) {
	isDialogMode = false;
	bitsy.textbox(false);

	if (isNarrating) {
		isNarrating = false;

		// redraw the room
		drawRoom(room[state.room], { redrawAll: true });
	}

	if (isDialogPreview) {
		isDialogPreview = false;

		if (onDialogPreviewEnd != null) {
			onDialogPreviewEnd();
		}
	}

	if (dialogCallback != undefined && dialogCallback != null) {
		dialogCallback(scriptResult);
	}

	if (soundPlayer) {
		soundPlayer.resumeTune();
	}
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr, end) {
	bitsy.log("NARRATE " + dialogStr);

	if(end === undefined) {
		end = false;
	}

	isNarrating = true;
	isEnding = end;

	if (isEnding && soundPlayer) {
		soundPlayer.stopTune();
	}

	// clear the room tiles before narrating
	bitsy.fill(bitsy.MAP1, 0);
	bitsy.fill(bitsy.MAP2, 0);

	startDialog(dialogStr);
}

function startEndingDialog(ending) {
	isNarrating = true;
	isEnding = true;

	var endingScriptId = ending.id;
	var endingDialogStr = dialog[ending.id].src;

	// compatibility with pre-7.0 endings
	if (flags.DLG_COMPAT === 1 && end[ending.id]) {
		endingScriptId = "end_compat_" + ending.id;
		endingDialogStr = end[ending.id].src;
	}

	var tmpTuneId = null;
	if (isEnding && soundPlayer) {
		tmpTuneId = soundPlayer.getCurTuneId();
		soundPlayer.stopTune();
	}

	startDialog(
		endingDialogStr,
		endingScriptId,
		function() {
			var isLocked = ending.property && ending.property.locked === true;
			if (isLocked) {
				isEnding = false;

				// if the ending was cancelled, restart the music
				// todo : should it resume from where it started? (right now it starts over)
				if (tmpTuneId && soundPlayer && !soundPlayer.isTunePlaying()) {
					soundPlayer.playTune(tune[tmpTuneId]);
				}
			}
		},
		ending);
}

function startItemDialog(itemId, dialogCallback) {
	var dialogId = item[itemId].dlg;
	// bitsy.log("START ITEM DIALOG " + dialogId);
	if (dialog[dialogId]) {
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr, dialogId, dialogCallback);
	}
	else {
		dialogCallback();
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg;

	// back compat for when dialog IDs were implicitly the same as sprite IDs
	if (flags.DLG_COMPAT === 1 && (dialogId === undefined || dialogId === null)) {
		dialogId = spr.id;
	}

	// bitsy.log("START SPRITE DIALOG " + dialogId);
	if (dialog[dialogId]){
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr, dialogId);
	}
}

function startDialog(dialogStr, scriptId, dialogCallback, objectContext) {
	bitsy.log("START DIALOG");

	if (soundPlayer) {
		soundPlayer.pauseTune();
	}

	if (dialogStr.length <= 0) {
		onExitDialog(null, dialogCallback);
		return;
	}

	if (!dialogBuffer) {
		bitsy.log(dialogStr);
		onExitDialog(null, dialogCallback);
		return;
	}

	if (!scriptInterpreter) {
		dialogRenderer.Reset();
		dialogRenderer.SetCentered(isNarrating /*centered*/);
		dialogBuffer.Reset();
		dialogBuffer.AddText(dialogStr);
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(null, dialogCallback);
		});
		bitsy.log("dialog start end");
		return;
	};

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(isNarrating /*centered*/);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	var onScriptEnd = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, dialogCallback);
		});
	};

	if (scriptId === undefined) { // TODO : what's this for again?
		scriptInterpreter.Interpret(dialogStr, onScriptEnd);
	}
	else {
		if (!scriptInterpreter.HasScript(scriptId)) {
			scriptInterpreter.Compile(scriptId, dialogStr);
		}
		// scriptInterpreter.DebugVisualizeScript(scriptId);
		scriptInterpreter.Run(scriptId, onScriptEnd, objectContext);
	}

}

var isDialogPreview = false;
function startPreviewDialog(script, dialogCallback) {
	if (!scriptInterpreter || !dialogBuffer) {
		return;
	}

	isNarrating = true;

	isDialogMode = true;

	isDialogPreview = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(true);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	// TODO : do I really need a seperate callback for this debug mode??
	onDialogPreviewEnd = dialogCallback;

	var onScriptEndCallback = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, null);
		});
	};

	scriptInterpreter.Eval(script, onScriptEndCallback);
}

/* NEW SCRIPT STUFF */
var scriptModule;
var scriptInterpreter;
var scriptUtils;
// scriptInterpreter.SetDialogBuffer( dialogBuffer );
if (engineFeatureFlags.isScriptEnabled) {
	bitsy.log("init script module");
	scriptModule = new Script();
	bitsy.log("init interpreter");
	scriptInterpreter = scriptModule.CreateInterpreter();
	bitsy.log("init utils");
	scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
	bitsy.log("init script module end");
}

/* SOUND */
var soundPlayer;
if (engineFeatureFlags.isSoundEnabled) {
	soundPlayer = new SoundPlayer();
}

/* EVENTS */
bitsy.loop(update);
</script>

<!-- store default font in separate script tag for back compat-->
<script type="text/bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 8220
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 8221
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 8216
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 8217
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
000000
000000
000000
001010
010100
000000
000000
000000
CHAR 160
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 161
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 162
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 163
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 165
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 167
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 171
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 172
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 177
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 178
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 187
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 188
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 189
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 191
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 196
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 197
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 198
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 199
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 201
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 209
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 214
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 220
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 223
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 224
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 225
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 226
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 230
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 231
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 232
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 233
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 234
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 235
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 236
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 237
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 238
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 239
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 241
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 242
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 243
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 244
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 246
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 247
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 249
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 250
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 251
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 252
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 255
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 402
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 915
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 920
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 931
011111
010000
001000
000100
001000
010000
011111
000000
CHAR 934
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 937
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 948
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 949
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 960
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 963
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 964
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 966
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 8226
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8252
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 8592
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 8593
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 8594
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 8595
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 8734
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 8735
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 8801
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 8804
000010
001100
010000
001100
000010
000000
011110
000000
CHAR 8805
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 8962
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 8976
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 9472
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 9474
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 9488
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 9492
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 9500
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 9508
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 9516
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 9524
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 9532
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 9552
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 9553
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 9556
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 9557
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 9558
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 9559
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 9561
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 9562
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 9563
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 9564
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 9565
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 9566
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 9567
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 9568
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 9569
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 9570
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 9571
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 9572
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 9573
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 9574
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 9575
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 9576
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 9577
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 9580
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 9601
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 9602
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 9603
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 9604
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 9605
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 9606
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 9607
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 9608
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 9609
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9610
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9611
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 9613
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 9615
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 9617
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 9618
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 9619
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 9644
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 9650
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 9658
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 9660
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 9668
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 9675
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 9688
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9689
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 9786
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 9787
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 9788
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 9792
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 9794
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 9824
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 9827
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 9829
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 9830
000000
000100
001110
011111
011111
001110
000100
000000
CHAR 9834
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 9835
000011
001101
001011
001101
001011
011011
011000
000000
</script>

</head>


<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
	<!-- GAME CANVAS -->
	<canvas id='game'></canvas>
</body>


</html>